ðŸ“¦
90000 /src/index.js.map
110019 /src/index.js
3818 /node_modules/@frida/base64-js/index.js
â†» base64-js
55789 /node_modules/@frida/buffer/index.js
â†» buffer
14098 /node_modules/@frida/events/events.js
â†» events
2221 /node_modules/@frida/ieee754/index.js
â†» ieee754
43649 /node_modules/@frida/path/index.js
â†» path
1484 /node_modules/@frida/process/index.js
â†» process
3314 /node_modules/@frida/readable-stream/errors.js
2861 /node_modules/@frida/readable-stream/lib/abort_controller.js
1277 /node_modules/@frida/readable-stream/lib/add-abort-signal.js
3714 /node_modules/@frida/readable-stream/lib/buffer_list.js
4033 /node_modules/@frida/readable-stream/lib/compose.js
7421 /node_modules/@frida/readable-stream/lib/destroy.js
11038 /node_modules/@frida/readable-stream/lib/duplex.js
5794 /node_modules/@frida/readable-stream/lib/end-of-stream.js
23064 /node_modules/@frida/readable-stream/lib/event_target.js
2536 /node_modules/@frida/readable-stream/lib/from.js
2818 /node_modules/@frida/readable-stream/lib/legacy.js
1317 /node_modules/@frida/readable-stream/lib/once.js
1666 /node_modules/@frida/readable-stream/lib/passthrough.js
7672 /node_modules/@frida/readable-stream/lib/pipeline.js
844 /node_modules/@frida/readable-stream/lib/promises.js
38711 /node_modules/@frida/readable-stream/lib/readable.js
807 /node_modules/@frida/readable-stream/lib/state.js
7777 /node_modules/@frida/readable-stream/lib/transform.js
5566 /node_modules/@frida/readable-stream/lib/utils.js
24496 /node_modules/@frida/readable-stream/lib/writable.js
1849 /node_modules/@frida/readable-stream/readable.js
â†» @frida/readable-stream
432 /node_modules/@frida/stream/index.js
â†» stream
9125 /node_modules/@frida/string_decoder/lib/string_decoder.js
â†» string_decoder
4686 /node_modules/@frida/util/support/types.js
19179 /node_modules/@frida/util/util.js
â†» util
35274 /node_modules/frida-fs/dist/index.js
â†» fs
105455 /node_modules/frida-il2cpp-bridge/dist/index.js.map
136509 /node_modules/frida-il2cpp-bridge/dist/index.js
â†» frida-il2cpp-bridge
âœ„
{"version":3,"file":"index.js","sourceRoot":"/home/sk/_projects/001webkinz/frida/","sources":["src/index.ts"],"names":[],"mappings":"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"}
âœ„
import "frida-il2cpp-bridge";
// ------- FUNCTION GLOBALS ------
// this sucks, but sure
// iterates to order logs by id in ./logs
var log_num = 0;
// values to help automatic gathering of public items
var GSFGetPublicItemsByOIDsSvc_lasthandled = 8140002;
var GSFGetPublicItemsByOIDsSvc_step = 1000;
var GSFGetPublicItemsByOIDsSvc_lastrun = Date.now();
var GSFGetPublicItemsByOIDsSvc_runstep = 10000;
// values to help automatic gathering of avatar accents
var GSFGetPublicAvatarAccentsByOIDsSvc_lasthandled = 0;
var GSFGetPublicAvatarAccentsByOIDsSvc_step = 1000;
var GSFGetPublicAvatarAccentsByOIDsSvc_lastrun = Date.now();
var GSFGetPublicAvatarAccentsByOIDsSvc_runstep = 10000;
// values to help automatic gathering of public assets but i don't think we ever did that
var create_GSFGetPublicAssetsByOIDsSvc_request_lasthandled = 0;
var create_GSFGetPublicAssetsByOIDsSvc_request_step = 1000;
// value to help automatic gathering of showcase avatars
var create_GSFGetShowcaseAvatarSvc_request_lasthandled = 211229;
// debug log consts
const UNSUPPORTED = "<errorSingleton: singleton intentionally unsupported>: ";
// ------- UTILITY FUNCTIONS -------
// grabs consts, il2cpp, etc.
// shorthand to get the image of any assembly. but . i think i did this one just beacuse of the name to be honest
function ass(assembly) {
    return Il2Cpp.domain.assembly(assembly).image;
}
// shorthand to get the Assembly-CSharp-firstpass image
function AssemblyCSharp() {
    return Il2Cpp.domain.assembly("Assembly-CSharp-firstpass").image;
}
// shorthand for the corlib Generic.List class
function List() {
    return Il2Cpp.corlib.class("System.Collections.Generic.List`1");
}
// shorthand to get the Assembly-CSharp image
function AssemblyCSharp_reg() {
    return Il2Cpp.domain.assembly("Assembly-CSharp").image;
}
// returns a nice filename for a json file, given an oid and a name
function get_json_filename(oid, name) {
    const oidName = oid.field("objectClass").value.toString() + "-" + oid.field("type").value.toString() + "-" + oid.field("server").value.toString() + "-" + oid.field("num").value.toString();
    const jsonName = oidName + " - " + name.toString().slice(1, -1) + ".json";
    return jsonName;
}
// check if field in given object is present
function present(object, field) {
    return !object.field(field).value.isNull();
}
// ------- GENERAL IDEAS -------
// things that are not necessarily il2cpp related
// appends given text to a given log file on the device to be pulled later
function write_log(file, ...msg) {
    const elements = file.split("/");
    const dir = Il2Cpp.application.dataPath + "/logs/" + elements.slice(0, -1).join("/");
    Java.perform(function () {
        Java.use('java.io.File').$new(dir).mkdirs();
    });
    const fd = new File(Il2Cpp.application.dataPath + "/logs/" + file, "a");
    const content = msg.join(" ");
    try {
        fd.write(content);
    }
    finally {
        fd.close();
    }
}
// hang the main thread for a given time [lol]
function wait(ms) {
    const start = Date.now();
    let now = start;
    while (now - start < ms) {
        now = Date.now();
    }
}
// ------- IL2CPP LOG HELPERS -------
// functions to quickly grab information from the game's internals
function log_TemplateCacheService_OnResolvePublicItemsByOIDsHandler() {
    const TemplateCacheService_OnResolvePublicItemsByOIDsHandler = AssemblyCSharp().class("TemplateCacheService").method("OnResolvePublicItemsByOIDsHandler");
    //@ts-ignore
    TemplateCacheService_OnResolvePublicItemsByOIDsHandler.implementation = function (session, response, request, viewContext) {
        console.log("\n");
        console.log("------- TemplateCacheService [OnResolvePublicItemsByOIDsHandler] -------");
        this.method("OnResolvePublicItemsByOIDsHandler").invoke(session, response, request, viewContext);
        console.log(viewContext);
        wait(1000);
        console.log(viewContext);
        // getting playeritem list and count
        var itemlist = viewContext.get(1);
        var itemcount = itemlist.method("get_Count").invoke();
        console.log("itemList of length: " + itemcount);
        for (let i = 0; i < itemcount; i++) {
            // log each GSFPlayerItem
            var GSFPlayerItem = itemlist.method("get_Item", 1).invoke(i);
            log_GSFPlayerItem_info(GSFPlayerItem, 0);
        }
    };
}
function log_GetPublicItemsByOIDs_request_ctor() {
    // takes list of OIDs
    // outputs general information about items provided
    const GetPublicItemsByOIDs_request_ctor = AssemblyCSharp().class("GSFGetPublicItemsByOIDsSvc").nested("GSFRequest").method(".ctor");
    // @ts-ignore
    GetPublicItemsByOIDs_request_ctor.implementation = function (oids, langlocalePairId, tierID, birthDate, registrationDate, previewDate, isPreviewEnabled) {
        console.log("\n");
        console.log("------- GetPublicItemsByOIDs [request, ctor] -------");
        console.log("oids of length: " + oids.method("get_Count").invoke());
        for (let i = 0; i < oids.method("get_Count").invoke(); i++) {
            console.log(oids.method("get_Item", 1).invoke(i));
        }
        console.log("tierID:" + tierID);
        console.log("langlocalePairID:" + langlocalePairId);
        console.log("birthDate:" + birthDate);
        console.log("registrationDate:" + registrationDate);
        console.log("previewDate:" + previewDate);
        console.log("isPreviewEnabled:" + isPreviewEnabled);
        this.method(".ctor").invoke(oids, langlocalePairId, tierID, birthDate, registrationDate, previewDate, isPreviewEnabled);
    };
}
function log_GSFGetPublicItemsByOIDsSvc_request_info(GSFGetPublicItemsByOIDsSvc, indent) {
    var ind = "  ".repeat(indent);
    console.log(ind + "GSFGetPublicItemsByOIDsSvc+GSFRequest:");
    const oids = GSFGetPublicItemsByOIDsSvc.field("oids").value;
    const oidsLength = oids.method("get_Count").invoke();
    console.log(ind + "oids of length: " + oidsLength);
    for (let i = 0; i < oidsLength; i++) {
        const oid = oids.method("get_Item", 1).invoke(i);
        console.log(ind + "oid: " + get_GSFOID_string(oid));
    }
    console.log(ind + "tierID:" + get_GSFOID_string(GSFGetPublicItemsByOIDsSvc.field("tierID").value));
    console.log(ind + "langlocalePairID:" + get_GSFOID_string(GSFGetPublicItemsByOIDsSvc.field("langlocalePairID").value));
    console.log(ind + "birthDate:" + GSFGetPublicItemsByOIDsSvc.field("birthDate").value);
    console.log(ind + "registrationDate:" + GSFGetPublicItemsByOIDsSvc.field("registrationDate").value);
    console.log(ind + "previewDate:" + GSFGetPublicItemsByOIDsSvc.field("previewDate").value);
    console.log(ind + "isPreviewEnabled:" + GSFGetPublicItemsByOIDsSvc.field("isPreviewEnabled").value);
}
function log_GSFCommsObject_ctor() {
    const GSFCommsObject_ctor = AssemblyCSharp().class("GSFCommsObject").method(".ctor");
    //@ts-ignore
    GSFCommsObject_ctor.implementation = function (...args) {
        this.method(".ctor").invoke(...args);
        console.log(JSON.stringify(str_Il2Cpp_Object(this), null, 4));
    };
}
function log_GSFAddEventSvc_request_ctor() {
    const GSFAddEventSvc_request_ctor = AssemblyCSharp().class("GSFAddEventSvc").nested("GSFRequest").method(".ctor");
    //@ts-ignore
    GSFAddEventSvc_request_ctor.implementation = function (eventID, eventObjectID, targetObjectID, targetObjectTemplateID, contextIDs, dynamicAttributes, returnRewards, count, broadcast) {
        console.log("\n");
        console.log("------- GSFAddEvent [request, ctor] -------");
        console.log("eventObjectId: " + eventObjectID.isNull() ? null : get_GSFOID_string(eventObjectID));
        console.log("targetObjectId: " + get_GSFOID_string(targetObjectID));
        console.log("targetObjectTemplateId: " + get_GSFOID_string(targetObjectTemplateID));
        if (!contextIDs.isNull()) {
            const contextIDsLength = contextIDs.method("get_Count").invoke();
            console.log("contextIDs of length: " + contextIDsLength);
            for (var i = 0; i < contextIDsLength; i++) {
                const oid = contextIDs.method("get_Item").invoke(i);
                console.log(oid);
            }
        }
        else {
            console.log("contextIDs: null");
        }
        if (!dynamicAttributes.isNull()) {
            const dynamicAttributesLength = dynamicAttributes.method("get_Count").invoke();
            console.log("contextIDs of length: " + dynamicAttributesLength);
            for (var i = 0; i < dynamicAttributesLength; i++) {
                const dynamicAttribute = dynamicAttributes.method("get_Item").invoke(i);
                console.log(dynamicAttribute);
            }
        }
        else {
            console.log("dynamicAttributes: null");
        }
        console.log("returnRewards: " + returnRewards);
        console.log("broadcast: " + broadcast);
        this.method(".ctor").invoke(eventID, eventObjectID, targetObjectID, targetObjectTemplateID, contextIDs, dynamicAttributes, returnRewards, count, broadcast);
    };
}
function log_GSFChangePlayerStatNotify_request_des() {
    const GSFChangePlayerStatNotify_request_des = AssemblyCSharp().class("GSFChangePlayerStatNotify").nested("GSFRequest").method("DeserializeMembers");
    //@ts-ignore
    GSFChangePlayerStatNotify_request_des.implementation = function (protocol, output) {
        console.log("\n");
        console.log("------- GSFChangePlayerStatNotify [request, des] -------");
        this.method("DeserializeMembers").invoke(protocol, output);
        console.log("parentInstanceID: " + get_GSFOID_string(this.field("parentInstanceID").value));
        console.log("instanceID: " + get_GSFOID_string(this.field("instanceID").value));
        console.log("templateID: " + get_GSFOID_string(this.field("templateID").value));
        console.log("pid: " + get_GSFOID_string(this.field("pid").value));
        console.log("vid: " + get_GSFOID_string(this.field("vid").value));
        console.log("lid: " + get_GSFOID_string(this.field("lid").value));
        console.log("oldLevel: " + this.field("oldLevel").value);
        console.log("newLevel: " + this.field("newLevel").value);
        console.log("contextTag: " + this.field("contextTag").value);
        console.log("------- GSFChangePlayerStatNotify [request, des] -------");
    };
}
function log_GSFAddEventSvc_response_des() {
    const GSFAddEventSvc_response_des = AssemblyCSharp().class("GSFAddEventSvc").nested("GSFResponse").method("DeserializeMembers");
    //@ts-ignore
    GSFAddEventSvc_response_des.implementation = function (protocol, output) {
        console.log("\n");
        console.log("------- GSFAddEvent [response, des] -------");
        this.method("DeserializeMembers").invoke(protocol, output);
        console.log(this.field("questAwardElements").value);
        console.log(this.field("questAwardElements").value.method("get_Count").invoke());
        console.log("------- GSFAddEvent [response, des] -------");
    };
}
function log_GetPublicItemsByOIDs_response_des() {
    const GetPublicItemsByOIDs_response_des = AssemblyCSharp().class("GSFGetPublicItemsByOIDsSvc").nested("GSFResponse").method("DeserializeMembers");
    //@ts-ignore
    GetPublicItemsByOIDs_response_des.implementation = function (protocol, input) {
        console.log("\n");
        console.log("------- GetPublicItemsByOIDs [response, des] -------");
        this.method("DeserializeMembers").invoke(protocol, input);
        var itemlist = this.field("items").value;
        var items = itemlist.method("get_Count").invoke();
        console.log("itemList of length: " + itemlist.method("get_Count").invoke());
        for (let i = 0; i < items; i++) {
            var item = itemlist.method("get_Item", 1).invoke(i);
            if (!item.isNull()) {
                console.log(JSON.stringify(stringify_GSFItem(item), null, 4));
                //log_GSFItem_info(item, 1, false)
                // const oidName = item.field<Il2Cpp.Object>("oid").value.field<number>("objectClass").value.toString() + "-" + item.field<Il2Cpp.Object>("oid").value.field<number>("type").value.toString() + "-" + item.field<Il2Cpp.Object>("oid").value.field<number>("server").value.toString() + "-" + item.field<Il2Cpp.Object>("oid").value.field<number>("num").value.toString()
                // const jsonName = oidName + " - " + item.field<Il2Cpp.String>("name").value.toString().slice(1,-1) + ".json"
                // write_log(jsonName, JSON.stringify(stringify_GSFItem(item)))
            }
        }
        console.log("------- GetPublicItemsByOIDs [response, des] -------");
    };
}
function log_GSFGetPublicAvatarAccentsByOIDsSvc_response_des(write_json) {
    const GetPublicAvatarAccentsByOIDsSvc_response_des = AssemblyCSharp().class("GSFGetPublicAvatarAccentsByOIDsSvc").nested("GSFResponse").method("DeserializeMembers");
    //@ts-ignore
    GetPublicAvatarAccentsByOIDsSvc_response_des.implementation = function (protocol, input) {
        console.log("\n");
        console.log("------- GSFGetPublicAvatarAccentsByOIDsSvc [response, des] -------");
        this.method("DeserializeMembers").invoke(protocol, input);
        var accents = this.field("accents").value;
        var accentsLength = accents.method("get_Count").invoke();
        console.log("accents of length: " + accentsLength);
        for (let i = 0; i < accentsLength; i++) {
            var GSFAvatarAccent = accents.method("get_Item", 1).invoke(i);
            if (!GSFAvatarAccent.isNull()) {
                log_GSFAvatarAccent_info(GSFAvatarAccent, 1, false);
                if (write_json) {
                    const jsonName = get_json_filename(GSFAvatarAccent.field("oid").value, GSFAvatarAccent.field("description").value);
                    write_log("GSFAvatarAccent/" + jsonName, JSON.stringify(stringify_GSFAvatarAccent(GSFAvatarAccent)));
                }
            }
        }
        console.log("------- GSFGetPublicAvatarAccentsByOIDsSvc [response, des] -------");
    };
}
function log_GetAssetsByOIDs_response_des() {
    const GetAssetsByOIDs_response_des = AssemblyCSharp().class("GSFGetAssetsByOIDsSvc").nested("GSFResponse").method("DeserializeMembers");
    //@ts-ignore
    GetAssetsByOIDs_response_des.implementation = function (protocol, input) {
        console.log("\n");
        console.log("------- GetAssetsByOIDs [response, des] -------");
        this.method("DeserializeMembers").invoke(protocol, input);
        // getting assets list and count
        var itemlist = this.field("assets").value;
        var items = itemlist.method("get_Count").invoke();
        for (let i = 0; i < items; i++) {
            // get each assetcontainer
            var asset_container = itemlist.method("get_Item", 1).invoke(i);
            // copy contained dictionary to array of dictionary's contained lists
            var dict = asset_container.field("assetMap").value;
            var dict_values = dict.method("get_Values").invoke();
            var new_dict_length = dict.method("get_Count").invoke();
            console.log("assetmap items: " + new_dict_length);
            var asset_container_array = Il2Cpp.array(List(), new_dict_length);
            dict_values.method("CopyTo").invoke(asset_container_array, 0);
            // parse contained lists and log their gsfassets
            for (var list of asset_container_array) {
                var length = list.method("get_Count").invoke();
                for (let i = 0; i < length; i++) {
                    var gsfasset = list.method("get_Item", 1).invoke(i);
                    console.log(gsfasset.field("resName").value + ": " + gsfasset.field("cdnId").value);
                }
            }
        }
        console.log("oid count:" + itemlist.method("get_Count").invoke());
    };
}
function log_GetAssetsByOIDs_request_ctor() {
    const GetAssetsByOIDs_request_ctor = AssemblyCSharp().class("GSFGetAssetsByOIDsSvc").nested("GSFRequest").method(".ctor", 1);
    //@ts-ignore
    GetAssetsByOIDs_request_ctor.implementation = function (oids) {
        console.log("\n");
        console.log("------- GetAssetsByOIDs [request, ctor] -------");
        var oid_count = oids.method("get_Count").invoke();
        for (let i = 0; i < oid_count; i++) {
            var oid = oids.method("get_Item", 1).invoke(i);
            console.log("requested " + i + ": " + oid);
        }
        this.method(".ctor", 1).invoke(oids);
    };
}
function log_GSFGetPlayerAvatarsSvc_request_ctor() {
    const GSFGetPlayerAvatarsSvc_request_ctor = AssemblyCSharp().class("GSFGetPlayerAvatarsSvc").nested("GSFRequest").method(".ctor", 3);
    //@ts-ignore
    GSFGetPlayerAvatarsSvc_request_ctor.implementation = function (playerId, playerMazeId, filterIDs) {
        console.log("\n");
        playerId = create_GSFOID(4, 1, 2, 286043);
        console.log("------- GSFGetPlayerAvatarsSvc [request, ctor] -------");
        console.log("playerId: " + get_GSFOID_string(playerId));
        if (!playerMazeId.isNull()) {
            console.log("playerMazeId: " + get_GSFOID_string(playerMazeId));
        }
        else {
            console.log("playerMazeId: null");
        }
        if (!filterIDs.isNull()) {
            var filterIDsLength = filterIDs.method("get_Count").invoke();
            console.log("filterIDs of length " + filterIDsLength + ":");
            for (let i = 0; i < filterIDsLength; i++) {
                console.log(filterIDsLength);
                var oid = filterIDs.method("get_Item", 1).invoke(i);
                console.log("filterID " + i + ": " + oid);
            }
        }
        else {
            console.log("filterIDs: null");
        }
        console.log("------- GSFGetPlayerAvatarsSvc [request, ctor] -------");
        this.method(".ctor", 3).invoke(playerId, playerMazeId, filterIDs);
    };
}
function log_GSFAvatarShowcase_des() {
    const GSFAvatarShowcase_des = AssemblyCSharp().class("GSFAvatarShowcase").method("DeserializeMembers");
    //@ts-ignore
    GSFAvatarShowcase_des.implementation = function (protocol, input) {
        console.log("\n");
        console.log("------- GSFAvatarShowcase [des] -------");
        this.method("DeserializeMembers").invoke(protocol, input);
        console.log("baby:");
        console.log(JSON.stringify(this.field("baby").value));
        console.log("primaryParent:");
        console.log(JSON.stringify(this.field("primaryParent").value));
        console.log("secondaryParent:");
        console.log(JSON.stringify(this.field("secondaryParent").value));
    };
}
function log_GSFGetPlayerAvatarsSvc_response_des() {
    const GSFGetPlayerAvatarsSvc_response_des = AssemblyCSharp().class("GSFGetPlayerAvatarsSvc").nested("GSFResponse").method("DeserializeMembers");
    //@ts-ignore
    GSFGetPlayerAvatarsSvc_response_des.implementation = function (protocol, input) {
        this.method("DeserializeMembers").invoke(protocol, input);
        console.log(JSON.stringify(str_Il2Cpp_Object(this), null, 4));
        // old method
        // console.log("\n")
        // console.log("------- GSFGetPlayerAvatarsSvc [response, des] -------")
        // this.method("DeserializeMembers").invoke(protocol, input);
        // var avatars = this.field<Il2Cpp.Object>("avatars").value
        // var avatarsLength = avatars.method<number>("get_Count").invoke();
        // console.log("avatars of length: " + avatars.method<number>("get_Count").invoke())
        // for (let i = 0; i < avatarsLength; i++) {
        //     var GSFPlayerAvatar = avatars.method<Il2Cpp.Object>("get_Item", 1).invoke(i)
        //     if (!GSFPlayerAvatar.isNull()) {
        //         console.log(JSON.stringify(stringify_GSFPlayerAvatar(GSFPlayerAvatar), null, 2))
        //     }
        // }
        // console.log("------- GSFGetPlayerAvatarsSvc [response, des] -------")
    };
}
function log_GSFGetShowcaseAvatarSvc_response_des() {
    const GSFGetShowcaseAvatarSvc_response_des = AssemblyCSharp().class("GSFGetShowcaseAvatarSvc").nested("GSFResponse").method("DeserializeMembers");
    //@ts-ignore
    GSFGetShowcaseAvatarSvc_response_des.implementation = function (protocol, input) {
        console.log("\n");
        console.log("------- GSFGetShowcaseAvatarSvc [response, des] -------");
        this.method("DeserializeMembers").invoke(protocol, input);
        console.log(JSON.stringify(stringify_GSFAvatarShowcase(this.field("showcase").value), null, 4));
        console.log("------- GSFGetShowcaseAvatarSvc [response, des] -------");
    };
}
function log_GSFGetShowcaseAvatarsSvc_response_des() {
    const GSFGetShowcaseAvatarsSvc_response_des = AssemblyCSharp().class("GSFGetShowcaseAvatarsSvc").nested("GSFResponse").method("DeserializeMembers");
    //@ts-ignore
    GSFGetShowcaseAvatarsSvc_response_des.implementation = function (protocol, input) {
        console.log("\n");
        console.log("------- GSFGetShowcaseAvatarsSvc [response, des] -------");
        this.method("DeserializeMembers").invoke(protocol, input);
        const showcase = this.field("showcase").value;
        const showcaseLength = showcase.method("get_Count").invoke();
        console.log("showcase of length: " + showcaseLength);
        for (var i = 0; i < showcaseLength; i++) {
            const GSFAvatarShowcaseString = stringify_GSFAvatarShowcase(showcase.method("get_Item").invoke(i));
            console.log(JSON.stringify(GSFAvatarShowcaseString, null, 4));
            const baby_oid = showcase.method("get_Item").invoke(i).field("baby").value.field("oid").value;
            write_log("GSFAvatarShowcase/" + get_json_filename(baby_oid, Il2Cpp.string(GSFAvatarShowcaseString.baby.name)), JSON.stringify(GSFAvatarShowcaseString, null, 4));
        }
        console.log("------- GSFGetShowcaseAvatarsSvc [response, des] -------");
    };
}
function log_GetPublicAssetsByOIDs_response_des() {
    const GetPublicAssetsByOIDs_response_des = AssemblyCSharp().class("GSFGetPublicAssetsByOIDsSvc").nested("GSFResponse").method("DeserializeMembers");
    //@ts-ignore
    GetPublicAssetsByOIDs_response_des.implementation = function (protocol, input) {
        console.log("\n");
        console.log("------- GetPublicAssetsByOIDs [response, des] -------");
        this.method("DeserializeMembers").invoke(protocol, input);
        // getting assets list and count
        var itemlist = this.field("assets").value;
        var items = itemlist.method("get_Count").invoke();
        for (let i = 0; i < items; i++) {
            // get each assetcontainer
            var asset_container = itemlist.method("get_Item", 1).invoke(i);
            // copy contained dictionary to array of dictionary's contained lists
            var dict = asset_container.field("assetMap").value;
            var dict_values = dict.method("get_Values").invoke();
            var new_dict_length = dict.method("get_Count").invoke();
            console.log("assetmap items: " + new_dict_length);
            var asset_container_array = Il2Cpp.array(List(), new_dict_length);
            dict_values.method("CopyTo").invoke(asset_container_array, 0);
            // parse contained lists and log their gsfassets
            for (var list of asset_container_array) {
                var length = list.method("get_Count").invoke();
                for (let i = 0; i < length; i++) {
                    var gsfasset = list.method("get_Item", 1).invoke(i);
                    console.log(gsfasset.field("resName").value + ": " + gsfasset.field("cdnId").value);
                }
            }
        }
        console.log("oid count:" + itemlist.method("get_Count").invoke());
    };
}
function log_TemplateCacheService_GetAssetsByOIDs() {
    const TemplateCacheService_GetAssetsByOIDs = AssemblyCSharp().class("TemplateCacheService").method("GetAssetsByOIDs");
    //@ts-ignore
    TemplateCacheService_GetAssetsByOIDs.implementation = function (oids) {
        console.log("\n");
        console.log("------- TemplateCacheService [main, getassetsbyoids] -------");
        var oid_count = oids.method("get_Count").invoke();
        for (let i = 0; i < oid_count; i++) {
            var oid = oids.method("get_Item", 1).invoke(i);
            console.log("requested " + i + ": " + oid);
        }
        this.method("GetAssetsByOIDs", 1).invoke(oids);
    };
}
function log_GSFOtherPlayerDetails_GetPlayerAvatars() {
    const GSFOtherPlayerDetails_GetPlayerAvatars = AssemblyCSharp().class("GSFOtherPlayerDetails").method("GetPlayerAvatars");
    //@ts-ignore
    GSFOtherPlayerDetails_GetPlayerAvatars.implementation = function () {
        console.log("\n");
        console.log("------- GSFOtherPlayerDetails [main, getplayeravatars] -------");
        var playerAvatars = this.method("GetPlayerAvatars").invoke();
        // var playerAvatarsLength = playerAvatars.method<number>("get_Count").invoke();
        // console.log("playerAvatars of length: " + playerAvatarsLength)
        // for (let i = 0; i < playerAvatarsLength; i++) {
        //     var avatar = playerAvatars.method<Il2Cpp.Object>("get_Item", 1).invoke(i)
        //     console.log(JSON.stringify(stringify_GSFPlayerAvatar))
        // }
        return playerAvatars;
    };
}
function log_PetBaseController_ConsumeFoodItem() {
    const GSFOtherPlayerDetails_GetPlayerAvatars = AssemblyCSharp_reg().class("PetBaseController").method("ConsumeFoodItem");
    //@ts-ignore
    GSFOtherPlayerDetails_GetPlayerAvatars.implementation = function (foodItem) {
        console.log("\n");
        console.log("------- PetBaseController [main, consumefooditem] -------");
        console.log(JSON.stringify(stringify_GSFPlayerItem(foodItem), null, 4));
        this.method("ConsumeFoodItem").invoke(foodItem);
        console.log("------- PetBaseController [main, consumefooditem] -------");
    };
}
function log_DockServices_FullDecayInventoryItem() {
    const DockServices_FullDecayInventoryItem = AssemblyCSharp().class("DockServices").method("FullDecayInventoryItem", 1);
    //@ts-ignore
    DockServices_FullDecayInventoryItem.implementation = function (playerItemId) {
        console.log("\n");
        console.log("------- DockServices [main, fulldecayinventoryitem] -------");
        console.log("oid: " + get_GSFOID_string(playerItemId));
        console.log("fullDecay: " + this.field("fullDecay").value.field("hiddenValue").value);
        return this.method("FullDecayInventoryItem", 1).invoke(playerItemId);
    };
}
function log_DockServices_OnFullDecayInventoryItemHandler() {
    const DockServices_OnFullDecayInventoryItemHandler = AssemblyCSharp().class("DockServices").method("OnFullDecayInventoryItemHandler");
    //@ts-ignore
    DockServices_OnFullDecayInventoryItemHandler.implementation = function (session, response, request, viewContext) {
        console.log("\n");
        console.log("------- DockServices [main, onfulldecayinventoryitemhandler] -------");
        console.log(response.field("body").value);
        console.log(response.field("body").value.field("questAwardElements").value);
        console.log(response.field("body").value.field("questAwardElements").value.method("get_Count").invoke());
        this.method("OnFullDecayInventoryItemHandler").invoke(session, response, request, viewContext);
    };
}
function get_GSFOID_string(GSFOID) {
    return GSFOID.method("ToString").invoke();
}
function log_GSFPlayerItem_info(GSFPlayerItem, indent) {
    var ind = "  ".repeat(indent);
    console.log(ind + "GSFPlayerItem: " + get_GSFOID_string(GSFPlayerItem.field("itemID").value));
    const slotId = GSFPlayerItem.field("slotId").value;
    if (!slotId.isNull()) {
        console.log(ind + "slotId: " + get_GSFOID_string(slotId));
    }
    const playerId = GSFPlayerItem.field("playerId").value;
    if (!playerId.isNull()) {
        console.log(ind + "playerId: " + get_GSFOID_string(playerId));
    }
    console.log(ind + "quantity: " + GSFPlayerItem.field("quantity").value);
    console.log(ind + "itemState: " + GSFPlayerItem.field("itemState").value);
    const item = GSFPlayerItem.field("item").value;
    if (!item.isNull()) {
        console.log(ind + "item: ");
        log_GSFItem_info(item, indent + 1, false);
    }
    // iterate and log list of attached items
    var attachedItems = GSFPlayerItem.field("attachedItems").value;
    if (!attachedItems.isNull()) {
        var attachedItemsLength = attachedItems.method("get_Count").invoke();
        console.log(ind + "attachedItems of length: " + attachedItemsLength);
        for (let i = 0; i < attachedItemsLength; i++) {
            var attachedGSFPlayerItem = attachedItems.method("get_Item", 1).invoke(i);
            log_GSFPlayerItem_info(attachedGSFPlayerItem, indent + 1);
        }
    }
}
function log_GSFAvatarAccent_info(GSFAvatarAccent, indent, inherit) {
    var ind = "  ".repeat(indent);
    if (inherit) {
        console.log(ind + "description: " + GSFAvatarAccent.field("description").value);
    }
    else {
        console.log(ind + "GSFAvatarAccent: " + GSFAvatarAccent.field("description").value);
    }
    console.log(ind + "oid: " + GSFAvatarAccent.field("oid").value);
    console.log(ind + "accentType: " + GSFAvatarAccent.field("accentType").value);
    console.log(ind + "rarityType: " + GSFAvatarAccent.field("rarityType").value);
    console.log(ind + "rarity: " + GSFAvatarAccent.field("rarity").value);
    console.log(ind + "isTransferable: " + GSFAvatarAccent.field("isTransferable").value);
    console.log(ind + "isReflective: " + GSFAvatarAccent.field("isReflective").value);
    console.log(ind + "inheritColor: " + GSFAvatarAccent.field("inheritColor").value);
    console.log(ind + "param: " + GSFAvatarAccent.field("param").value);
    console.log(ind + "poolType: " + GSFAvatarAccent.field("poolType").value);
    log_GSFAssetContainer_info(GSFAvatarAccent, indent, true);
}
function log_GSFItem_info(GSFItem, indent, inherit) {
    var ind = "  ".repeat(indent);
    if (inherit) {
        console.log(ind + "name: " + GSFItem.field("name").value);
    }
    else {
        console.log(ind + "GSFItem: " + GSFItem.field("name").value);
    }
    console.log(ind + "oid: " + GSFItem.field("oid").value);
    console.log(ind + "quantity: " + GSFItem.field("quantity").value);
    log_GSFAssetContainer_info(GSFItem, indent, true);
}
function log_GSFAssetContainer_info(GSFAssetContainer, indent, inherit) {
    var ind = "  ".repeat(indent);
    if (!inherit) {
        console.log(ind + "GSFAssetContainer: " + GSFAssetContainer.field("oid").value);
    }
    // get assetMap info
    var assetMap = GSFAssetContainer.field("assetMap").value;
    var assetMapLength = assetMap.method("get_Count").invoke();
    var assetMapValues = assetMap.method("get_Values").invoke();
    console.log(ind + "assetMap of length: " + assetMapLength);
    // rehouse values into il2cpp array
    var assetMapArray = Il2Cpp.array(List(), assetMapLength);
    assetMapValues.method("CopyTo").invoke(assetMapArray, 0);
    // array now contains lists of gsfassets
    // parse contained lists and log their gsfassets
    for (var assetList of assetMapArray) {
        var assetListLength = assetList.method("get_Count").invoke();
        for (let i = 0; i < assetListLength; i++) {
            var GSFAsset = assetList.method("get_Item", 1).invoke(i);
            log_GSFAsset_info(GSFAsset, indent + 1);
        }
    }
    // iterate and log list of assetpackages
    var assetPackages = GSFAssetContainer.field("assetPackages").value;
    var assetPackagesLength = assetPackages.method("get_Count").invoke();
    console.log(ind + "assetPackages of length: " + assetPackagesLength);
    for (let i = 0; i < assetPackagesLength; i++) {
        var GSFAssetPackage = assetPackages.method("get_Item", 1).invoke(i);
        log_GSFAssetPackage_info(GSFAssetPackage, indent + 1);
    }
}
function log_GSFAssetPackage_info(GSFAssetPackage, indent) {
    var ind = "  ".repeat(indent);
    console.log(ind + "GSFAssetPackage: " + GSFAssetPackage.field("pTag").value);
    log_GSFAssetContainer_info(GSFAssetPackage, indent, true);
}
function log_GSFAsset_info(GSFAsset, indent) {
    var ind = "  ".repeat(indent);
    console.log(ind + "GSFAsset: " + GSFAsset.field("resName").value);
    console.log(ind + "groupName: " + GSFAsset.field("groupName").value);
    console.log(ind + "assetTypeName: " + GSFAsset.field("assetTypeName").value);
    console.log(ind + "cdnId: " + GSFAsset.field("cdnId").value);
}
function log_GetPlayerInventoryByItemCategory_response_des() {
    const GetPlayerInventoryByItemCategory_response_des = AssemblyCSharp().class("GSFGetPlayerInventoryByItemCategorySvc").nested("GSFResponse").method("DeserializeMembers", 2);
    //@ts-ignore
    GetPlayerInventoryByItemCategory_response_des.implementation = function (protocol, input) {
        console.log("\n");
        console.log("------- GetPlayerInventoryByItemCategory [response, des] -------");
        this.method("DeserializeMembers", 2).invoke(protocol, input);
        // getting playeritem list and count
        var itemlist = this.field("playerItems").value;
        var itemcount = itemlist.method("get_Count").invoke();
        console.log("itemList of length: " + itemcount);
        for (let i = 0; i < itemcount; i++) {
            // log each GSFPlayerItem
            var GSFPlayerItem = itemlist.method("get_Item", 1).invoke(i);
            log_GSFPlayerItem_info(GSFPlayerItem, 0);
        }
    };
}
function log_to_file_GSFOID_ctor() {
    const GSFOID = AssemblyCSharp().class("GSFOID").method(".ctor", 4);
    const GSFOIDctorbyte = GSFOID;
    //@ts-ignore
    GSFOIDctorbyte.implementation = function (svcClass, objType, server, objNum) {
        write_log("oidlog_byte", svcClass + ", " + objType + ", " + server + ", " + objNum + "\n");
        this.method(".ctor", 4).invoke(svcClass, objType, server, objNum);
    };
    const GSFOIDctorlong = AssemblyCSharp().class("GSFOID").method(".ctor", 1);
    //@ts-ignore
    GSFOIDctorlong.implementation = function (l) {
        write_log("oidlog_long", l.toString());
        this.method(".ctor", 1).invoke(l);
    };
}
//function log_to_file_
// ------- IL2CPP EDITORS -------
// functions to modify method parameters
function modify_GSFOtherPlayerDetails_GetPlayerAvatar() {
    const GSFOtherPlayerDetails_GetPlayerAvatar = AssemblyCSharp().class("GSFOtherPlayerDetails").method("GetPlayerAvatar");
    //@ts-ignore
    GSFOtherPlayerDetails_GetPlayerAvatar.implementation = function (playerAvatarId) {
        console.log("\n");
        console.log("------- Modified GSFOtherPlayerDetails [main, getplayeravatar] -------");
        var GSFPlayerAvatar = this.method("GetPlayerAvatar").invoke(create_GSFOID(4, 11, 2, 250561));
        console.log("GSFPlayerAvatar: " + GSFPlayerAvatar);
        return GSFPlayerAvatar;
    };
}
function modify_GSFGetShowcaseAvatarsSvc_ctor(rarity, size) {
    const GSFGetShowcaseAvatarsSvc_ctor = AssemblyCSharp().class("GSFGetShowcaseAvatarsSvc").nested("GSFRequest");
    //@ts-ignore
    GSFGetShowcaseAvatarsSvc_ctor.method(".ctor").implementation = function (rarity_ctor, size_ctor) {
        console.log("\n");
        console.log("------- Modified GSFGetShowcaseAvatarsSvc [request, ctor] -------");
        console.log("rarity: " + rarity_ctor + " -> " + rarity);
        console.log("size: " + size_ctor + " -> " + size);
        console.log("------- Modified GSFGetShowcaseAvatarsSvc [request, ctor] -------");
        // replace rarity/size with our own value
        rarity_ctor = rarity;
        size_ctor = size;
        this.method(".ctor").invoke(rarity, size);
    };
}
function modify_GSFGetPublicAvatarAccentsByOIDsSvc_ctor() {
    const GSFGetPublicAvatarAccentsByOIDsSvc_request = AssemblyCSharp().class("GSFGetPublicAvatarAccentsByOIDsSvc").nested("GSFRequest");
    //@ts-ignore
    GSFGetPublicAvatarAccentsByOIDsSvc_request.method(".ctor").implementation = function (oids, langlocalePairID, tierID, birthDate, registrationDate, previewDate, isPreviewEnabled) {
        // clear list, so we never get correct cache calls and can keep calling
        oids.method("Clear").invoke();
        // replacing GSFOIDs with our own if time for next run has passed
        if (Date.now() - GSFGetPublicAvatarAccentsByOIDsSvc_lastrun > GSFGetPublicAvatarAccentsByOIDsSvc_runstep) {
            replace_GSFOID_list(oids, 4, 200, 0, GSFGetPublicAvatarAccentsByOIDsSvc_lasthandled + GSFGetPublicAvatarAccentsByOIDsSvc_step, GSFGetPublicAvatarAccentsByOIDsSvc_lasthandled);
            console.log("\n");
            console.log("------- Modified GSFGetPublicAvatarAccentsByOIDsSvc [request, ctor] -------");
            console.log("oids of length: " + oids.method("get_Count").invoke());
            for (let i = 0; i < oids.method("get_Count").invoke(); i++) {
                console.log(oids.method("get_Item", 1).invoke(i));
            }
            console.log("tierID:" + tierID);
            console.log("langlocalePairID:" + langlocalePairID);
            console.log("birthDate:" + birthDate);
            console.log("registrationDate:" + registrationDate);
            console.log("previewDate:" + previewDate);
            console.log("isPreviewEnabled:" + isPreviewEnabled);
            GSFGetPublicAvatarAccentsByOIDsSvc_lastrun = Date.now();
            GSFGetPublicAvatarAccentsByOIDsSvc_lasthandled += GSFGetPublicAvatarAccentsByOIDsSvc_step;
            write_log("lasthandled_GSFGetPublicAvatarAccentsByOIDsSvc.log", GSFGetPublicAvatarAccentsByOIDsSvc_lasthandled.toString());
        }
        this.method(".ctor").invoke(oids, langlocalePairID, tierID, birthDate, registrationDate, previewDate, isPreviewEnabled);
    };
}
function modify_GSFHeartbeatSvc_request_ctor() {
    const GetAssetsByOIDs_request_ctor = AssemblyCSharp().class("GSFHeartbeatSvc").nested("GSFRequest").method(".ctor");
    //@ts-ignore
    GetAssetsByOIDs_request_ctor.implementation = function (activity, xCoordinate, yCoordinate, zCoordinate, inactivityTime) {
        this.method(".ctor").invoke(activity, xCoordinate, yCoordinate, zCoordinate, 0);
    };
}
function modify_GetAssetsByOIDs_request_ctor() {
    const GetAssetsByOIDs_request_ctor = AssemblyCSharp().class("GSFGetAssetsByOIDsSvc").nested("GSFRequest").method(".ctor", 1);
    //@ts-ignore
    GetAssetsByOIDs_request_ctor.implementation = function (oids) {
        console.log("called...");
        replace_GSFOID_list(oids, 4, 73, 0, 9617559 + 50, 9617559 - 50);
        this.method(".ctor", 1).invoke(oids);
        console.log(stringify(str_Il2Cpp_Object(this, 0)));
    };
}
function modify_TemplateCacheService_OnResolvePublicItemsByOIDsHandler() {
    const TemplateCacheService_OnResolvePublicItemsByOIDsHandler = AssemblyCSharp().class("TemplateCacheService").method("OnResolvePublicItemsByOIDsHandler", 4);
    //@ts-ignore
    TemplateCacheService_OnResolvePublicItemsByOIDsHandler.implementation = function (session, response, request, viewContext) {
        console.log("\n");
        console.log("------- Modified TemplateCacheService [OnResolvePublicItemsByOIDsHandler] -------");
        console.log(AssemblyCSharp().class("uPromise.Deferred`1").method("Resolve", 1));
        console.log("session: " + session);
        console.log("response: " + response);
        // replacing underlying request's oids
        modify_GSFGetPublicItemsByOIDsSvc_req(request.field("body").value, 4, 6, 0, 9617788 - 400, 9617788 - 500);
        var itemlist = viewContext.get(1);
        //replace_GSFPlayerItem_list(itemlist, 9617788 - 400, 9617788 - 500)
        log_GSFGetPublicItemsByOIDsSvc_request_info(request.field("body").value, 1);
        this.method("OnResolvePublicItemsByOIDsHandler").invoke(session, response, request, viewContext);
        console.log(viewContext);
        // wait(10000)
        // console.log(viewContext)
        // // getting playeritem list and count
        // var itemlist = viewContext.get(1)
        // var itemcount = itemlist.method<number>("get_Count").invoke();
        // console.log("itemList of length: " + itemcount)
        // for (let i = 0; i < itemcount; i++) {
        //     // log each GSFPlayerItem
        //     var GSFPlayerItem = itemlist.method<Il2Cpp.Object>("get_Item", 1).invoke(i)
        //     log_GSFPlayerItem_info(GSFPlayerItem, 0)
        // }
    };
}
function modify_GSFPlayerItem_info(GSFPlayerItem, svcClass, objType, server, objNum) {
    modify_GSFOID_info(GSFPlayerItem.field("itemID").value, svcClass, objType, server, objNum);
}
function modify_GSFOID_info(GSFOID, svcClass, objType, server, objNum) {
    GSFOID.method("Set", 4).invoke(svcClass, objType, server, objNum);
}
function modify_GSFOID_ctor() {
    const GSFOID_ctor = AssemblyCSharp().class("GSFOID").method(".ctor", 4);
    //@ts-ignore
    GSFOID_ctor.implementation = function (svcClass, objType, server, objNum) {
        // modify here
        // objType is defined in GSFAwObjectTypes
        this.method(".ctor", 4).invoke(svcClass, objType, server, objNum);
    };
}
function modify_GSFGetPublicItemsByOIDsSvc_req(GSFGetPublicItemsByOIDsSvc, svcClass, objType, server, objNumUpper, objNumLower) {
    const oids = GSFGetPublicItemsByOIDsSvc.field("oids").value;
    replace_GSFOID_list(oids, svcClass, objType, server, objNumUpper, objNumLower);
}
function modify_MessageHeader_ctor() {
    const MessageHeader_ctor = AssemblyCSharp().class("MessageHeader").method(".ctor", 1);
    //@ts-ignore
    MessageHeader_ctor.implementation = function (requestId) {
        this.method(".ctor", 1).invoke(150);
    };
}
function replace_GSFOID_list(GSFOIDList, svcClass, objType, server, objNumUpper, objNumLower) {
    GSFOIDList.method("Clear").invoke();
    for (var i = objNumUpper; i >= objNumLower; i--) {
        GSFOIDList.method("Add", 1).invoke(create_GSFOID(svcClass, objType, server, i));
    }
    return GSFOIDList;
}
function modify_WowGameController_ctor() {
    const WowGameController_ctor = AssemblyCSharp_reg().class("Game.WheelOfWow.WowGameController").method(".ctor");
    //@ts-ignore
    WowGameController_ctor.implementation = function () {
        // replace bonusSlotCount so we get a bonus every time
        //@ts-ignore
        this.field("bonusPlays").value = 24;
        this.method(".ctor").invoke();
        //@ts-ignore
        this.field("bonusPlays").value = 24;
        console.log("bonusPlays: " + this.field("bonusPlays").value);
    };
}
function modify_GSFGetPublicItemsByOIDsSvc_ctor() {
    const GSFGetPublicItemsByOIDsSvc_request = AssemblyCSharp().class("GSFGetPublicItemsByOIDsSvc").nested("GSFRequest");
    //@ts-ignore
    GSFGetPublicItemsByOIDsSvc_request.method(".ctor").implementation = function (oids, langlocalePairID, tierID, birthDate, registrationDate, previewDate, isPreviewEnabled) {
        // clear list, so we never get correct cache calls and can keep calling
        oids.method("Clear").invoke();
        // replacing GSFOIDs with our own if time for next run has passed
        if (Date.now() - GSFGetPublicItemsByOIDsSvc_lastrun > GSFGetPublicItemsByOIDsSvc_runstep && GSFGetPublicItemsByOIDsSvc_lasthandled > 0) {
            replace_GSFOID_list(oids, 4, 6, 0, GSFGetPublicItemsByOIDsSvc_lasthandled, GSFGetPublicItemsByOIDsSvc_lasthandled - GSFGetPublicItemsByOIDsSvc_step);
            console.log("\n");
            console.log("------- Modified GetPublicItemsByOIDs [request, ctor] -------");
            console.log("oids of length: " + oids.method("get_Count").invoke());
            for (let i = 0; i < oids.method("get_Count").invoke(); i++) {
                console.log(oids.method("get_Item", 1).invoke(i));
            }
            console.log("tierID:" + tierID);
            console.log("langlocalePairID:" + langlocalePairID);
            console.log("birthDate:" + birthDate);
            console.log("registrationDate:" + registrationDate);
            console.log("previewDate:" + previewDate);
            console.log("isPreviewEnabled:" + isPreviewEnabled);
            GSFGetPublicItemsByOIDsSvc_lastrun = Date.now();
            GSFGetPublicItemsByOIDsSvc_lasthandled -= GSFGetPublicItemsByOIDsSvc_step;
            write_log("lasthandled.log", GSFGetPublicItemsByOIDsSvc_lasthandled.toString());
        }
        this.method(".ctor").invoke(oids, langlocalePairID, tierID, birthDate, registrationDate, previewDate, isPreviewEnabled);
    };
}
function get_stringify_boolean(object, field) {
    return object.field(field).value.valueOf();
}
function get_stringify_number(object, field, boxed) {
    const output = boxed ? Number(object.field(field).value) : object.field(field).value;
    return output;
}
function get_stringify_string(object, field) {
    return object.field(field).value.toString();
}
function get_stringify_GSFOID(object, field) {
    return stringify_GSFOID(object.field(field).value);
}
function get_stringify_GSFOID_safe(object, field) {
    return present(object, field) ? stringify_GSFOID(object.field(field).value) : undefined;
}
function get_stringify_DateTime(object, field) {
    // CURRENTLY BROKEN [maybe]
    const boxed_nullable = object.field(field).value.box();
    return boxed_nullable.isNull() ? null : boxed_nullable.method("ToString").invoke().toString();
}
function get_stringify_assetMap(object, field) {
    // dump assetmap info to array
    var assetMapString = [];
    // copy contained dictionary to array of dictionary's contained lists
    var assetMap = object.field(field).value;
    var assetMapValues = assetMap.method("get_Values").invoke();
    var assetMapLength = assetMap.method("get_Count").invoke();
    var assetMapArray = Il2Cpp.array(List(), assetMapLength);
    assetMapValues.method("CopyTo").invoke(assetMapArray, 0);
    // parse contained lists and push their GSFAssets
    for (var assetList of assetMapArray) {
        var assetListLength = assetList.method("get_Count").invoke();
        for (let i = 0; i < assetListLength; i++) {
            assetMapString.push(stringify_GSFAsset(assetList.method("get_Item", 1).invoke(i)));
        }
    }
    return assetMapString;
}
function stringify_GSFAvatarShowcase(GSFAvatarShowcase) {
    var GSFAvatarShowcaseString = {
        baby: stringify_GSFPlayerAvatar(GSFAvatarShowcase.field("baby").value),
        primaryParent: stringify_GSFPlayerAvatar(GSFAvatarShowcase.field("primaryParent").value),
        secondaryParent: stringify_GSFPlayerAvatar(GSFAvatarShowcase.field("secondaryParent").value),
    };
    return GSFAvatarShowcaseString;
}
function stringify_GSFPlayerAvatar(GSFPlayerAvatar) {
    // dump GSFPlayerAvatar info to root
    console.log(GSFPlayerAvatar.field("lastPlay").value.box());
    var GSFPlayerAvatarString = {
        oid: get_stringify_GSFOID(GSFPlayerAvatar, "oid"),
        avatarID: get_stringify_GSFOID(GSFPlayerAvatar, "avatarID"),
        playerID: get_stringify_GSFOID(GSFPlayerAvatar, "playerID"),
        buildingID: present(GSFPlayerAvatar, "buildingID") ? get_stringify_GSFOID(GSFPlayerAvatar, "buildingID") : undefined,
        name: get_stringify_string(GSFPlayerAvatar, "name"),
        bio: get_stringify_string(GSFPlayerAvatar, "bio"),
        gender: get_stringify_string(GSFPlayerAvatar, "gender"),
        createTS: present(GSFPlayerAvatar, "createTS") ? get_stringify_DateTime(GSFPlayerAvatar, "createTS") : undefined,
        playerAvatarOutfitId: present(GSFPlayerAvatar, "playerAvatarOutfitId") ? get_stringify_GSFOID(GSFPlayerAvatar, "playerAvatarOutfitId") : undefined,
        outfitNo: get_stringify_number(GSFPlayerAvatar, "outfitNo"),
        x: get_stringify_number(GSFPlayerAvatar, "x"),
        y: get_stringify_number(GSFPlayerAvatar, "y"),
        z: get_stringify_number(GSFPlayerAvatar, "z"),
        rotation: get_stringify_string(GSFPlayerAvatar, "rotation"),
        parentID: present(GSFPlayerAvatar, "parentID") ? get_stringify_GSFOID(GSFPlayerAvatar, "parentID") : undefined,
        parentTemplateID: present(GSFPlayerAvatar, "parentID") ? get_stringify_GSFOID(GSFPlayerAvatar, "parentTemplateID") : undefined,
        parentOrdinal: get_stringify_number(GSFPlayerAvatar, "parentOrdinal"),
        playTime: present(GSFPlayerAvatar, "playTime") ? get_stringify_number(GSFPlayerAvatar, "playTime", true) : undefined,
        lastPlay: present(GSFPlayerAvatar, "lastPlay") ? get_stringify_DateTime(GSFPlayerAvatar, "lastPlay") : undefined,
        birthDay: present(GSFPlayerAvatar, "birthDay") ? get_stringify_DateTime(GSFPlayerAvatar, "birthDay") : undefined,
        breed: get_stringify_number(GSFPlayerAvatar, "breed"),
        state: get_stringify_number(GSFPlayerAvatar, "state"),
        rarity: get_stringify_number(GSFPlayerAvatar, "rarity"),
        babyTasks: get_stringify_number(GSFPlayerAvatar, "babyTasks"),
        growthPoints: get_stringify_number(GSFPlayerAvatar, "growthPoints"),
        bonusAvailable: get_stringify_boolean(GSFPlayerAvatar, "bonusAvailable"),
        kidTasks: get_stringify_number(GSFPlayerAvatar, "kidTasks"),
        accent01ID: present(GSFPlayerAvatar, "accent01ID") ? get_stringify_GSFOID(GSFPlayerAvatar, "accent01ID") : undefined,
        accent02ID: present(GSFPlayerAvatar, "accent02ID") ? get_stringify_GSFOID(GSFPlayerAvatar, "accent02ID") : undefined,
        accent03ID: present(GSFPlayerAvatar, "accent03ID") ? get_stringify_GSFOID(GSFPlayerAvatar, "accent03ID") : undefined,
        accent04ID: present(GSFPlayerAvatar, "accent04ID") ? get_stringify_GSFOID(GSFPlayerAvatar, "accent04ID") : undefined,
        accent05ID: present(GSFPlayerAvatar, "accent05ID") ? get_stringify_GSFOID(GSFPlayerAvatar, "accent05ID") : undefined,
        accent06ID: present(GSFPlayerAvatar, "accent06ID") ? get_stringify_GSFOID(GSFPlayerAvatar, "accent06ID") : undefined,
        accent07ID: present(GSFPlayerAvatar, "accent07ID") ? get_stringify_GSFOID(GSFPlayerAvatar, "accent07ID") : undefined,
        accent08ID: present(GSFPlayerAvatar, "accent08ID") ? get_stringify_GSFOID(GSFPlayerAvatar, "accent08ID") : undefined,
        accent09ID: present(GSFPlayerAvatar, "accent09ID") ? get_stringify_GSFOID(GSFPlayerAvatar, "accent09ID") : undefined,
        accent10ID: present(GSFPlayerAvatar, "accent10ID") ? get_stringify_GSFOID(GSFPlayerAvatar, "accent10ID") : undefined,
        playedByID: present(GSFPlayerAvatar, "playedByID") ? get_stringify_GSFOID(GSFPlayerAvatar, "playedByID") : undefined,
        generation: get_stringify_number(GSFPlayerAvatar, "generation"),
        primaryParentID: present(GSFPlayerAvatar, "primaryParentID") ? get_stringify_GSFOID(GSFPlayerAvatar, "primaryParentID") : undefined,
        secondaryParentID: present(GSFPlayerAvatar, "secondaryParentID") ? get_stringify_GSFOID(GSFPlayerAvatar, "secondaryParentID") : undefined,
        accent01Origin: present(GSFPlayerAvatar, "accent01Origin") ? get_stringify_number(GSFPlayerAvatar, "accent01Origin", true) : undefined,
        accent02Origin: present(GSFPlayerAvatar, "accent02Origin") ? get_stringify_number(GSFPlayerAvatar, "accent02Origin", true) : undefined,
        accent03Origin: present(GSFPlayerAvatar, "accent03Origin") ? get_stringify_number(GSFPlayerAvatar, "accent03Origin", true) : undefined,
        accent04Origin: present(GSFPlayerAvatar, "accent04Origin") ? get_stringify_number(GSFPlayerAvatar, "accent04Origin", true) : undefined,
        accent05Origin: present(GSFPlayerAvatar, "accent05Origin") ? get_stringify_number(GSFPlayerAvatar, "accent05Origin", true) : undefined,
        accent06Origin: present(GSFPlayerAvatar, "accent06Origin") ? get_stringify_number(GSFPlayerAvatar, "accent06Origin", true) : undefined,
        accent07Origin: present(GSFPlayerAvatar, "accent07Origin") ? get_stringify_number(GSFPlayerAvatar, "accent07Origin", true) : undefined,
        accent08Origin: present(GSFPlayerAvatar, "accent08Origin") ? get_stringify_number(GSFPlayerAvatar, "accent08Origin", true) : undefined,
        accent09Origin: present(GSFPlayerAvatar, "accent09Origin") ? get_stringify_number(GSFPlayerAvatar, "accent09Origin", true) : undefined,
        accent10Origin: present(GSFPlayerAvatar, "accent10Origin") ? get_stringify_number(GSFPlayerAvatar, "accent10Origin", true) : undefined,
        accent01Rarity: present(GSFPlayerAvatar, "accent01Rarity") ? get_stringify_number(GSFPlayerAvatar, "accent01Origin", true) : undefined,
        accent02Rarity: present(GSFPlayerAvatar, "accent02Rarity") ? get_stringify_number(GSFPlayerAvatar, "accent02Origin", true) : undefined,
        accent03Rarity: present(GSFPlayerAvatar, "accent03Rarity") ? get_stringify_number(GSFPlayerAvatar, "accent03Origin", true) : undefined,
        accent04Rarity: present(GSFPlayerAvatar, "accent04Rarity") ? get_stringify_number(GSFPlayerAvatar, "accent04Origin", true) : undefined,
        accent05Rarity: present(GSFPlayerAvatar, "accent05Rarity") ? get_stringify_number(GSFPlayerAvatar, "accent05Origin", true) : undefined,
        accent06Rarity: present(GSFPlayerAvatar, "accent06Rarity") ? get_stringify_number(GSFPlayerAvatar, "accent06Origin", true) : undefined,
        accent07Rarity: present(GSFPlayerAvatar, "accent07Rarity") ? get_stringify_number(GSFPlayerAvatar, "accent07Origin", true) : undefined,
        accent08Rarity: present(GSFPlayerAvatar, "accent08Rarity") ? get_stringify_number(GSFPlayerAvatar, "accent08Origin", true) : undefined,
        accent09Rarity: present(GSFPlayerAvatar, "accent09Rarity") ? get_stringify_number(GSFPlayerAvatar, "accent09Origin", true) : undefined,
        accent10Rarity: present(GSFPlayerAvatar, "accent10Rarity") ? get_stringify_number(GSFPlayerAvatar, "accent10Origin", true) : undefined,
        daycareType: get_stringify_number(GSFPlayerAvatar, "daycareType", true),
        daycareEndDate: present(GSFPlayerAvatar, "playerAvatarItemId") ? get_stringify_DateTime(GSFPlayerAvatar, "daycareEndDate") : undefined,
        playerAvatarItemId: present(GSFPlayerAvatar, "playerAvatarItemId") ? get_stringify_GSFOID(GSFPlayerAvatar, "playerAvatarItemId") : undefined,
        avatar: present(GSFPlayerAvatar, "avatar") ? stringify_GSFAvatar(GSFPlayerAvatar.field("avatar").value) : undefined,
        avatarAccents: [],
        primaryParent: present(GSFPlayerAvatar, "primaryParent") ? stringify_GSFPlayerAvatar(GSFPlayerAvatar.field("primaryParent").value) : undefined,
        accentSlotRarities: [],
        plushPurchaseOrder: present(GSFPlayerAvatar, "plushPurchaseOrder") ? stringify_GSFPlayerWalletPurchaseOrder(GSFPlayerAvatar.field("plushPurchaseOrder").value) : undefined,
    };
    // dump avatar accents to array
    if (present(GSFPlayerAvatar, "avatarAccents")) {
        const avatarAccentsList = GSFPlayerAvatar.field("avatarAccents").value;
        const avatarAccentsLength = avatarAccentsList.method("get_Count").invoke();
        for (let i = 0; i < avatarAccentsLength; i++) {
            GSFPlayerAvatarString.avatarAccents.push(stringify_GSFAvatarAccent(avatarAccentsList.method("get_Item", 1).invoke(i)));
        }
    }
    // dump accent slot rarities to array
    if (present(GSFPlayerAvatar, "accentSlotRarities")) {
        const accentSlotRaritiesList = GSFPlayerAvatar.field("accentSlotRarities").value;
        const accentSlotRaritiesLength = accentSlotRaritiesList.method("get_Count").invoke();
        for (let i = 0; i < accentSlotRaritiesLength; i++) {
            GSFPlayerAvatarString.accentSlotRarities.push(stringify_GSFOIDIntPair(accentSlotRaritiesList.method("get_Item", 1).invoke(i)));
        }
    }
    return GSFPlayerAvatarString;
}
function stringify_GSFPlayerWalletPurchaseOrder(GSFPlayerWalletPurchaseOrder) {
    var GSFPlayerWalletPurchaseOrderString = {
        oid: get_stringify_GSFOID(GSFPlayerWalletPurchaseOrder, "oid"),
        walletOwnerId: get_stringify_string(GSFPlayerWalletPurchaseOrder, "walletOwnerId"),
        playerID: get_stringify_GSFOID(GSFPlayerWalletPurchaseOrder, "playerID"),
        appId: get_stringify_string(GSFPlayerWalletPurchaseOrder, "appId"),
        walletName: get_stringify_string(GSFPlayerWalletPurchaseOrder, "walletName"),
        walletTransactionId: get_stringify_string(GSFPlayerWalletPurchaseOrder, "walletTransactionId"),
        itemID: get_stringify_GSFOID(GSFPlayerWalletPurchaseOrder, "itemID"),
        storeItemID: get_stringify_GSFOID(GSFPlayerWalletPurchaseOrder, "storeItemID"),
        walletStatus: get_stringify_string(GSFPlayerWalletPurchaseOrder, "walletStatus"),
        status: get_stringify_string(GSFPlayerWalletPurchaseOrder, "status"),
        amount: get_stringify_number(GSFPlayerWalletPurchaseOrder, "amount"),
        currency: get_stringify_string(GSFPlayerWalletPurchaseOrder, "currency"),
        createDate: get_stringify_DateTime(GSFPlayerWalletPurchaseOrder, "createDate"),
        receipt: get_stringify_string(GSFPlayerWalletPurchaseOrder, "receipt"),
    };
    return GSFPlayerWalletPurchaseOrderString;
}
function stringify_GSFOIDIntPair(GSFOIDIntPair) {
    var GSFOIDIntPairString = {
        a: get_stringify_GSFOID(GSFOIDIntPair, "a"),
        b: get_stringify_number(GSFOIDIntPair, "b"),
    };
    return GSFOIDIntPairString;
}
function stringify_GSFAvatar(GSFAvatar) {
    // dump GSFAvatar info to root
    var GSFAvatarString = {
        name: get_stringify_string(GSFAvatar, "name"),
        description: get_stringify_string(GSFAvatar, "description"),
        dimensions: get_stringify_string(GSFAvatar, "dimensions"),
        weight: get_stringify_number(GSFAvatar, "weight"),
        height: get_stringify_number(GSFAvatar, "height"),
        maxOutfits: get_stringify_number(GSFAvatar, "maxOutfits"),
        param: get_stringify_string(GSFAvatar, "param"),
        breed: get_stringify_number(GSFAvatar, "breed"),
        state: get_stringify_number(GSFAvatar, "state"),
        rarity: get_stringify_number(GSFAvatar, "rarity"),
        babyTasks: get_stringify_number(GSFAvatar, "babyTasks"),
        kidTasks: get_stringify_number(GSFAvatar, "kidTasks"),
        isBreedable: get_stringify_boolean(GSFAvatar, "isBreedable"),
        accent01ID: present(GSFAvatar, "accent01ID") ? get_stringify_GSFOID(GSFAvatar, "accent01ID") : undefined,
        accent02ID: present(GSFAvatar, "accent02ID") ? get_stringify_GSFOID(GSFAvatar, "accent02ID") : undefined,
        accent03ID: present(GSFAvatar, "accent03ID") ? get_stringify_GSFOID(GSFAvatar, "accent03ID") : undefined,
        accent04ID: present(GSFAvatar, "accent04ID") ? get_stringify_GSFOID(GSFAvatar, "accent04ID") : undefined,
        accent05ID: present(GSFAvatar, "accent05ID") ? get_stringify_GSFOID(GSFAvatar, "accent05ID") : undefined,
        accent06ID: present(GSFAvatar, "accent06ID") ? get_stringify_GSFOID(GSFAvatar, "accent06ID") : undefined,
        accent07ID: present(GSFAvatar, "accent07ID") ? get_stringify_GSFOID(GSFAvatar, "accent07ID") : undefined,
        accent08ID: present(GSFAvatar, "accent08ID") ? get_stringify_GSFOID(GSFAvatar, "accent08ID") : undefined,
        accent09ID: present(GSFAvatar, "accent09ID") ? get_stringify_GSFOID(GSFAvatar, "accent09ID") : undefined,
        accent10ID: present(GSFAvatar, "accent10ID") ? get_stringify_GSFOID(GSFAvatar, "accent10ID") : undefined,
        productType: get_stringify_number(GSFAvatar, "productType"),
        assetMap: get_stringify_assetMap(GSFAvatar, "assetMap"),
    };
    return GSFAvatarString;
}
function stringify_GSFAvatarAccent(GSFAvatarAccent) {
    // dump GSFAvatarAccent info to root
    var GSFAvatarAccentString = {
        description: GSFAvatarAccent.field("description").value.toString(),
        oid: stringify_GSFOID(GSFAvatarAccent.field("oid").value),
        accentType: GSFAvatarAccent.field("accentType").value,
        rarityType: GSFAvatarAccent.field("rarityType").value,
        rarity: GSFAvatarAccent.field("rarity").value,
        isTransferable: GSFAvatarAccent.field("isTransferable").value.valueOf(),
        isReflective: GSFAvatarAccent.field("isReflective").value.valueOf(),
        inheritColor: GSFAvatarAccent.field("inheritColor").value.valueOf(),
        param: GSFAvatarAccent.field("param").value.toString(),
        poolType: GSFAvatarAccent.field("poolType").value,
        assetMap: []
    };
    // dump assetmap info to array
    // copy contained dictionary to array of dictionary's contained lists
    var assetMap = GSFAvatarAccent.field("assetMap").value;
    var assetMapValues = assetMap.method("get_Values").invoke();
    var assetMapLength = assetMap.method("get_Count").invoke();
    var assetMapArray = Il2Cpp.array(List(), assetMapLength);
    assetMapValues.method("CopyTo").invoke(assetMapArray, 0);
    // parse contained lists and push their GSFAssets
    for (var assetList of assetMapArray) {
        var assetListLength = assetList.method("get_Count").invoke();
        for (let i = 0; i < assetListLength; i++) {
            GSFAvatarAccentString.assetMap.push(stringify_GSFAsset(assetList.method("get_Item", 1).invoke(i)));
        }
    }
    return GSFAvatarAccentString;
}
function stringify_GSFInventoryPosition(GSFInventoryPosition) {
    var GSFInventoryPositionString = {
        rotation: get_stringify_string(GSFInventoryPosition, "rotation"),
        x: get_stringify_number(GSFInventoryPosition, "x"),
        y: get_stringify_number(GSFInventoryPosition, "y"),
        z: get_stringify_number(GSFInventoryPosition, "z"),
    };
    return GSFInventoryPositionString;
}
function stringify_GSFPlayerItem(GSFPlayerItem) {
    var GSFPlayerItemString = {
        oid: get_stringify_GSFOID(GSFPlayerItem, "oid"),
        itemID: get_stringify_GSFOID(GSFPlayerItem, "itemID"),
        ordinal: get_stringify_number(GSFPlayerItem, "ordinal"),
        parentPioId: get_stringify_GSFOID_safe(GSFPlayerItem, "parentPioId"),
        slotId: get_stringify_GSFOID_safe(GSFPlayerItem, "slotId"),
        playerAvatarOutfitId: get_stringify_GSFOID_safe(GSFPlayerItem, "playerAvatarOutfitId"),
        inventoryPosition: present(GSFPlayerItem, "inventoryPosition") ? stringify_GSFInventoryPosition(GSFPlayerItem.field("inventoryPosition").value) : undefined,
        isYard: get_stringify_boolean(GSFPlayerItem, "isYard"),
        playerMazeId: get_stringify_GSFOID_safe(GSFPlayerItem, "playerMazeId"),
        playerAvatarId: get_stringify_GSFOID_safe(GSFPlayerItem, "playerAvatarId"),
        playerId: get_stringify_GSFOID(GSFPlayerItem, "playerId"),
        isItemUsed: get_stringify_boolean(GSFPlayerItem, "isYard"),
        sellPrice: get_stringify_number(GSFPlayerItem, "sellPrice"),
        createDate: get_stringify_DateTime(GSFPlayerItem, "createDate"),
        growthCompletionDate: get_stringify_DateTime(GSFPlayerItem, "createDate"),
        growthStartDate: get_stringify_DateTime(GSFPlayerItem, "createDate"),
        matureEndDate: get_stringify_DateTime(GSFPlayerItem, "createDate"),
        decayEndDate: get_stringify_DateTime(GSFPlayerItem, "createDate"),
        harvestDate: get_stringify_DateTime(GSFPlayerItem, "createDate"),
        attachedItems: [],
        sendingID: get_stringify_GSFOID_safe(GSFPlayerItem, "sendingID"),
        quantity: get_stringify_number(GSFPlayerItem, "quantity"),
        unitsToExpire: get_stringify_number(GSFPlayerItem, "unitsToExpire"),
        qualityIndex: get_stringify_number(GSFPlayerItem, "qualityIndex"),
        itemState: get_stringify_number(GSFPlayerItem, "itemState"),
        item: stringify_GSFItem(GSFPlayerItem.field("item").value),
        quantityInTransit: get_stringify_number(GSFPlayerItem, "quantityInTransit"),
    };
    // dump attached items to array
    const attachedItems = GSFPlayerItem.field("attachedItems").value;
    if (!attachedItems.isNull()) {
        const attachedItemsLength = attachedItems.method("get_Count").invoke();
        for (var i = 0; i < attachedItemsLength; i++) {
            GSFPlayerItemString.attachedItems.push(stringify_GSFPlayerItem(attachedItems.method("get_Item").invoke(i)));
        }
    }
    return GSFPlayerItemString;
}
function stringify_GSFItem(GSFItem) {
    // dump gsfitem info to root
    var GSFItemString = {
        name: GSFItem.field("name").value.toString(),
        oid: stringify_GSFOID(GSFItem.field("oid").value),
        IsABed: GSFItem.method("get_IsABed").invoke(),
        IsACrib: GSFItem.method("get_IsACrib").invoke(),
        IsAGem: GSFItem.method("get_IsAGem").invoke(),
        IsAStroller: GSFItem.method("get_IsAStroller").invoke(),
        IsClassic: GSFItem.method("get_IsClassic").invoke(),
        IsClassicDiamond: GSFItem.method("get_IsClassicDiamond").invoke(),
        IsClassicDiamondRegular: GSFItem.method("get_IsClassicDiamondRegular").invoke(),
        IsClassicDiamondSmall: GSFItem.method("get_IsClassicDiamondSmall").invoke(),
        IsClassicNoDuplicates: GSFItem.method("get_IsClassicNoDuplicates").invoke(),
        IsClassicRegular: GSFItem.method("get_IsClassicRegular").invoke(),
        IsClassicSmall: GSFItem.method("get_IsClassicSmall").invoke(),
        IsCompetitionFood: GSFItem.method("get_IsCompetitionFood").invoke(),
        IsContainer3D: GSFItem.method("get_IsContainer3D").invoke(),
        IsHarvestable: GSFItem.method("get_IsHarvestable").invoke(),
        IsSlag: GSFItem.method("get_IsSlag").invoke(),
        acceptsPresentable: GSFItem.field("acceptsPresentable").value.valueOf(),
        decayDuration: GSFItem.field("decayDuration").value,
        depth: GSFItem.field("depth").value,
        growthRate: GSFItem.field("growthRate").value,
        height: GSFItem.field("height").value,
        isPresentable: GSFItem.field("isPresentable").value.valueOf(),
        isTradeable: GSFItem.field("isTradeable").value.valueOf(),
        isUserSellable: GSFItem.field("isUserSellable").value.valueOf(),
        matureDuration: GSFItem.field("matureDuration").value,
        qualityIndex: GSFItem.field("qualityIndex").value,
        quantity: GSFItem.field("quantity").value,
        returnToDockNotAllowed: GSFItem.field("returnToDockNotAllowed").value.valueOf(),
        sellPrice: GSFItem.field("sellPrice").value,
        width: GSFItem.field("width").value,
        slotIds: [],
        itemCategories: [],
        assetMap: [],
        assetPackages: [],
    };
    // dump slotids info to subobject
    const slotIds = GSFItem.field("slotIds").value;
    if (!slotIds.isNull()) {
        const slotIdsLength = slotIds.method("get_Count").invoke();
        for (var i = 0; i < slotIdsLength; i++) {
            GSFItemString.slotIds.push(stringify_GSFOID(slotIds.method("get_Item").invoke(i)));
        }
    }
    // dump itemcategory info to array
    const itemCategories = GSFItem.field("itemCategories").value;
    if (!itemCategories.isNull()) {
        const itemCategoriesLength = itemCategories.method("get_Count").invoke();
        for (var i = 0; i < itemCategoriesLength; i++) {
            GSFItemString.itemCategories.push(stringify_GSFItemCategory(itemCategories.method("get_Item").invoke(i)));
        }
    }
    // dump assetmap info to array
    // copy contained dictionary to array of dictionary's contained lists
    var assetMap = GSFItem.field("assetMap").value;
    var assetMapValues = assetMap.method("get_Values").invoke();
    var assetMapLength = assetMap.method("get_Count").invoke();
    var assetMapArray = Il2Cpp.array(List(), assetMapLength);
    assetMapValues.method("CopyTo").invoke(assetMapArray, 0);
    // parse contained lists and push their GSFAssets
    for (var assetList of assetMapArray) {
        var assetListLength = assetList.method("get_Count").invoke();
        for (let i = 0; i < assetListLength; i++) {
            GSFItemString.assetMap.push(stringify_GSFAsset(assetList.method("get_Item", 1).invoke(i)));
        }
    }
    // dump assetPackages
    var assetPackages = GSFItem.field("assetPackages").value;
    var assetPackagesLength = assetPackages.method("get_Count").invoke();
    for (let i = 0; i < assetPackagesLength; i++) {
        GSFItemString.assetPackages.push(stringify_GSFAssetPackage(assetPackages.method("get_Item", 1).invoke(i)));
    }
    return GSFItemString;
}
function stringify_GSFOID(GSFOID, safe) {
    const GSFOIDString = {
        objectClass: GSFOID.field("objectClass").value,
        type: GSFOID.field("type").value,
        server: GSFOID.field("server").value,
        num: GSFOID.field("num").value
    };
    return GSFOIDString;
}
function stringify_GSFAsset(GSFAsset) {
    const GSFAssetString = {
        resName: GSFAsset.field("resName").value.toString(),
        groupName: GSFAsset.field("groupName").value.toString(),
        assetTypeName: GSFAsset.field("assetTypeName").value.toString(),
        cdnId: GSFAsset.field("cdnId").value.toString()
    };
    return GSFAssetString;
}
function stringify_GSFItemCategory(GSFItemCategory) {
    const GSFItemCategoryString = {
        name: GSFItemCategory.field("name").value.toString(),
        isOutdoor: GSFItemCategory.field("isOutdoor").value.valueOf(),
        isWalkover: GSFItemCategory.field("isWalkover").value.valueOf(),
        parentId: GSFItemCategory.field("parentId").value.isNull() ? undefined : stringify_GSFOID(GSFItemCategory.field("parentId").value),
        showInDock: GSFItemCategory.field("showInDock").value.valueOf(),
        ordinal: GSFItemCategory.field("ordinal").value,
        ruleProperty: present(GSFItemCategory, "ruleProperty") ? stringify_GSFRuleProperty(GSFItemCategory.field("ruleProperty").value) : null,
        locked: get_stringify_boolean(GSFItemCategory, "locked"),
        isMultiplayer: get_stringify_boolean(GSFItemCategory, "isMultiplayer"),
        isPlayerHosted: get_stringify_boolean(GSFItemCategory, "isPlayerHosted"),
        isPlayedOffline: get_stringify_boolean(GSFItemCategory, "isPlayedOffline"),
        lockReasons: [],
        assetMap: [],
        assetPackages: [],
    };
    // dump lockReasons
    var lockReasons = GSFItemCategory.field("lockReasons").value;
    if (!lockReasons.isNull()) {
        var lockReasonsLength = lockReasons.method("get_Count").invoke();
        for (let i = 0; i < lockReasonsLength; i++) {
            GSFItemCategoryString.lockReasons.push(lockReasons.method("get_Item", 1).invoke(i).toString());
        }
    }
    // dump assetmap info to array
    // copy contained dictionary to array of dictionary's contained lists
    var assetMap = GSFItemCategory.field("assetMap").value;
    if (!assetMap.isNull()) {
        var assetMapValues = assetMap.method("get_Values").invoke();
        var assetMapLength = assetMap.method("get_Count").invoke();
        var assetMapArray = Il2Cpp.array(List(), assetMapLength);
        assetMapValues.method("CopyTo").invoke(assetMapArray, 0);
        // parse contained lists and push their GSFAssets
        for (var assetList of assetMapArray) {
            var assetListLength = assetList.method("get_Count").invoke();
            for (let i = 0; i < assetListLength; i++) {
                GSFItemCategoryString.assetMap.push(stringify_GSFAsset(assetList.method("get_Item", 1).invoke(i)));
            }
        }
    }
    // dump assetPackages
    var assetPackages = GSFItemCategory.field("assetPackages").value;
    if (!assetPackages.isNull()) {
        var assetPackagesLength = assetPackages.method("get_Count").invoke();
        for (let i = 0; i < assetPackagesLength; i++) {
            GSFItemCategoryString.assetPackages.push(stringify_GSFAssetPackage(assetPackages.method("get_Item", 1).invoke(i)));
        }
    }
    return GSFItemCategoryString;
}
function stringify_GSFAssetPackage(GSFAssetPackage) {
    const GSFAssetPackageString = {
        pTag: get_stringify_string(GSFAssetPackage, "pTag"),
        createDate: get_stringify_DateTime(GSFAssetPackage, "createDate"),
        assetMap: [],
        assetPackages: [],
    };
    // dump assetmap info to array
    // copy contained dictionary to array of dictionary's contained lists
    var assetMap = GSFAssetPackage.field("assetMap").value;
    var assetMapValues = assetMap.method("get_Values").invoke();
    var assetMapLength = assetMap.method("get_Count").invoke();
    var assetMapArray = Il2Cpp.array(List(), assetMapLength);
    assetMapValues.method("CopyTo").invoke(assetMapArray, 0);
    // parse contained lists and push their GSFAssets
    for (var assetList of assetMapArray) {
        var assetListLength = assetList.method("get_Count").invoke();
        for (let i = 0; i < assetListLength; i++) {
            GSFAssetPackageString.assetMap.push(stringify_GSFAsset(assetList.method("get_Item", 1).invoke(i)));
        }
    }
    // dump assetPackages
    var assetPackages = GSFAssetPackage.field("assetPackages").value;
    var assetPackagesLength = assetPackages.method("get_Count").invoke();
    for (let i = 0; i < assetPackagesLength; i++) {
        GSFAssetPackageString.assetPackages.push(stringify_GSFAssetPackage(assetPackages.method("get_Item", 1).invoke(i)));
    }
    return GSFAssetPackageString;
}
function stringify_GSFRuleProperty(GSFRuleProperty) {
    const GSFRulePropertyString = {
        ID: get_stringify_GSFOID(GSFRuleProperty, "ID"),
        parentID: get_stringify_GSFOID(GSFRuleProperty, "parentID"),
        components: [],
        parentComponents: [],
        properties: new Map(),
        childrenGroup: new Map(),
        lookup: new Map(),
    };
    // components import
    var components = GSFRuleProperty.field("components").value;
    var componentsLength = components.method("get_Count").invoke();
    for (let i = 0; i < componentsLength; i++) {
        GSFRulePropertyString.components.push(components.method("get_Item", 1).invoke(i).toString());
    }
    // parentComponents import
    var parentComponents = GSFRuleProperty.field("parentComponents").value;
    var parentComponentsLength = parentComponents.method("get_Count").invoke();
    for (let i = 0; i < parentComponentsLength; i++) {
        GSFRulePropertyString.parentComponents.push(parentComponents.method("get_Item", 1).invoke(i).toString());
    }
    // properties import
    const properties = GSFRuleProperty.field("properties").value;
    const propertiesValues = properties.field("values").value;
    const propertiesKeys = properties.field("keys").value;
    for (var i = 0; i < propertiesKeys.length; i++) {
        GSFRulePropertyString.properties.set(propertiesKeys.get(i).toString(), propertiesValues.get(i).toString());
    }
    // childrenGroup import
    const childrenGroup = GSFRuleProperty.field("childrenGroup").value;
    const childrenGroupValues = childrenGroup.field("values").value;
    const childrenGroupKeys = childrenGroup.field("keys").value;
    for (var i = 0; i < childrenGroupKeys.length; i++) {
        // extract values from valueList
        const GSFRulePropertyList = childrenGroupValues.get(i);
        const GSFRulePropertyListLength = GSFRulePropertyList.method("get_Count").invoke();
        var GSFRulePropertyArray = [];
        for (var i = 0; i < GSFRulePropertyListLength; i++) {
            GSFRulePropertyArray.push(stringify_GSFRuleProperty(GSFRulePropertyList.method("get_Item").invoke(i)));
        }
        GSFRulePropertyString.childrenGroup.set(childrenGroupKeys.get(i).toString(), GSFRulePropertyArray);
    }
    // lookup import
    const lookup = GSFRuleProperty.field("lookup").value;
    const lookupValues = lookup.field("values").value;
    const lookupKeys = lookup.field("keys").value;
    for (var i = 0; i < lookupKeys.length; i++) {
        GSFRulePropertyString.lookup.set(lookupKeys.get(i).toString(), lookupValues.get(i).toString());
    }
    return GSFRulePropertyString;
}
// ------- PACKET FAKING --------
// the actual task.
function replace_GSFPlayerItem_list(GSFPlayerItemList, objNumUpper, objNumLower) {
    GSFPlayerItemList.method("Clear").invoke();
    for (var i = objNumUpper; i > objNumLower; i--) {
        GSFPlayerItemList.method("Add", 1).invoke(create_GSFPlayerItem(create_GSFOID(4, 6, 0, i)));
    }
    return GSFPlayerItemList;
}
function create_GSFOID(svcClass, objType, server, objNum) {
    const GSFOID = AssemblyCSharp().class("GSFOID").alloc();
    GSFOID.method(".ctor", 4).invoke(svcClass, objType, server, objNum);
    return GSFOID;
}
function create_GSFPlayerItem(oid) {
    const GSFPlayerItem = AssemblyCSharp().class("GSFPlayerItem").alloc();
    GSFPlayerItem.method(".ctor").invoke();
    GSFPlayerItem.field("itemID").value = oid;
    return GSFPlayerItem;
}
function append_Il2CppObject_list(main, append) {
    var append_count = append.method("get_Count").invoke();
    for (let i = 0; i < append_count; i++) {
        var append_item = append.method("get_Item", 1).invoke(i);
        main.method("Add", 1).invoke(append_item);
    }
    return main;
}
//    console.log(created_request)
// // serialize request
// // get protocol output
// const GSFIProtocolOutput = AssemblyCSharp.class("GSFIProtocolOutput");
// console.log(GSFIProtocolOutput.methods)
// GSFIProtocolOutput.method(".cctor").implementation = function () {
//     this.method(".cctor").invoke();
// }
// var output = GSFIProtocolOutput.alloc()
// output.method(".ctor").invoke()
// // get protocol enum
// const ProtocolType = AssemblyCSharp.class("ProtocolType");
// const Bit = ProtocolType.field<Il2Cpp.ValueType>("Bit").value;
// // call serializer
// created_request.method("SerializeMembers").invoke(Bit, output);
// }
function create_gsfgetassetsbyoidssvc_request(gsfoids_list) {
    const AssemblyCSharp = Il2Cpp.domain.assembly("Assembly-CSharp-firstpass").image;
    const GSFGetAssetsByOIDsSvcRequest = AssemblyCSharp.class("GSFGetAssetsByOIDsSvc").nested("GSFRequest");
    const new_request = GSFGetAssetsByOIDsSvcRequest.alloc();
    new_request.method(".ctor", 1).invoke(gsfoids_list);
    return new_request;
}
// function create_GSFGetPublicItemsByOIDsSvc_request(
//     oids: Il2Cpp.Object,
//     langlocalePairID: Il2Cpp.Object,
//     tierID: Il2Cpp.Object | null,
//     birthDate: Il2Cpp.Object | null,
//     registrationDate: Il2Cpp.Object | null,
//     previewDate: Il2Cpp.Object | null,
//     isPreviewEnabled: boolean) : Il2Cpp.Object
//     {
//     const GSFGetPublicItemsByOIDsSvc_request = AssemblyCSharp().class("GSFGetPublicItemsByOIDsSvc").nested("GSFRequest").alloc()
//     GSFGetPublicItemsByOIDsSvc_request.method(".ctor", 7).invoke(oids, langlocalePairID, tierID, birthDate, registrationDate, previewDate, isPreviewEnabled)
//     return GSFGetPublicItemsByOIDsSvc_request
// }
function create_GSFGetPublicAssetsByOIDsSvc_request() {
    // THIS FUNCTION IS FUCKED AND DOES NOT WORK
    // needs old gsfrequestmessage logic removing
    // determine gsfoids to query
    const lowerIndex = create_GSFGetPublicAssetsByOIDsSvc_request_lasthandled;
    const higherIndex = (create_GSFGetPublicAssetsByOIDsSvc_request_lasthandled += create_GSFGetPublicAssetsByOIDsSvc_request_step);
    // make list
    const listClass = List().inflate(AssemblyCSharp().class("GSFOID"));
    const gsfoidList = listClass.alloc();
    gsfoidList.method(".ctor").invoke();
    // for (var i = lowerIndex; i < higherIndex; i++) {
    // gsfoidList.method("Add", 1).invoke(create_GSFOID(gsfoidReferenceList[i][0], gsfoidReferenceList[i][1], gsfoidReferenceList[i][2], gsfoidReferenceList[i][3]))
    gsfoidList.method("Add", 1).invoke(create_GSFOID(4, 6, 0, 9618477));
    gsfoidList.method("Add", 1).invoke(create_GSFOID(4, 6, 0, 9618477));
    gsfoidList.method("Add", 1).invoke(create_GSFOID(4, 6, 0, 9618477));
    gsfoidList.method("Add", 1).invoke(create_GSFOID(4, 6, 0, 9618477));
    gsfoidList.method("Add", 1).invoke(create_GSFOID(4, 6, 0, 9618477));
    // }
    const GSFOtherPlayerDetails = AssemblyCSharp().class("GSFSession");
    Il2Cpp.gc.choose(GSFOtherPlayerDetails).forEach((instance) => {
        // generate params for gsfrequestmessage
        var serviceClass = AssemblyCSharp().class("ServiceClass").field("UserServer").value;
        var messageType = 570;
        // generate request
        var GSFRequest = AssemblyCSharp().class("GSFGetPublicAssetsByOIDsSvc").nested("GSFRequest").alloc();
        var oids = gsfoidList;
        var langlocalePairID = create_GSFOID(4, 19, 0, 8452423);
        var tierID = create_GSFOID(4, 38, 0, 9220128);
        const nullableDate = Il2Cpp.domain.assembly("mscorlib").image.class("System.Nullable`1").inflate(Il2Cpp.domain.assembly("mscorlib").image.class("System.DateTime"));
        var birthDate = new Il2Cpp.ValueType(Il2Cpp.alloc(nullableDate.actualInstanceSize), nullableDate.type);
        birthDate.field("hasValue").value = false;
        var registrationDate = new Il2Cpp.ValueType(Il2Cpp.alloc(nullableDate.actualInstanceSize), nullableDate.type);
        registrationDate.field("hasValue").value = false;
        var previewDate = new Il2Cpp.ValueType(Il2Cpp.alloc(nullableDate.actualInstanceSize), nullableDate.type);
        previewDate.field("hasValue").value = false;
        var isPreviewEnabled = false;
        GSFRequest.method(".ctor", 7).invoke(oids, langlocalePairID, tierID, birthDate, registrationDate, previewDate, isPreviewEnabled);
        // generate gsfrequestmessage + send
        var GSFRequestMessage = AssemblyCSharp().class("GSFRequestMessage").alloc();
        GSFRequestMessage.method(".ctor", 3).invoke(serviceClass, messageType, GSFRequest);
        console.log(stringify(str_Il2Cpp_Object(GSFRequestMessage, 1)));
        instance.method("WriteMessage", 1).invoke(GSFRequestMessage);
        // console.log(instance.field<Il2Cpp.Object>("statsType").value.field<Il2Cpp.String>("v").value)
        // console.log(instance.field<Il2Cpp.Object>("level").value)
    });
}
function create_GSFGetShowcaseAvatarSvc_request() {
    const GSFGetShowcaseAvatarSvc_request = AssemblyCSharp().class("GSFGetShowcaseAvatarSvc").nested("GSFRequest");
    const GSFRequest = GSFGetShowcaseAvatarSvc_request.alloc();
    GSFRequest.method(".ctor", 1).invoke(create_GSFOID(4, 11, 2, create_GSFGetShowcaseAvatarSvc_request_lasthandled--));
    create_and_send_GSFRequestMessage(GSFRequest, 621);
}
function create_and_send_GSFRequestMessage(GSFRequest, messageType) {
    // generate GSFRequestMessage
    var serviceClass = AssemblyCSharp().class("ServiceClass").field("UserServer").value;
    var GSFRequestMessage = AssemblyCSharp().class("GSFRequestMessage").alloc();
    GSFRequestMessage.method(".ctor", 3).invoke(serviceClass, messageType, GSFRequest);
    console.log(stringify(str_Il2Cpp_Object(GSFRequestMessage, 1)));
    // send on "all channels" [always so far just one]
    const GSFSessions = AssemblyCSharp().class("GSFSession");
    Il2Cpp.gc.choose(GSFSessions)[0].method("WriteMessage", 1).invoke(GSFRequestMessage);
    console.log("message of type " + messageType + " sent...");
}
// ------ NEW STRINGIFY -------
// fix this.
function stringify(str) {
    return JSON.stringify(str, null, 4);
}
function str_field(Il2Cpp_Object, fieldName, indent) {
    // shorthand to quickly get stringified singletons from an object's field
    const retrievedObject = get_safe(Il2Cpp_Object, fieldName);
    return retrievedObject === null ? null : str_Il2Cpp_Singleton(retrievedObject.value, retrievedObject.type.class, indent);
}
function get_safe(Il2Cpp_Object, fieldName) {
    // safely get Il2Cpp.Object and Il2Cpp.type of valuetype/object field from object/class. works on both dynamic and static fields
    // also convert valuetypes, maybe
    // cast object to class, or just use object if primitive
    const checker = Il2Cpp_Object instanceof Il2Cpp.Class || Il2Cpp_Object.class === undefined ? Il2Cpp_Object : Il2Cpp_Object.class;
    //@ts-ignore
    const get_from = checker.field(fieldName).isStatic && !(Il2Cpp_Object instanceof Il2Cpp.Class) ? Il2Cpp_Object.class : Il2Cpp_Object;
    // switch (get_from.field<Il2Cpp.Object>(fieldName).type.class.fullName.toString()) {
    //     case "System.Nullable`1":
    //     return get_from.field<Il2Cpp.ValueType>(fieldName).value.box();
    // default:
    //     return get_from.field<Il2Cpp.Object>(fieldName).value
    // }
    return { value: get_from.field(fieldName).value, type: get_from.field(fieldName).type };
}
function search(assembly, searchString, exclusions) {
    return Il2Cpp.domain.assembly(assembly).image.classes.filter((klass) => klass.fullName.includes(searchString) && !exclusions.includes(klass.fullName)).map((klass) => klass.fullName);
}
function hook_str(assembly, klasses, subklasses, method, before, returned, after, params, logging_enabled) {
    const indent = logging_enabled ? 1 : undefined;
    for (const klass of klasses) {
        var foundklass = ass(assembly).class(klass);
        var klassName = foundklass.fullName;
        if (subklasses) {
            for (const subklass of subklasses) {
                foundklass = foundklass.nested(subklass);
                klassName += foundklass.fullName;
            }
        }
        for (const foundmethod of foundklass.methods) {
            if (foundmethod.name == method) {
                console.log("replacing " + foundmethod.name + " of " + foundklass.name);
                //@ts-ignore
                foundmethod.implementation = function (...args) {
                    log_num += 1;
                    const printNum = log_num.toString().padStart(6, "0");
                    const printClass = klassName;
                    const printMethod = foundmethod.name;
                    const paramCount = foundmethod.parameterCount;
                    const className = this instanceof Il2Cpp.Class ? this.fullName : this instanceof Il2Cpp.Object ? this.class.fullName : this.type.class.fullName;
                    console.log("\n");
                    console.log("------- " + printClass + " [" + printMethod + "] -------");
                    if (params) {
                        console.log("logging params...");
                        args.forEach((arg, index) => {
                            console.log("arg " + (index + 1) + "/" + args.length + " of type " + ((arg.class == null) ? "<unknown>" : arg.class.fullName));
                            const output = stringify(str_Il2Cpp_Singleton(arg, arg.class, indent));
                            console.log(output);
                            write_log(printNum + " " + className + "/" + printMethod + "_param" + index + ".json", output);
                        });
                    }
                    if (before) {
                        console.log("logging before...");
                        const output = stringify(str_Il2Cpp_Object(this, indent));
                        console.log(output);
                        write_log(printNum + " " + className + "/" + printMethod + "_before.json", output);
                    }
                    const foundreturned = this.method(method, paramCount).invoke(...args);
                    if (returned) {
                        if (foundreturned != null) {
                            console.log("logging returned...");
                            const output = stringify(str_Il2Cpp_Object(foundreturned, indent));
                            console.log(output);
                            write_log(printNum + " " + className + "/" + printMethod + "_returned.json", output);
                        }
                        else {
                            console.log("returned null, skipping returned");
                        }
                    }
                    if (after) {
                        console.log("logging after...");
                        const output = stringify(str_Il2Cpp_Object(this, indent));
                        console.log(output);
                        write_log(printNum + " " + className + "/" + printMethod + "_after.json", output);
                    }
                    console.log("------- " + printClass + " [" + printMethod + "] -------");
                };
            }
        }
        ;
    }
}
function test_str() {
    const GetPublicItemsByOIDs_response_des = AssemblyCSharp().class("GSFGetPublicItemsByOIDsSvc").nested("GSFResponse").method("DeserializeMembers");
    //@ts-ignore
    GetPublicItemsByOIDs_response_des.implementation = function (protocol, input) {
        console.log("\n");
        console.log("------- GetPublicItemsByOIDs [response, des] -------");
        this.method("DeserializeMembers").invoke(protocol, input);
        console.log(JSON.stringify(str_Il2Cpp_Object(this), null, 4));
        console.log("------- GetPublicItemsByOIDs [response, des] -------");
    };
}
function log_indented(message, indent) {
    if (indent) {
        console.log("  ".repeat(indent) + message);
    }
}
// function get_Il2Cpp_Field(Il2Cpp_Object: Il2Cpp.Object, Il2Cpp_Field: Il2Cpp.Field) {
//     // check field type, splitting on generics to find iterables
//     switch (Il2Cpp_Field.type.name.split("<", 1)[0]) {
//         case "System.Boolean":
//             return Il2Cpp_Object.field<boolean>(Il2Cpp_Field.name).value
//         case "System.String":
//             return Il2Cpp_Object.field<Il2Cpp.String>(Il2Cpp_Field.name).value
//         case "System.Int16":
//         case "System.Int32":
//         case "System.Int64":
//             return Il2Cpp_Object.field<number>(Il2Cpp_Field.name).value
//         default:
//             return Il2Cpp_Object.field<Il2Cpp.Object>(Il2Cpp_Field.name).value
//     }
// }
// function get_Il2Cpp_Object(Il2Cpp_Object: Il2Cpp.Object | Il2Cpp.Class, field: Il2Cpp.Field) {
//     // drop field value to object, boxing any valuetypes in the process
//     // if valuetypes were retrieved directly/generically as objects, we would not be able to retrieve their fields or methods
//     const fieldType = field.type.class.name
//     switch (fieldType) {
//         case "System.Nullable":
//             return Il2Cpp_Object.field<Il2Cpp.ValueType>(field.name).value.box();
//         default:
//             return Il2Cpp_Object.field<Il2Cpp.Object>(field.name).value
//     }
// }
function str_Il2Cpp_Singleton(Il2Cpp_Singleton, Il2Cpp_SingletonClass, indent) {
    if (Il2Cpp_SingletonClass == null) {
        return '<errorSingleton: singletonClass of ' + Il2Cpp_Singleton + ' was null>';
    }
    // handle single object. the core trunk of the recursion of this method
    // add cases here for new objects as you find errors and exceptions in the generic stringifying
    // handle primitives first, due to different null function
    if (Il2Cpp_Singleton == null) {
        return null;
    }
    // check field type, splitting on generics to find iterables
    switch (Il2Cpp_SingletonClass.fullName.toString()) {
        case "System.Boolean":
            log_indented("handling as boolean", indent);
            return Il2Cpp_Singleton.valueOf();
        case "System.String":
        case "System.Char":
            log_indented("handling as string", indent);
            return Il2Cpp_Singleton.toString();
        case "System.IntPtr":
        case "System.Bit":
        case "System.Byte":
        case "System.Int16":
        case "System.Int32":
        case "System.Int64":
        case "System.Single":
        case "System.Double":
        case "System.Float":
            log_indented("handling as number", indent);
            return Il2Cpp_Singleton;
        case "System.IO.MemoryStream":
        case "System.IO.BinaryWriter":
        case "System.IO.BinaryReader":
        case "System.IO.Stream":
        case "GSFSession":
        case "SessionManager":
        case "SessionContext":
        case "IPetBehaviour":
        case "GSFEncryptedString":
            // currently unsupported types. break here with null to prevent crashes
            return UNSUPPORTED + Il2Cpp_SingletonClass.fullName.toString();
        default:
    }
    // return null objects as null
    if (Il2Cpp_Singleton.isNull()) {
        return null;
    }
    // handle arrays
    if (Il2Cpp_Singleton.constructor.name == "Array") {
        log_indented("handling as array", indent);
        //@ts-ignore
        return str_Array(Il2Cpp_Singleton, indent ? indent + 1 : undefined);
    }
    // handle enums
    if (Il2Cpp_SingletonClass.isEnum) {
        log_indented("handling as enum", indent);
        return str_Il2Cpp_Singleton(Il2Cpp_Singleton.field("value__").value, Il2Cpp_Singleton.field("value__").value.class, indent ? indent : undefined);
    }
    // handle objects second
    switch (Il2Cpp_SingletonClass.fullName.toString().split("`", 1)[0]) {
        case "GSFOID":
            log_indented("handling as GSFOID", indent);
            return str_GSFOID(Il2Cpp_Singleton);
        case "GSFPlayerMaze":
            log_indented("handling as GSFPlayerMaze", indent);
            return str_GSFPlayerMaze(Il2Cpp_Singleton, indent);
        case "UnityEngine.Vector3":
            log_indented("handling as Vector3", indent);
            return str_UnityEngine_Vector3(Il2Cpp_Singleton, indent);
        case "UnityEngine.Quaternion":
            log_indented("handling as Quaternion", indent);
            return str_UnityEngine_Quaternion(Il2Cpp_Singleton, indent);
        case "System.TimeSpan":
            log_indented("handling as TimeSpan", indent);
            //@ts-ignore
            return str_System_TimeSpan(Il2Cpp_Singleton);
        case "System.DateTime":
            log_indented("handling as DateTime", indent);
            //@ts-ignore
            return str_System_DateTime(Il2Cpp_Singleton);
        case "System.Collections.Generic.List":
            log_indented("handling as list", indent);
            return str_Systems_Collections_Generic_List(Il2Cpp_Singleton, indent);
        case "System.Collections.Generic.Dictionary":
            log_indented("handling as dict", indent);
            return str_Systems_Collections_Generic_Dictionary(Il2Cpp_Singleton, indent);
        case "System.Nullable":
            log_indented("handling as nullable", indent);
            return Il2Cpp_Singleton.method("get_HasValue").invoke() ? str_Il2Cpp_Singleton(Il2Cpp_Singleton.method("get_Value").invoke(), Il2Cpp_SingletonClass.generics[0], indent ? indent + 1 : undefined) : null;
        case "System.Type":
            log_indented("handling as System.Type", indent);
            return Il2Cpp_Singleton.toString();
        case "System.Delegate":
        case "CallbackDelegate":
        case "System.EventHandler":
        case "System.Action":
            return str_System_Delegate(Il2Cpp_Singleton, indent);
        case "ISessionManager":
            return str_ISessionManager(Il2Cpp_Singleton, indent);
        default:
            log_indented("fallback, handling as generic object...", indent);
            return str_Il2Cpp_Object(Il2Cpp_Singleton, indent ? indent + 1 : undefined);
    }
}
function str_Il2Cpp_Object(Il2Cpp_ObjectRaw, indent, template) {
    if (Il2Cpp_ObjectRaw.isNull()) {
        return '<errorObject: object was null>';
    }
    // check type of incoming object and reduce to object or class
    // using new variable for object to shut compiler up
    var Il2Cpp_Object;
    let Il2Cpp_ObjectClasses = [];
    switch (Il2Cpp_ObjectRaw.constructor.name) {
        case "Object":
        default:
            //@ts-ignore
            Il2Cpp_Object = Il2Cpp_ObjectRaw;
            //@ts-ignore
            Il2Cpp_ObjectClasses = [Il2Cpp_Object.class];
            break;
        case "Class":
            //@ts-ignore
            Il2Cpp_Object = Il2Cpp_ObjectRaw;
            //@ts-ignore
            Il2Cpp_ObjectClasses = [Il2Cpp_Object];
            break;
        case "ValueType":
            //@ts-ignore
            Il2Cpp_Object = Il2Cpp_ObjectRaw.box();
            //@ts-ignore
            Il2Cpp_ObjectClasses = [Il2Cpp_Object.class];
            break;
    }
    // push inherited classes to classes
    while (Il2Cpp_ObjectClasses[Il2Cpp_ObjectClasses.length - 1].parent != null) {
        //@ts-ignore
        Il2Cpp_ObjectClasses.push(Il2Cpp_ObjectClasses[Il2Cpp_ObjectClasses.length - 1].parent);
    }
    // iterate fields and stringify
    var Il2Cpp_ObjectString = {};
    if (template) {
        Il2Cpp_ObjectString = template;
    }
    log_indented("iterating object: " + Il2Cpp_Object.toString(), indent);
    Il2Cpp_ObjectClasses.forEach((klass) => {
        klass.fields.forEach((field) => {
            log_indented("field " + field.name + " of type " + field.type + ":", indent);
            // skip backing fields, auto-generated fields that infinitely recurse
            if (template && Object.keys(template).includes(field.name)) {
                log_indented("found in template, skipped", indent);
            }
            else if (field.name.includes("__BackingField")) {
                log_indented("backing field, skipped", indent);
            }
            else if (field.isStatic) {
                log_indented("static, skipped", indent);
            }
            else {
                Il2Cpp_ObjectString[field.name] = str_field(Il2Cpp_Object, field.name, indent ? indent + 1 : indent);
            }
        });
    });
    return Il2Cpp_ObjectString;
}
function str_Array(Il2Cpp_Array, indent) {
    var Il2Cpp_ArrayString = [];
    for (const singleton of Il2Cpp_Array) {
        Il2Cpp_ArrayString.push(str_Il2Cpp_Singleton(singleton, Il2Cpp_Array.elementType.class, indent));
    }
    return Il2Cpp_ArrayString;
}
function str_Systems_Collections_Generic_List(Il2Cpp_List, indent) {
    if (Il2Cpp_List.isNull()) {
        return null;
    }
    var Il2Cpp_ListString = [];
    // iterate list and stringify
    var Il2Cpp_ListLength = Il2Cpp_List.method("get_Count").invoke();
    for (let i = 0; i < Il2Cpp_ListLength; i++) {
        // TODO: we fucked up this line, no longer handles valuetypes
        Il2Cpp_ListString.push(str_Il2Cpp_Singleton(Il2Cpp_List.method("get_Item", 1).invoke(i), Il2Cpp_List.class.generics[0], indent));
    }
    return Il2Cpp_ListString;
}
function str_Systems_Collections_Generic_Dictionary(Il2Cpp_Dictionary, indent) {
    if (Il2Cpp_Dictionary.isNull()) {
        return null;
    }
    // if empty return empty object
    const Il2Cpp_DictionaryLength = Il2Cpp_Dictionary.method("get_Count").invoke();
    if (Il2Cpp_DictionaryLength == 0) {
        return {};
    }
    const Il2Cpp_DictionaryKeys = Il2Cpp.array(Il2Cpp_Dictionary.class.generics[0], Il2Cpp_DictionaryLength);
    const Il2Cpp_DictionaryValues = Il2Cpp.array(Il2Cpp_Dictionary.class.generics[1], Il2Cpp_DictionaryLength);
    Il2Cpp_Dictionary.method("get_Keys").invoke().method("CopyTo").invoke(Il2Cpp_DictionaryKeys, 0);
    Il2Cpp_Dictionary.method("get_Values").invoke().method("CopyTo").invoke(Il2Cpp_DictionaryValues, 0);
    // stringify as object if keys can be safely defined as strings.
    // else stringify as map
    var Il2Cpp_DictionaryParsedKeys = [], Il2Cpp_DictionaryString;
    for (const Il2Cpp_DictionaryKey of Il2Cpp_DictionaryKeys) {
        Il2Cpp_DictionaryParsedKeys.push(str_Il2Cpp_Singleton(Il2Cpp_DictionaryKey, Il2Cpp_Dictionary.class.generics[0], indent));
    }
    if (["String", "number", "boolean"].includes(Il2Cpp_DictionaryParsedKeys[0].constructor.name)) {
        Il2Cpp_DictionaryString = {};
        for (var i = 0; i < Il2Cpp_DictionaryLength; i++) {
            //@ts-ignore
            Il2Cpp_DictionaryString[Il2Cpp_DictionaryParsedKeys[i]] = str_Il2Cpp_Singleton(Il2Cpp_DictionaryValues.get(i), Il2Cpp_Dictionary.class.generics[1], indent);
        }
    }
    else {
        Il2Cpp_DictionaryString = [];
        for (var i = 0; i < Il2Cpp_DictionaryLength; i++) {
            Il2Cpp_DictionaryString.push({
                key: Il2Cpp_DictionaryParsedKeys[i],
                value: str_Il2Cpp_Singleton(Il2Cpp_DictionaryValues.get(i), Il2Cpp_Dictionary.class.generics[1], indent),
            });
        }
    }
    return Il2Cpp_DictionaryString;
}
function str_GSFOID(GSFOID) {
    return {
        objectClass: GSFOID.field("objectClass").value,
        type: GSFOID.field("type").value,
        server: GSFOID.field("server").value,
        num: GSFOID.field("num").value
    };
}
function str_GSFPlayerMaze(GSFPlayerMaze, indent) {
    str_Il2Cpp_Object(GSFPlayerMaze, indent, {
        parent: UNSUPPORTED
    });
}
function str_UnityEngine_Vector3(UnityEngine_Vector3, indent) {
    return {
        x: str_field(UnityEngine_Vector3, "x", indent),
        y: str_field(UnityEngine_Vector3, "y", indent),
        z: str_field(UnityEngine_Vector3, "z", indent)
    };
}
function str_UnityEngine_Quaternion(UnityEngine_Quaternion, indent) {
    return {
        x: str_field(UnityEngine_Quaternion, "x", indent),
        y: str_field(UnityEngine_Quaternion, "y", indent),
        z: str_field(UnityEngine_Quaternion, "z", indent),
        w: str_field(UnityEngine_Quaternion, "w", indent),
    };
}
function str_System_TimeSpan(System_TimeSpan) {
    // https://stackoverflow.com/questions/2906022/timespan-to-iso8601-duration-format-string
    return Il2Cpp.domain.assembly("System.Xml").image.class("System.Xml.XmlConvert").method("ToString", 1).overload("System.TimeSpan").invoke(System_TimeSpan);
}
function str_System_DateTime(System_DateTime) {
    return System_DateTime.method("ToString", 1).invoke(Il2Cpp.string("o"));
}
function str_System_Delegate(System_Delegate, indent) {
    str_Il2Cpp_Object(System_Delegate, indent, {
        m_target: System_Delegate.tryField("m_target")?.value === null ? System_Delegate.field("m_target").value.class.fullName + ", ToString: " + System_Delegate.field("m_target").value.toString() : null
    });
}
function str_ISessionManager(ISessionManager, indent) {
    str_Il2Cpp_Object(ISessionManager, indent, {
        mUserSession: UNSUPPORTED,
        mSyncSession: UNSUPPORTED
    });
}
Il2Cpp.perform(function () {
    // found:
    // gsfbitstream: handles object -> bitstream conversion
    const filtered_class_names = ["gsfbitstream",
        "gsftextutils",
        "gstbitprotocolcodec",
        "kinztime",
        "bitinput",
        "intmodexs",
        "gsfsession",
        "gsfwebsocket",
        "resultcode"
    ];
    // DISABLE PLAYER TIMEOUT
    modify_GSFHeartbeatSvc_request_ctor();
    // Il2Cpp.trace(true)
    // .assemblies(Il2Cpp.domain.assembly("Assembly-CSharp"))
    // .filterClasses(klass => klass.fullName.toString().toLowerCase().includes("interactiveobject") && !filtered_class_names.includes(klass.name.toString().toLowerCase()))
    // .and()
    // .assemblies(Il2Cpp.domain.assembly("Assembly-CSharp"))
    // .filterMethods(klass => klass.name.toString().toLowerCase().includes("interactiveobject") && !filtered_class_names.includes(klass.name.toString().toLowerCase()))
    // .and()
    // .assemblies(Il2Cpp.domain.assembly("Assembly-CSharp"))
    // .filterParameters(klass => klass.type.class.fullName.toString().toLowerCase().includes("interactiveobject") || klass.name.toLowerCase().toString().includes("interactiveobject"))
    // .and()
    // .attach();
    // Il2Cpp.backtrace()
    // .classes(AssemblyCSharp_reg().class("MountPlayer"))
    // .and()
    // .attach();
    // hook_str("Assembly-CSharp", ["ContainerController"], [], "Initialize", true, true, true, true, false)
    // hook_str("Assembly-CSharp-firstpass", ["GSFPlayerItem"], [], "DeserializeMembers", false, false, true, false, false)
    // hook_str("Assembly-CSharp-firstpass", ["GSFItem"], [], ".ctor", false, false, true, false, false)
    // hook_str("Assembly-CSharp", ["PetBaseController"], null, "ConsumeFoodItem", true, true, true, true, false)
    // hook_str("Assembly-CSharp-firstpass", ["DockServices"], null, "FullDecayInventoryItem", true, true, true, true, false)
    // hook_str("Assembly-CSharp-firstpass", ["DockServices"], null, "OnFullDecayInventoryItemHandler", true, true, true, true, false)
    // hook_str("Assembly-CSharp-firstpass", 
    // ["GSFChangePlayerStatNotify"], 
    // ["GSFRequest"], 
    // "DeserializeMembers", false, false, true, false, false);
    // hook_str("Assembly-CSharp-firstpass", 
    // ["GSFAddEventSvc"], 
    // ["GSFRequest"], 
    // ".ctor", false, false, true, false, false);
    // hook_str("Assembly-CSharp-firstpass", 
    // ["GSFAddEventSvc",], 
    // ["GSFResponse"], 
    // "DeserializeMembers", false, false, true, false, false);
    // hook_str("Assembly-CSharp-firstpass", 
    // ["ShopServices"], 
    // [], 
    // "GetStoreItemByStoreItemId", false, true, false, false, false);
    // modify_GetAssetsByOIDs_request_ctor();
    // hook_str("Assembly-CSharp-firstpass", 
    // ["GSFStoreItem"], 
    // [], 
    // "DeserializeMembers", false, false, true, false, false);
    // const GSFOtherPlayerDetails = AssemblyCSharp().class("ShopServices")
    // Il2Cpp.gc.choose(GSFOtherPlayerDetails).forEach((instance: Il2Cpp.Object) => {
    //     console.log(instance)
    //     var newvar = instance.method<Il2Cpp.Object>("GetStoreItemByStoreItemId", 1).invoke(create_GSFOID(4, 73, 0, 9618837))
    //     console.log(newvar.class)
    //     wait(5000)
    //     console.log(newvar.method<number>("get_Count").invoke())
    //     // console.log(instance.field<Il2Cpp.Object>("statsType").value.field<Il2Cpp.String>("v").value)
    //     // console.log(instance.field<Il2Cpp.Object>("level").value)
    // })
    hook_str("Assembly-CSharp-firstpass", ["GSFResponseMessage"], [], "DeserializeMembers", false, true, true, false, false);
    hook_str("Assembly-CSharp-firstpass", ["GSFRequestMessage"], [], ".ctor", false, true, true, false, false);
    // modify_WowGameController_ctor();
    // hook_str("Assembly-CSharp", 
    // ["Game.WheelOfWow.WowGameController"], 
    // [], 
    // ".ctor", false, false, true, false, false);
    // console.log(Il2Cpp.domain.assembly("UnityEngine.CoreModule").image.class("UnityEngine.Material").methods)
    // hook_str("UnityEngine.CoreModule", 
    // ["UnityEngine.ResourcesAPI"], 
    // [], 
    // "FindShaderByName", false, true, false, false, false);
    // hook_str("Assembly-CSharp-firstpass", 
    // search("Assembly-CSharp-firstpass", "GSF", filtered_class_names), 
    // [], 
    // ".ctor", false, false, true, false, false);
    // Il2Cpp.trace(true)
    // // .assemblies(Il2Cpp.domain.assembly("UnityEngine.CoreModule"))
    // // .filterClasses(klass => klass.fullName.toString().includes("GSFChangePlayerStatNotify") || klass.isSubclassOf(AssemblyCSharp().class("GSFChangePlayerStatNotify"), true))
    // // .and()
    // .assemblies(Il2Cpp.domain.assembly("UnityEngine.CoreModule"))
    // .filterClasses(klass => klass.fullName.toString().toLowerCase().includes("shader") && !filtered_class_names.includes(klass.name.toString().toLowerCase()))
    // .and()
    // .assemblies(Il2Cpp.domain.assembly("UnityEngine.CoreModule"))
    // .filterMethods(klass => klass.name.toString().toLowerCase().includes("shader") && !filtered_class_names.includes(klass.name.toString().toLowerCase()))
    // .and()
    // .assemblies(Il2Cpp.domain.assembly("UnityEngine.CoreModule"))
    // .filterParameters(klass => klass.type.class.fullName.toString().toLowerCase().includes("shader") || klass.name.toLowerCase().toString().includes("shader"))
    // .and()
    // .attach();
    // -------- COMPLETED TASKS --------
    // ENABLES CAPTURING OF ITEMS
    // modify_GSFGetPublicItemsByOIDsSvc_ctor();
    // log_GetPublicItemsByOIDs_response_des();
    // ENABLES CAPTURING OF AVATARACCENTS
    // modify_GSFGetPublicAvatarAccentsByOIDsSvc_ctor();
    // log_GSFGetPublicAvatarAccentsByOIDsSvc_response_des(true)
    // ENABLES CAPTURING OF SHOWCASEAVATARS
    // modify_GSFGetShowcaseAvatarsSvc_ctor(8, 250);
    // log_GSFGetShowcaseAvatarsSvc_response_des();
    // LOG LOGGER
    // Il2Cpp.trace(true)
    // .assemblies(Il2Cpp.domain.assembly("UnityEngine.CoreModule"))
    // .filterMethods(klass => klass.name.toLowerCase().includes("log"))
    // .and()
    // .assemblies(Il2Cpp.domain.assembly("Assembly-CSharp-firstpass"))
    // .filterMethods(klass => klass.name.toLowerCase().includes("log"))
    // .and()
    // .attach();
    // ENABLES CAPTURING/CREATION OF SHOWCASEAVATAR
    // hook_str("Assembly-CSharp-firstpass", 
    // ["GSFGetShowcaseAvatarSvc"], 
    // ["GSFResponse"], 
    // "DeserializeMembers", false, false, true, false, false);
    // setInterval(create_GSFGetShowcaseAvatarSvc_request, 7500);
    // hook_str("Assembly-CSharp-firstpass", 
    // ["GSFGetAssetsByOIDsSvc"], 
    // ["GSFResponse"], 
    // ".ctor", false, false, true, false, false);
    // hook_str("Assembly-CSharp-firstpass", 
    // ["GSFSession"], 
    // [], 
    // "WriteMessage", false, false, false, true, false);
    // const GSFOtherPlayerDetails = AssemblyCSharp().class("GSFSession")
    // Il2Cpp.gc.choose(GSFOtherPlayerDetails).forEach((instance: Il2Cpp.Object) => {
    //     var serviceClass = AssemblyCSharp().class("ServiceClass").field<Il2Cpp.ValueType>("UserServer").value
    //     var messageType = 179
    //     console.log("okay")
    //     var GSFRequest = AssemblyCSharp().class("GSFGetAssetsByOIDsSvc").nested("GSFRequest").alloc()
    //     var gsfoidlist = List().inflate(AssemblyCSharp().class("GSFOID")).alloc()
    //     gsfoidlist.method(".ctor").invoke()
    //     gsfoidlist.method("Add", 1).invoke(create_GSFOID(4, 60, 0, 4677291))
    //     gsfoidlist.method("Add", 1).invoke(create_GSFOID(4, 60, 0, 4677291))
    //     gsfoidlist.method("Add", 1).invoke(create_GSFOID(4, 60, 0, 4677291))
    //     GSFRequest.method(".ctor", 1).invoke(gsfoidlist)
    //     var GSFRequestMessage = AssemblyCSharp().class("GSFRequestMessage").alloc()
    //     GSFRequestMessage.method(".ctor", 3).invoke(serviceClass, messageType, GSFRequest)
    //     console.log(stringify(str_Il2Cpp_Object(GSFRequestMessage, 1)))
    //     instance.method("WriteMessage", 1).invoke(GSFRequestMessage)
    //     // console.log(instance.field<Il2Cpp.Object>("statsType").value.field<Il2Cpp.String>("v").value)
    //     // console.log(instance.field<Il2Cpp.Object>("level").value)
    // })
    console.log("reset successful");
});
âœ„
const lookup = []
const revLookup = []

const code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (let i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  const len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  let validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  const placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
export function byteLength (b64) {
  const lens = getLens(b64)
  const validLen = lens[0]
  const placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

export function toByteArray (b64) {
  const lens = getLens(b64)
  const validLen = lens[0]
  const placeHoldersLen = lens[1]

  const arr = new Uint8Array(_byteLength(b64, validLen, placeHoldersLen))

  let curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  const len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  let i
  for (i = 0; i < len; i += 4) {
    const tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    const tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    const tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  const output = []
  for (let i = start; i < end; i += 3) {
    const tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

export function fromByteArray (uint8) {
  const len = uint8.length
  const extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  const parts = []
  const maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (let i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    const tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    const tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

âœ„
/*!
 * The buffer module from node.js, for Frida.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

import * as base64 from 'base64-js'
import * as ieee754 from 'ieee754'

export const config = {
  INSPECT_MAX_BYTES: 50
}

const K_MAX_LENGTH = 0x7fffffff
export { K_MAX_LENGTH as kMaxLength }

Buffer.TYPED_ARRAY_SUPPORT = true

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

export function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (value instanceof ArrayBuffer ||
      (value && value.buffer instanceof ArrayBuffer)) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (value instanceof SharedArrayBuffer ||
      (value && value.buffer instanceof SharedArrayBuffer)) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (arrayView instanceof Uint8Array) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || Number.isNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

export function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (a instanceof Uint8Array) a = Buffer.from(a, a.offset, a.byteLength)
  if (b instanceof Uint8Array) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (buf instanceof Uint8Array) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) {
          buf = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength)
        }
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || string instanceof ArrayBuffer) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a frida-compile context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = config.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
Buffer.prototype[Symbol.for('nodejs.util.inspect.custom')] = Buffer.prototype.inspect

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (target instanceof Uint8Array) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (Number.isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (Number.isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
}

Buffer.prototype.readBigUInt64BE = function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
}

Buffer.prototype.readBigInt64BE = function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
}

Buffer.prototype.writeBigUInt64BE = function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
}

Buffer.prototype.writeBigInt64BE = function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target) {
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

export default {
  config,
  kMaxLength: K_MAX_LENGTH,
  Buffer,
  SlowBuffer
}

âœ„
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

export default EventEmitter;
export { EventEmitter, once };

function ProcessEmitWarning(warning) {
  console.warn(warning);
}

function EventEmitter() {
  EventEmitter.init.call(this);
}

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
let defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || Number.isNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || Number.isNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  const args = [];
  for (let i = 1; i < arguments.length; i++) args.push(arguments[i]);
  let doError = (type === 'error');

  const events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    let er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    const err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  const handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    Reflect.apply(handler, this, args);
  } else {
    const len = handler.length;
    const listeners = arrayClone(handler, len);
    for (let i = 0; i < len; ++i)
      Reflect.apply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  let existing;

  checkListener(listener);

  let events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    const m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      const w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  const state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  const wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      checkListener(listener);

      const events = this._events;
      if (events === undefined)
        return this;

      const list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        let originalListener;
        let position = -1;

        for (let i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      const events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        const keys = Object.keys(events);
        for (let i = 0; i < keys.length; ++i) {
          const key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      const listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (let i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  const events = target._events;

  if (events === undefined)
    return [];

  const evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  const events = this._events;

  if (events !== undefined) {
    const evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

function arrayClone(arr, n) {
  const copy = new Array(n);
  for (let i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  const ret = new Array(arr.length);
  for (let i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

âœ„
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

export function read (buffer, offset, isLE, mLen, nBytes) {
  let e, m
  const eLen = (nBytes * 8) - mLen - 1
  const eMax = (1 << eLen) - 1
  const eBias = eMax >> 1
  let nBits = -7
  let i = isLE ? (nBytes - 1) : 0
  const d = isLE ? -1 : 1
  let s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  while (nBits > 0) {
    e = (e * 256) + buffer[offset + i]
    i += d
    nBits -= 8
  }

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  while (nBits > 0) {
    m = (m * 256) + buffer[offset + i]
    i += d
    nBits -= 8
  }

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

export function write (buffer, value, offset, isLE, mLen, nBytes) {
  let e, m, c
  let eLen = (nBytes * 8) - mLen - 1
  const eMax = (1 << eLen) - 1
  const eBias = eMax >> 1
  const rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  let i = isLE ? 0 : (nBytes - 1)
  const d = isLE ? 1 : -1
  const s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  while (mLen >= 8) {
    buffer[offset + i] = m & 0xff
    i += d
    m /= 256
    mLen -= 8
  }

  e = (e << mLen) | m
  eLen += mLen
  while (eLen > 0) {
    buffer[offset + i] = e & 0xff
    i += d
    e /= 256
    eLen -= 8
  }

  buffer[offset + i - d] |= s * 128
}

âœ„
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

import process from 'process';

const
  CHAR_UPPERCASE_A    = 65,
  CHAR_LOWERCASE_A    = 97,
  CHAR_UPPERCASE_Z    = 90,
  CHAR_LOWERCASE_Z    = 122,
  CHAR_DOT            = 46,
  CHAR_FORWARD_SLASH  = 47,
  CHAR_BACKWARD_SLASH = 92,
  CHAR_COLON          = 58,
  CHAR_QUESTION_MARK  = 63;

const platformIsWin32 = (process.platform === 'win32');

function isPathSeparator(code) {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
}

function isPosixPathSeparator(code) {
  return code === CHAR_FORWARD_SLASH;
}

function isWindowsDeviceRoot(code) {
  return (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||
         (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);
}

// Resolves . and .. elements in a path with directory names
function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
  let res = '';
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = 0;
  for (let i = 0; i <= path.length; ++i) {
    if (i < path.length)
      code = path.charCodeAt(i);
    else if (isPathSeparator(code))
      break;
    else
      code = CHAR_FORWARD_SLASH;

    if (isPathSeparator(code)) {
      if (lastSlash === i - 1 || dots === 1) {
        // NOOP
      } else if (dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 ||
            res.charCodeAt(res.length - 1) !== CHAR_DOT ||
            res.charCodeAt(res.length - 2) !== CHAR_DOT) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = '';
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength =
                res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i;
            dots = 0;
            continue;
          } else if (res.length !== 0) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          res += res.length > 0 ? `${separator}..` : '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += `${separator}${path.slice(lastSlash + 1, i)}`;
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === CHAR_DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

/**
 * @param {string} sep
 * @param {{
 *  dir?: string;
 *  root?: string;
 *  base?: string;
 *  name?: string;
 *  ext?: string;
 *  }} pathObject
 * @returns {string}
 */
function _format(sep, pathObject) {
  const dir = pathObject.dir || pathObject.root;
  const base = pathObject.base ||
    `${pathObject.name || ''}${pathObject.ext || ''}`;
  if (!dir) {
    return base;
  }
  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;
}

const _win32 = {
  /**
   * path.resolve([from ...], to)
   * @param {...string} args
   * @returns {string}
   */
  resolve(...args) {
    let resolvedDevice = '';
    let resolvedTail = '';
    let resolvedAbsolute = false;

    for (let i = args.length - 1; i >= -1; i--) {
      let path;
      if (i >= 0) {
        path = args[i];

        // Skip empty entries
        if (path.length === 0) {
          continue;
        }
      } else if (resolvedDevice.length === 0) {
        path = process.cwd();
      } else {
        // Windows has the concept of drive-specific current working
        // directories. If we've resolved a drive letter but not yet an
        // absolute path, get cwd for that drive, or the process cwd if
        // the drive cwd is not available. We're sure the device is not
        // a UNC path at this points, because UNC paths are always absolute.
        path = process.env[`=${resolvedDevice}`] || process.cwd();

        // Verify that a cwd was found and that it actually points
        // to our drive. If not, default to the drive's root.
        if (path === undefined ||
            (path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&
            path.charCodeAt(2) === CHAR_BACKWARD_SLASH)) {
          path = `${resolvedDevice}\\`;
        }
      }

      const len = path.length;
      let rootEnd = 0;
      let device = '';
      let isAbsolute = false;
      const code = path.charCodeAt(0);

      // Try to match a root
      if (len === 1) {
        if (isPathSeparator(code)) {
          // `path` contains just a path separator
          rootEnd = 1;
          isAbsolute = true;
        }
      } else if (isPathSeparator(code)) {
        // Possible UNC root

        // If we started with a separator, we know we at least have an
        // absolute path of some kind (UNC or otherwise)
        isAbsolute = true;

        if (isPathSeparator(path.charCodeAt(1))) {
          // Matched double path separator at beginning
          let j = 2;
          let last = j;
          // Match 1 or more non-path separators
          while (j < len &&
                 !isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            const firstPart = path.slice(last, j);
            // Matched!
            last = j;
            // Match 1 or more path separators
            while (j < len &&
                   isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j < len && j !== last) {
              // Matched!
              last = j;
              // Match 1 or more non-path separators
              while (j < len &&
                     !isPathSeparator(path.charCodeAt(j))) {
                j++;
              }
              if (j === len || j !== last) {
                // We matched a UNC root
                device =
                  `\\\\${firstPart}\\${path.slice(last, j)}`;
                rootEnd = j;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot(code) &&
                  path.charCodeAt(1) === CHAR_COLON) {
        // Possible device root
        device = path.slice(0, 2);
        rootEnd = 2;
        if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
          // Treat separator following drive name as an absolute path
          // indicator
          isAbsolute = true;
          rootEnd = 3;
        }
      }

      if (device.length > 0) {
        if (resolvedDevice.length > 0) {
          if (device.toLowerCase() !== resolvedDevice.toLowerCase())
            // This path points to another device so it is not applicable
            continue;
        } else {
          resolvedDevice = device;
        }
      }

      if (resolvedAbsolute) {
        if (resolvedDevice.length > 0)
          break;
      } else {
        resolvedTail =
          `${path.slice(rootEnd)}\\${resolvedTail}`;
        resolvedAbsolute = isAbsolute;
        if (isAbsolute && resolvedDevice.length > 0) {
          break;
        }
      }
    }

    // At this point the path should be resolved to a full absolute path,
    // but handle relative paths to be safe (might happen when process.cwd()
    // fails)

    // Normalize the tail path
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\',
                                   isPathSeparator);

    return resolvedAbsolute ?
      `${resolvedDevice}\\${resolvedTail}` :
      `${resolvedDevice}${resolvedTail}` || '.';
  },

  /**
   * @param {string} path
   * @returns {string}
   */
  normalize(path) {
    const len = path.length;
    if (len === 0)
      return '.';
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);

    // Try to match a root
    if (len === 1) {
      // `path` contains just a single char, exit early to avoid
      // unnecessary work
      return isPosixPathSeparator(code) ? '\\' : path;
    }
    if (isPathSeparator(code)) {
      // Possible UNC root

      // If we started with a separator, we know we at least have an absolute
      // path of some kind (UNC or otherwise)
      isAbsolute = true;

      if (isPathSeparator(path.charCodeAt(1))) {
        // Matched double path separator at beginning
        let j = 2;
        let last = j;
        // Match 1 or more non-path separators
        while (j < len &&
               !isPathSeparator(path.charCodeAt(j))) {
          j++;
        }
        if (j < len && j !== last) {
          const firstPart = path.slice(last, j);
          // Matched!
          last = j;
          // Match 1 or more path separators
          while (j < len &&
                 isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            // Matched!
            last = j;
            // Match 1 or more non-path separators
            while (j < len &&
                   !isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j === len) {
              // We matched a UNC root only
              // Return the normalized version of the UNC root since there
              // is nothing left to process
              return `\\\\${firstPart}\\${path.slice(last)}\\`;
            }
            if (j !== last) {
              // We matched a UNC root with leftovers
              device =
                `\\\\${firstPart}\\${path.slice(last, j)}`;
              rootEnd = j;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot(code) &&
               path.charCodeAt(1) === CHAR_COLON) {
      // Possible device root
      device = path.slice(0, 2);
      rootEnd = 2;
      if (len > 2 && isPathSeparator(path.charCodeAt(2))) {
        // Treat separator following drive name as an absolute path
        // indicator
        isAbsolute = true;
        rootEnd = 3;
      }
    }

    let tail = rootEnd < len ?
      normalizeString(path.slice(rootEnd),
                      !isAbsolute, '\\', isPathSeparator) :
      '';
    if (tail.length === 0 && !isAbsolute)
      tail = '.';
    if (tail.length > 0 &&
        isPathSeparator(path.charCodeAt(len - 1)))
      tail += '\\';
    if (device === undefined) {
      return isAbsolute ? `\\${tail}` : tail;
    }
    return isAbsolute ? `${device}\\${tail}` : `${device}${tail}`;
  },

  /**
   * @param {string} path
   * @returns {boolean}
   */
  isAbsolute(path) {
    const len = path.length;
    if (len === 0)
      return false;

    const code = path.charCodeAt(0);
    return isPathSeparator(code) ||
      // Possible device root
      (len > 2 &&
      isWindowsDeviceRoot(code) &&
      path.charCodeAt(1) === CHAR_COLON &&
      isPathSeparator(path.charCodeAt(2)));
  },

  /**
   * @param {...string} args
   * @returns {string}
   */
  join(...args) {
    if (args.length === 0)
      return '.';

    let joined;
    let firstPart;
    for (let i = 0; i < args.length; ++i) {
      const arg = args[i];
      if (arg.length > 0) {
        if (joined === undefined)
          joined = firstPart = arg;
        else
          joined += `\\${arg}`;
      }
    }

    if (joined === undefined)
      return '.';

    // Make sure that the joined path doesn't start with two slashes, because
    // normalize() will mistake it for a UNC path then.
    //
    // This step is skipped when it is very clear that the user actually
    // intended to point at a UNC path. This is assumed when the first
    // non-empty string arguments starts with exactly two slashes followed by
    // at least one more non-slash character.
    //
    // Note that for normalize() to treat a path as a UNC path it needs to
    // have at least 2 components, so we don't filter for that here.
    // This means that the user can use join to construct UNC paths from
    // a server name and a share name; for example:
    //   path.join('//server', 'share') -> '\\\\server\\share\\')
    let needsReplace = true;
    let slashCount = 0;
    if (isPathSeparator(firstPart.charCodeAt(0))) {
      ++slashCount;
      const firstLen = firstPart.length;
      if (firstLen > 1 &&
          isPathSeparator(firstPart.charCodeAt(1))) {
        ++slashCount;
        if (firstLen > 2) {
          if (isPathSeparator(firstPart.charCodeAt(2)))
            ++slashCount;
          else {
            // We matched a UNC path in the first part
            needsReplace = false;
          }
        }
      }
    }
    if (needsReplace) {
      // Find any more consecutive slashes we need to replace
      while (slashCount < joined.length &&
             isPathSeparator(joined.charCodeAt(slashCount))) {
        slashCount++;
      }

      // Replace the slashes if needed
      if (slashCount >= 2)
        joined = `\\${joined.slice(slashCount)}`;
    }

    return _win32.normalize(joined);
  },

  /**
   * It will solve the relative path from `from` to `to`, for instancee
   * from = 'C:\\orandea\\test\\aaa'
   * to = 'C:\\orandea\\impl\\bbb'
   * The output of the function should be: '..\\..\\impl\\bbb'
   * @param {string} from
   * @param {string} to
   * @returns {string}
   */
  relative(from, to) {
    if (from === to)
      return '';

    const fromOrig = _win32.resolve(from);
    const toOrig = _win32.resolve(to);

    if (fromOrig === toOrig)
      return '';

    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();

    if (from === to)
      return '';

    // Trim any leading backslashes
    let fromStart = 0;
    while (fromStart < from.length &&
           from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {
      fromStart++;
    }
    // Trim trailing backslashes (applicable to UNC paths only)
    let fromEnd = from.length;
    while (
      fromEnd - 1 > fromStart &&
      from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH
    ) {
      fromEnd--;
    }
    const fromLen = fromEnd - fromStart;

    // Trim any leading backslashes
    let toStart = 0;
    while (toStart < to.length &&
           to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {
      toStart++;
    }
    // Trim trailing backslashes (applicable to UNC paths only)
    let toEnd = to.length;
    while (toEnd - 1 > toStart &&
           to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {
      toEnd--;
    }
    const toLen = toEnd - toStart;

    // Compare paths to find the longest common path from root
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for (; i < length; i++) {
      const fromCode = from.charCodeAt(fromStart + i);
      if (fromCode !== to.charCodeAt(toStart + i))
        break;
      else if (fromCode === CHAR_BACKWARD_SLASH)
        lastCommonSep = i;
    }

    // We found a mismatch before the first common path separator was seen, so
    // return the original `to`.
    if (i !== length) {
      if (lastCommonSep === -1)
        return toOrig;
    } else {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) ===
            CHAR_BACKWARD_SLASH) {
          // We get here if `from` is the exact base path for `to`.
          // For example: from='C:\\foo\\bar'; to='C:\\foo\\bar\\baz'
          return toOrig.slice(toStart + i + 1);
        }
        if (i === 2) {
          // We get here if `from` is the device root.
          // For example: from='C:\\'; to='C:\\foo'
          return toOrig.slice(toStart + i);
        }
      }
      if (fromLen > length) {
        if (from.charCodeAt(fromStart + i) ===
            CHAR_BACKWARD_SLASH) {
          // We get here if `to` is the exact base path for `from`.
          // For example: from='C:\\foo\\bar'; to='C:\\foo'
          lastCommonSep = i;
        } else if (i === 2) {
          // We get here if `to` is the device root.
          // For example: from='C:\\foo\\bar'; to='C:\\'
          lastCommonSep = 3;
        }
      }
      if (lastCommonSep === -1)
        lastCommonSep = 0;
    }

    let out = '';
    // Generate the relative path based on the path difference between `to` and
    // `from`
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd ||
          from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
        out += out.length === 0 ? '..' : '\\..';
      }
    }

    toStart += lastCommonSep;

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts
    if (out.length > 0)
      return `${out}${toOrig.slice(toStart, toEnd)}`;

    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH)
      ++toStart;
    return toOrig.slice(toStart, toEnd);
  },

  /**
   * @param {string} path
   * @returns {string}
   */
  toNamespacedPath(path) {
    // Note: this will *probably* throw somewhere.
    if (typeof path !== 'string' || path.length === 0)
      return path;

    const resolvedPath = _win32.resolve(path);

    if (resolvedPath.length <= 2)
      return path;

    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
      // Possible UNC root
      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
        const code = resolvedPath.charCodeAt(2);
        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {
          // Matched non-long UNC root, convert the path to a long UNC path
          return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
        }
      }
    } else if (
      isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&
      resolvedPath.charCodeAt(1) === CHAR_COLON &&
      resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH
    ) {
      // Matched device root, convert the path to a long UNC path
      return `\\\\?\\${resolvedPath}`;
    }

    return path;
  },

  /**
   * @param {string} path
   * @returns {string}
   */
  dirname(path) {
    const len = path.length;
    if (len === 0)
      return '.';
    let rootEnd = -1;
    let offset = 0;
    const code = path.charCodeAt(0);

    if (len === 1) {
      // `path` contains just a path separator, exit early to avoid
      // unnecessary work or a dot.
      return isPathSeparator(code) ? path : '.';
    }

    // Try to match a root
    if (isPathSeparator(code)) {
      // Possible UNC root

      rootEnd = offset = 1;

      if (isPathSeparator(path.charCodeAt(1))) {
        // Matched double path separator at beginning
        let j = 2;
        let last = j;
        // Match 1 or more non-path separators
        while (j < len &&
               !isPathSeparator(path.charCodeAt(j))) {
          j++;
        }
        if (j < len && j !== last) {
          // Matched!
          last = j;
          // Match 1 or more path separators
          while (j < len &&
                 isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            // Matched!
            last = j;
            // Match 1 or more non-path separators
            while (j < len &&
                   !isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j === len) {
              // We matched a UNC root only
              return path;
            }
            if (j !== last) {
              // We matched a UNC root with leftovers

              // Offset by 1 to include the separator after the UNC root to
              // treat it as a "normal root" on top of a (UNC) root
              rootEnd = offset = j + 1;
            }
          }
        }
      }
    // Possible device root
    } else if (isWindowsDeviceRoot(code) &&
               path.charCodeAt(1) === CHAR_COLON) {
      rootEnd =
        len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;
      offset = rootEnd;
    }

    let end = -1;
    let matchedSlash = true;
    for (let i = len - 1; i >= offset; --i) {
      if (isPathSeparator(path.charCodeAt(i))) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) {
      if (rootEnd === -1)
        return '.';

      end = rootEnd;
    }
    return path.slice(0, end);
  },

  /**
   * @param {string} path
   * @param {string} [ext]
   * @returns {string}
   */
  basename(path, ext) {
    let start = 0;
    let end = -1;
    let matchedSlash = true;

    // Check for a drive letter prefix so as not to mistake the following
    // path separator as an extra separator at the end of the path that can be
    // disregarded
    if (path.length >= 2 &&
        isWindowsDeviceRoot(path.charCodeAt(0)) &&
        path.charCodeAt(1) === CHAR_COLON) {
      start = 2;
    }

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext === path)
        return '';
      let extIdx = ext.length - 1;
      let firstNonSlashEnd = -1;
      for (let i = path.length - 1; i >= start; --i) {
        const code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path.length;
      return path.slice(start, end);
    }
    for (let i = path.length - 1; i >= start; --i) {
      if (isPathSeparator(path.charCodeAt(i))) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // path component
        matchedSlash = false;
        end = i + 1;
      }
    }

    if (end === -1)
      return '';
    return path.slice(start, end);
  },

  /**
   * @param {string} path
   * @returns {string}
   */
  extname(path) {
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    let preDotState = 0;

    // Check for a drive letter prefix so as not to mistake the following
    // path separator as an extra separator at the end of the path that can be
    // disregarded

    if (path.length >= 2 &&
        path.charCodeAt(1) === CHAR_COLON &&
        isWindowsDeviceRoot(path.charCodeAt(0))) {
      start = startPart = 2;
    }

    for (let i = path.length - 1; i >= start; --i) {
      const code = path.charCodeAt(i);
      if (isPathSeparator(code)) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === CHAR_DOT) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 ||
        end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        (preDotState === 1 &&
         startDot === end - 1 &&
         startDot === startPart + 1)) {
      return '';
    }
    return path.slice(startDot, end);
  },

  format: _format.bind(null, '\\'),

  /**
   * @param {string} path
   * @returns {{
   *  dir: string;
   *  root: string;
   *  base: string;
   *  name: string;
   *  ext: string;
   *  }}
   */
  parse(path) {
    const ret = { root: '', dir: '', base: '', ext: '', name: '' };
    if (path.length === 0)
      return ret;

    const len = path.length;
    let rootEnd = 0;
    let code = path.charCodeAt(0);

    if (len === 1) {
      if (isPathSeparator(code)) {
        // `path` contains just a path separator, exit early to avoid
        // unnecessary work
        ret.root = ret.dir = path;
        return ret;
      }
      ret.base = ret.name = path;
      return ret;
    }
    // Try to match a root
    if (isPathSeparator(code)) {
      // Possible UNC root

      rootEnd = 1;
      if (isPathSeparator(path.charCodeAt(1))) {
        // Matched double path separator at beginning
        let j = 2;
        let last = j;
        // Match 1 or more non-path separators
        while (j < len &&
               !isPathSeparator(path.charCodeAt(j))) {
          j++;
        }
        if (j < len && j !== last) {
          // Matched!
          last = j;
          // Match 1 or more path separators
          while (j < len &&
                 isPathSeparator(path.charCodeAt(j))) {
            j++;
          }
          if (j < len && j !== last) {
            // Matched!
            last = j;
            // Match 1 or more non-path separators
            while (j < len &&
                   !isPathSeparator(path.charCodeAt(j))) {
              j++;
            }
            if (j === len) {
              // We matched a UNC root only
              rootEnd = j;
            } else if (j !== last) {
              // We matched a UNC root with leftovers
              rootEnd = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code) &&
               path.charCodeAt(1) === CHAR_COLON) {
      // Possible device root
      if (len <= 2) {
        // `path` contains just a drive root, exit early to avoid
        // unnecessary work
        ret.root = ret.dir = path;
        return ret;
      }
      rootEnd = 2;
      if (isPathSeparator(path.charCodeAt(2))) {
        if (len === 3) {
          // `path` contains just a drive root, exit early to avoid
          // unnecessary work
          ret.root = ret.dir = path;
          return ret;
        }
        rootEnd = 3;
      }
    }
    if (rootEnd > 0)
      ret.root = path.slice(0, rootEnd);

    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    let preDotState = 0;

    // Get non-dir info
    for (; i >= rootEnd; --i) {
      code = path.charCodeAt(i);
      if (isPathSeparator(code)) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === CHAR_DOT) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (end !== -1) {
      if (startDot === -1 ||
          // We saw a non-dot character immediately before the dot
          preDotState === 0 ||
          // The (right-most) trimmed path component is exactly '..'
          (preDotState === 1 &&
           startDot === end - 1 &&
           startDot === startPart + 1)) {
        ret.base = ret.name = path.slice(startPart, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
      }
    }

    // If the directory is the root, use the entire root as the `dir` including
    // the trailing slash if any (`C:\abc` -> `C:\`). Otherwise, strip out the
    // trailing slash (`C:\abc\def` -> `C:\abc`).
    if (startPart > 0 && startPart !== rootEnd)
      ret.dir = path.slice(0, startPart - 1);
    else
      ret.dir = ret.root;

    return ret;
  },

  sep: '\\',
  delimiter: ';',
  win32: null,
  posix: null
};

const posixCwd = (() => {
  if (platformIsWin32) {
    // Converts Windows' backslash path separators to POSIX forward slashes
    // and truncates any drive indicator
    const regexp = /\\/g;
    return () => {
      const cwd = process.cwd().replace(regexp, '/');
      return cwd.slice(cwd.indexOf('/'));
    };
  }

  // We're already on POSIX, no need for any transformations
  return () => process.cwd();
})();

const _posix = {
  /**
   * path.resolve([from ...], to)
   * @param {...string} args
   * @returns {string}
   */
  resolve(...args) {
    let resolvedPath = '';
    let resolvedAbsolute = false;

    for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      const path = i >= 0 ? args[i] : posixCwd();

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }

      resolvedPath = `${path}/${resolvedPath}`;
      resolvedAbsolute =
        path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/',
                                   isPosixPathSeparator);

    if (resolvedAbsolute) {
      return `/${resolvedPath}`;
    }
    return resolvedPath.length > 0 ? resolvedPath : '.';
  },

  /**
   * @param {string} path
   * @returns {string}
   */
  normalize(path) {
    if (path.length === 0)
      return '.';

    const isAbsolute =
      path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    const trailingSeparator =
      path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;

    // Normalize the path
    path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);

    if (path.length === 0) {
      if (isAbsolute)
        return '/';
      return trailingSeparator ? './' : '.';
    }
    if (trailingSeparator)
      path += '/';

    return isAbsolute ? `/${path}` : path;
  },

  /**
   * @param {string} path
   * @returns {boolean}
   */
  isAbsolute(path) {
    return path.length > 0 &&
           path.charCodeAt(0) === CHAR_FORWARD_SLASH;
  },

  /**
   * @param {...string} args
   * @returns {string}
   */
  join(...args) {
    if (args.length === 0)
      return '.';
    let joined;
    for (let i = 0; i < args.length; ++i) {
      const arg = args[i];
      if (arg.length > 0) {
        if (joined === undefined)
          joined = arg;
        else
          joined += `/${arg}`;
      }
    }
    if (joined === undefined)
      return '.';
    return _posix.normalize(joined);
  },

  /**
   * @param {string} from
   * @param {string} to
   * @returns {string}
   */
  relative(from, to) {
    if (from === to)
      return '';

    // Trim leading forward slashes.
    from = _posix.resolve(from);
    to = _posix.resolve(to);

    if (from === to)
      return '';

    const fromStart = 1;
    const fromEnd = from.length;
    const fromLen = fromEnd - fromStart;
    const toStart = 1;
    const toLen = to.length - toStart;

    // Compare paths to find the longest common path from root
    const length = (fromLen < toLen ? fromLen : toLen);
    let lastCommonSep = -1;
    let i = 0;
    for (; i < length; i++) {
      const fromCode = from.charCodeAt(fromStart + i);
      if (fromCode !== to.charCodeAt(toStart + i))
        break;
      else if (fromCode === CHAR_FORWARD_SLASH)
        lastCommonSep = i;
    }
    if (i === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {
          // We get here if `from` is the exact base path for `to`.
          // For example: from='/foo/bar'; to='/foo/bar/baz'
          return to.slice(toStart + i + 1);
        }
        if (i === 0) {
          // We get here if `from` is the root
          // For example: from='/'; to='/foo'
          return to.slice(toStart + i);
        }
      } else if (fromLen > length) {
        if (from.charCodeAt(fromStart + i) ===
            CHAR_FORWARD_SLASH) {
          // We get here if `to` is the exact base path for `from`.
          // For example: from='/foo/bar/baz'; to='/foo/bar'
          lastCommonSep = i;
        } else if (i === 0) {
          // We get here if `to` is the root.
          // For example: from='/foo/bar'; to='/'
          lastCommonSep = 0;
        }
      }
    }

    let out = '';
    // Generate the relative path based on the path difference between `to`
    // and `from`.
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd ||
          from.charCodeAt(i) === CHAR_FORWARD_SLASH) {
        out += out.length === 0 ? '..' : '/..';
      }
    }

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts.
    return `${out}${to.slice(toStart + lastCommonSep)}`;
  },

  /**
   * @param {string} path
   * @returns {string}
   */
  toNamespacedPath(path) {
    // Non-op on posix systems
    return path;
  },

  /**
   * @param {string} path
   * @returns {string}
   */
  dirname(path) {
    if (path.length === 0)
      return '.';
    const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    let end = -1;
    let matchedSlash = true;
    for (let i = path.length - 1; i >= 1; --i) {
      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1)
      return hasRoot ? '/' : '.';
    if (hasRoot && end === 1)
      return '//';
    return path.slice(0, end);
  },

  /**
   * @param {string} path
   * @param {string} [ext]
   * @returns {string}
   */
  basename(path, ext) {
    let start = 0;
    let end = -1;
    let matchedSlash = true;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext === path)
        return '';
      let extIdx = ext.length - 1;
      let firstNonSlashEnd = -1;
      for (let i = path.length - 1; i >= 0; --i) {
        const code = path.charCodeAt(i);
        if (code === CHAR_FORWARD_SLASH) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path.length;
      return path.slice(start, end);
    }
    for (let i = path.length - 1; i >= 0; --i) {
      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // path component
        matchedSlash = false;
        end = i + 1;
      }
    }

    if (end === -1)
      return '';
    return path.slice(start, end);
  },

  /**
   * @param {string} path
   * @returns {string}
   */
  extname(path) {
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    let preDotState = 0;
    for (let i = path.length - 1; i >= 0; --i) {
      const code = path.charCodeAt(i);
      if (code === CHAR_FORWARD_SLASH) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === CHAR_DOT) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 ||
        end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        (preDotState === 1 &&
         startDot === end - 1 &&
         startDot === startPart + 1)) {
      return '';
    }
    return path.slice(startDot, end);
  },

  format: _format.bind(null, '/'),

  /**
   * @param {string} path
   * @returns {{
   *   dir: string;
   *   root: string;
   *   base: string;
   *   name: string;
   *   ext: string;
   *   }}
   */
  parse(path) {
    const ret = { root: '', dir: '', base: '', ext: '', name: '' };
    if (path.length === 0)
      return ret;
    const isAbsolute =
      path.charCodeAt(0) === CHAR_FORWARD_SLASH;
    let start;
    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    let preDotState = 0;

    // Get non-dir info
    for (; i >= start; --i) {
      const code = path.charCodeAt(i);
      if (code === CHAR_FORWARD_SLASH) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === CHAR_DOT) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (end !== -1) {
      const start = startPart === 0 && isAbsolute ? 1 : startPart;
      if (startDot === -1 ||
          // We saw a non-dot character immediately before the dot
          preDotState === 0 ||
          // The (right-most) trimmed path component is exactly '..'
          (preDotState === 1 &&
          startDot === end - 1 &&
          startDot === startPart + 1)) {
        ret.base = ret.name = path.slice(start, end);
      } else {
        ret.name = path.slice(start, startDot);
        ret.base = path.slice(start, end);
        ret.ext = path.slice(startDot, end);
      }
    }

    if (startPart > 0)
      ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute)
      ret.dir = '/';

    return ret;
  },

  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};

_posix.win32 = _win32.win32 = _win32;
_posix.posix = _win32.posix = _posix;

const impl = platformIsWin32 ? _win32 : _posix;
export default impl;
const {
  resolve,
  normalize,
  isAbsolute,
  join,
  relative,
  toNamespacedPath,
  dirname,
  basename,
  extname,
  format,
  parse,
  sep,
  delimiter,
  win32,
  posix,
} = impl;
export {
  resolve,
  normalize,
  isAbsolute,
  join,
  relative,
  toNamespacedPath,
  dirname,
  basename,
  extname,
  format,
  parse,
  sep,
  delimiter,
  win32,
  posix,
};

âœ„
export function nextTick(callback, ...args) {
  Script.nextTick(callback, ...args);
}

export const title = 'Frida';
export const browser = false;
export const platform = detectPlatform();
export const pid = Process.id;
export const env = {
  FRIDA_COMPILE: '1',
};
export const argv = [];
export const version = Frida.version;
export const versions = {};

function noop() {}

export const on = noop;
export const addListener = noop;
export const once = noop;
export const off = noop;
export const removeListener = noop;
export const removeAllListeners = noop;
export const emit = noop;
export const prependListener = noop;
export const prependOnceListener = noop;

export const listeners = function (name) { return []; }

export function binding(name) {
    throw new Error('process.binding is not supported');
}

export function cwd() {
    return (Process.platform === 'windows') ? 'C:\\' : '/';
}
export function chdir(dir) {
    throw new Error('process.chdir is not supported');
}
export function umask() { return 0; }

export default {
    nextTick,
    title,
    browser,
    platform,
    pid,
    env,
    argv,
    version,
    versions,
    on,
    addListener,
    once,
    off,
    removeListener,
    removeAllListeners,
    emit,
    prependListener,
    prependOnceListener,
    listeners,
    binding,
    cwd,
    chdir,
    umask,
};

function detectPlatform() {
    const platform = Process.platform;
    return (platform === 'windows') ? 'win32' : platform;
}

âœ„
import { format } from 'util';

const messages = new Map();
export const codes = {};

export function aggregateTwoErrors(innerError, outerError) {
  if (innerError && outerError && innerError !== outerError) {
    if (Array.isArray(outerError.errors)) {
      // If `outerError` is already an `AggregateError`.
      outerError.errors.push(innerError);
      return outerError;
    }
    // eslint-disable-next-line no-restricted-syntax
    const err = new AggregateError([
      outerError,
      innerError,
    ], outerError.message);
    err.code = outerError.code;
    return err;
  }
  return innerError || outerError;
}

function makeNodeErrorWithCode(Base, key) {
  return function NodeError(...args) {
    const error = new Base();
    const message = getMessage(key, args, error);
    Object.defineProperties(error, {
      message: {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true,
      },
      toString: {
        value() {
          return `${this.name} [${key}]: ${this.message}`;
        },
        enumerable: false,
        writable: true,
        configurable: true,
      },
    });
    error.code = key;
    return error;
  };
}

function E(sym, val, def, ...otherClasses) {
  messages.set(sym, val);
  def = makeNodeErrorWithCode(def, sym);

  if (otherClasses.length !== 0) {
    otherClasses.forEach((clazz) => {
      def[clazz.name] = makeNodeErrorWithCode(clazz, sym);
    });
  }
  codes[sym] = def;
}

function getMessage(key, args, self) {
  const msg = messages.get(key);

  if (typeof msg === 'function') {
    return Reflect.apply(msg, self, args);
  }

  const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
  if (args.length === 0)
    return msg;

  args.unshift(msg);
  return Reflect.apply(format, null, args);
}

export class AbortError extends Error {
  constructor() {
    super('The operation was aborted');
    this.code = 'ABORT_ERR';
    this.name = 'AbortError';
  }
}

E('ERR_EVENT_RECURSION', 'The event "%s" is already being dispatched', Error);
E('ERR_ILLEGAL_CONSTRUCTOR', 'Illegal constructor', TypeError);
E('ERR_INVALID_ARG_TYPE', 'Invalid argument type', TypeError);
E('ERR_INVALID_ARG_VALUE', 'Invalid argument value', TypeError, RangeError);
E('ERR_INVALID_RETURN_VALUE', 'Invalid return value', TypeError, RangeError);
E('ERR_INVALID_THIS', 'Value of "this" must be of type %s', TypeError);
E('ERR_METHOD_NOT_IMPLEMENTED', 'The %s method is not implemented', Error);
E('ERR_MISSING_ARGS', 'Missing argument', TypeError);
E('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times', Error);
E('ERR_OUT_OF_RANGE', 'Out of range', RangeError);
E('ERR_STREAM_ALREADY_FINISHED',
  'Cannot call %s after a stream was finished',
  Error);
E('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable', Error);
E('ERR_STREAM_DESTROYED', 'Cannot call %s after a stream was destroyed', Error);
E('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
E('ERR_STREAM_PREMATURE_CLOSE', 'Premature close', Error);
E('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF', Error);
E('ERR_STREAM_UNSHIFT_AFTER_END_EVENT',
  'stream.unshift() after end event', Error);
E('ERR_STREAM_WRITE_AFTER_END', 'write after end', Error);
E('ERR_UNKNOWN_ENCODING', 'Unknown encoding: %s', TypeError);

âœ„
// Modeled very closely on the AbortController implementation
// in https://github.com/mysticatea/abort-controller (MIT license)

import { codes as errorCodes } from '../errors.js';
import {
  defineEventHandler,
  EventTarget,
  Event,
  kTrustEvent
} from './event_target.js';

import { inspect } from 'util';

const {
  ERR_ILLEGAL_CONSTRUCTOR,
  ERR_INVALID_THIS,
} = errorCodes;

export const kAborted = Symbol('kAborted');

function customInspect(self, obj, depth, options) {
  if (depth < 0)
    return self;

  const opts = Object.assign({}, options, {
    depth: options.depth === null ? null : options.depth - 1
  });

  return `${self.constructor.name} ${inspect(obj, opts)}`;
}

function validateAbortSignal(obj) {
  if (obj?.[kAborted] === undefined)
    throw new ERR_INVALID_THIS('AbortSignal');
}

export class AbortSignal extends EventTarget {
  constructor() {
    throw new ERR_ILLEGAL_CONSTRUCTOR();
  }

  get aborted() {
    validateAbortSignal(this);
    return !!this[kAborted];
  }

  [inspect.custom](depth, options) {
    return customInspect(this, {
      aborted: this.aborted
    }, depth, options);
  }

  static abort() {
    return createAbortSignal(true);
  }
}

Object.defineProperties(AbortSignal.prototype, {
  aborted: { enumerable: true }
});

Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {
  writable: false,
  enumerable: false,
  configurable: true,
  value: 'AbortSignal',
});

defineEventHandler(AbortSignal.prototype, 'abort');

function createAbortSignal(aborted = false) {
  const signal = new EventTarget();
  Object.setPrototypeOf(signal, AbortSignal.prototype);
  signal[kAborted] = aborted;
  return signal;
}

function abortSignal(signal) {
  if (signal[kAborted]) return;
  signal[kAborted] = true;
  const event = new Event('abort', {
    [kTrustEvent]: true
  });
  signal.dispatchEvent(event);
}

// TODO(joyeecheung): V8 snapshot does not support instance member
// initializers for now:
// https://bugs.chromium.org/p/v8/issues/detail?id=10704
const kSignal = Symbol('signal');

function validateAbortController(obj) {
  if (obj?.[kSignal] === undefined)
    throw new ERR_INVALID_THIS('AbortController');
}

export class AbortController {
  constructor() {
    this[kSignal] = createAbortSignal();
  }

  get signal() {
    validateAbortController(this);
    return this[kSignal];
  }

  abort() {
    validateAbortController(this);
    abortSignal(this[kSignal]);
  }

  [inspect.custom](depth, options) {
    return customInspect(this, {
      signal: this.signal
    }, depth, options);
  }
}

Object.defineProperties(AbortController.prototype, {
  signal: { enumerable: true },
  abort: { enumerable: true }
});

Object.defineProperty(AbortController.prototype, Symbol.toStringTag, {
  writable: false,
  enumerable: false,
  configurable: true,
  value: 'AbortController',
});

âœ„
import eos from './end-of-stream.js';
import {
  AbortError,
  codes as errorCodes,
} from '../errors.js';

const { ERR_INVALID_ARG_TYPE } = errorCodes;

// This method is inlined here for readable-stream
// It also does not allow for signal to not exist on the stream
// https://github.com/nodejs/node/pull/36061#discussion_r533718029
const validateAbortSignal = (signal, name) => {
  if (typeof signal !== 'object' ||
       !('aborted' in signal)) {
    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal);
  }
};

function isNodeStream(obj) {
  return !!(obj && typeof obj.pipe === 'function');
}

export function addAbortSignal(signal, stream) {
  validateAbortSignal(signal, 'signal');
  if (!isNodeStream(stream)) {
    throw new ERR_INVALID_ARG_TYPE('stream', 'stream.Stream', stream);
  }
  return module.exports.addAbortSignalNoValidate(signal, stream);
}

export function addAbortSignalNoValidate(signal, stream) {
  if (typeof signal !== 'object' || !('aborted' in signal)) {
    return stream;
  }
  const onAbort = () => {
    stream.destroy(new AbortError());
  };
  if (signal.aborted) {
    onAbort();
  } else {
    signal.addEventListener('abort', onAbort);
    eos(stream, () => signal.removeEventListener('abort', onAbort));
  }
  return stream;
}

âœ„
import { Buffer } from 'buffer';
import { inspect } from 'util';

export default class BufferList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  push(v) {
    const entry = { data: v, next: null };
    if (this.length > 0)
      this.tail.next = entry;
    else
      this.head = entry;
    this.tail = entry;
    ++this.length;
  }

  unshift(v) {
    const entry = { data: v, next: this.head };
    if (this.length === 0)
      this.tail = entry;
    this.head = entry;
    ++this.length;
  }

  shift() {
    if (this.length === 0)
      return;
    const ret = this.head.data;
    if (this.length === 1)
      this.head = this.tail = null;
    else
      this.head = this.head.next;
    --this.length;
    return ret;
  }

  clear() {
    this.head = this.tail = null;
    this.length = 0;
  }

  join(s) {
    if (this.length === 0)
      return '';
    let p = this.head;
    let ret = '' + p.data;
    while (p = p.next)
      ret += s + p.data;
    return ret;
  }

  concat(n) {
    if (this.length === 0)
      return Buffer.alloc(0);
    const ret = Buffer.allocUnsafe(n >>> 0);
    let p = this.head;
    let i = 0;
    while (p) {
      ret.set(p.data, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  }

  // Consumes a specified amount of bytes or characters from the buffered data.
  consume(n, hasStrings) {
    const data = this.head.data;
    if (n < data.length) {
      // `slice` is the same for buffers and strings.
      const slice = data.slice(0, n);
      this.head.data = data.slice(n);
      return slice;
    }
    if (n === data.length) {
      // First chunk is a perfect match.
      return this.shift();
    }
    // Result spans more than one buffer.
    return hasStrings ? this._getString(n) : this._getBuffer(n);
  }

  first() {
    return this.head.data;
  }

  *[Symbol.iterator]() {
    for (let p = this.head; p; p = p.next) {
      yield p.data;
    }
  }

  // Consumes a specified amount of characters from the buffered data.
  _getString(n) {
    let ret = '';
    let p = this.head;
    let c = 0;
    do {
      const str = p.data;
      if (n > str.length) {
        ret += str;
        n -= str.length;
      } else {
        if (n === str.length) {
          ret += str;
          ++c;
          if (p.next)
            this.head = p.next;
          else
            this.head = this.tail = null;
        } else {
          ret += str.slice(0, n);
          this.head = p;
          p.data = str.slice(n);
        }
        break;
      }
      ++c;
    } while (p = p.next);
    this.length -= c;
    return ret;
  }

  // Consumes a specified amount of bytes from the buffered data.
  _getBuffer(n) {
    const ret = Buffer.allocUnsafe(n);
    const retLen = n;
    let p = this.head;
    let c = 0;
    do {
      const buf = p.data;
      if (n > buf.length) {
        ret.set(buf, retLen - n);
        n -= buf.length;
      } else {
        if (n === buf.length) {
          ret.set(buf, retLen - n);
          ++c;
          if (p.next)
            this.head = p.next;
          else
            this.head = this.tail = null;
        } else {
          ret.set(new Uint8Array(buf.buffer, buf.byteOffset, n),
                  retLen - n);
          this.head = p;
          p.data = buf.slice(n);
        }
        break;
      }
      ++c;
    } while (p = p.next);
    this.length -= c;
    return ret;
  }

  // Make sure the linked list only shows the minimal necessary information.
  [inspect.custom](_, options) {
    return inspect(this, {
      ...options,
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: false
    });
  }
}

âœ„
import { destroyer } from './destroy.js';
import Duplex from './duplex.js';
import {
  AbortError,
  codes as errorCodes,
} from '../errors.js';
import { pipeline } from './pipeline.js';
import {
  isNodeStream,
  isReadable,
  isWritable,
} from './utils.js';

const {
  ERR_INVALID_ARG_VALUE,
  ERR_MISSING_ARGS,
} = errorCodes;

// This is needed for pre node 17.
class ComposeDuplex extends Duplex {
  constructor(options) {
    super(options);

    // https://github.com/nodejs/node/pull/34385

    if (options?.readable === false) {
      this._readableState.readable = false;
      this._readableState.ended = true;
      this._readableState.endEmitted = true;
    }

    if (options?.writable === false) {
      this._writableState.writable = false;
      this._writableState.ending = true;
      this._writableState.ended = true;
      this._writableState.finished = true;
    }
  }
}

export default function compose(...streams) {
  if (streams.length === 0) {
    throw new ERR_MISSING_ARGS('streams');
  }

  if (streams.length === 1) {
    return Duplex.from(streams[0]);
  }

  const orgStreams = [...streams];

  if (typeof streams[0] === 'function') {
    streams[0] = Duplex.from(streams[0]);
  }

  if (typeof streams[streams.length - 1] === 'function') {
    const idx = streams.length - 1;
    streams[idx] = Duplex.from(streams[idx]);
  }

  for (let n = 0; n < streams.length; ++n) {
    if (!isNodeStream(streams[n])) {
      // TODO(ronag): Add checks for non streams.
      continue;
    }
    if (n < streams.length - 1 && !isReadable(streams[n])) {
      throw new ERR_INVALID_ARG_VALUE(
        `streams[${n}]`,
        orgStreams[n],
        'must be readable'
      );
    }
    if (n > 0 && !isWritable(streams[n])) {
      throw new ERR_INVALID_ARG_VALUE(
        `streams[${n}]`,
        orgStreams[n],
        'must be writable'
      );
    }
  }

  let ondrain;
  let onfinish;
  let onreadable;
  let onclose;
  let d;

  function onfinished(err) {
    const cb = onclose;
    onclose = null;

    if (cb) {
      cb(err);
    } else if (err) {
      d.destroy(err);
    } else if (!readable && !writable) {
      d.destroy();
    }
  }

  const head = streams[0];
  const tail = pipeline(streams, onfinished);

  const writable = !!isWritable(head);
  const readable = !!isReadable(tail);

  // TODO(ronag): Avoid double buffering.
  // Implement Writable/Readable/Duplex traits.
  // See, https://github.com/nodejs/node/pull/33515.
  d = new ComposeDuplex({
    // TODO (ronag): highWaterMark?
    writableObjectMode: !!head?.writableObjectMode,
    readableObjectMode: !!tail?.writableObjectMode,
    writable,
    readable,
  });

  if (writable) {
    d._write = function(chunk, encoding, callback) {
      if (head.write(chunk, encoding)) {
        callback();
      } else {
        ondrain = callback;
      }
    };

    d._final = function(callback) {
      head.end();
      onfinish = callback;
    };

    head.on('drain', function() {
      if (ondrain) {
        const cb = ondrain;
        ondrain = null;
        cb();
      }
    });

    tail.on('finish', function() {
      if (onfinish) {
        const cb = onfinish;
        onfinish = null;
        cb();
      }
    });
  }

  if (readable) {
    tail.on('readable', function() {
      if (onreadable) {
        const cb = onreadable;
        onreadable = null;
        cb();
      }
    });

    tail.on('end', function() {
      d.push(null);
    });

    d._read = function() {
      while (true) {
        const buf = tail.read();

        if (buf === null) {
          onreadable = d._read;
          return;
        }

        if (!d.push(buf)) {
          return;
        }
      }
    };
  }

  d._destroy = function(err, callback) {
    if (!err && onclose !== null) {
      err = new AbortError();
    }

    onreadable = null;
    ondrain = null;
    onfinish = null;

    if (onclose === null) {
      callback(err);
    } else {
      onclose = callback;
      destroyer(tail, err);
    }
  };

  return d;
}

âœ„
import {
  aggregateTwoErrors,
  codes as errorCodes,
  AbortError,
} from '../errors.js';
import {
  kDestroyed,
  isDestroyed,
  isFinished,
  isServerRequest
} from './utils.js';

import process from 'process';

const {
  ERR_MULTIPLE_CALLBACK,
} = errorCodes;

const kDestroy = Symbol('kDestroy');
const kConstruct = Symbol('kConstruct');

function checkError(err, w, r) {
  if (err) {
    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364
    err.stack; // eslint-disable-line no-unused-expressions

    if (w && !w.errored) {
      w.errored = err;
    }
    if (r && !r.errored) {
      r.errored = err;
    }
  }
}

// Backwards compat. cb() is undocumented and unused in core but
// unfortunately might be used by modules.
export function destroy(err, cb) {
  const r = this._readableState;
  const w = this._writableState;
  // With duplex streams we use the writable side for state.
  const s = w || r;

  if ((w && w.destroyed) || (r && r.destroyed)) {
    if (typeof cb === 'function') {
      cb();
    }

    return this;
  }


  // We set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks
  checkError(err, w, r);

  if (w) {
    w.destroyed = true;
  }
  if (r) {
    r.destroyed = true;
  }

  // If still constructing then defer calling _destroy.
  if (!s.constructed) {
    this.once(kDestroy, function(er) {
      _destroy(this, aggregateTwoErrors(er, err), cb);
    });
  } else {
    _destroy(this, err, cb);
  }

  return this;
}

function _destroy(self, err, cb) {
  let called = false;

  function onDestroy(err) {
    if (called) {
      return;
    }
    called = true;

    const r = self._readableState;
    const w = self._writableState;

    checkError(err, w, r);

    if (w) {
      w.closed = true;
    }
    if (r) {
      r.closed = true;
    }

    if (typeof cb === 'function') {
      cb(err);
    }

    if (err) {
      process.nextTick(emitErrorCloseNT, self, err);
    } else {
      process.nextTick(emitCloseNT, self);
    }
  }
  try {
    const result = self._destroy(err || null, onDestroy);
    if (result != null) {
      const then = result.then;
      if (typeof then === 'function') {
        then.call(
          result,
          function() {
            process.nextTick(onDestroy, null);
          },
          function(err) {
            process.nextTick(onDestroy, err);
          });
      }
    }
  } catch (err) {
    onDestroy(err);
  }
}

function emitErrorCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  const r = self._readableState;
  const w = self._writableState;

  if (w) {
    w.closeEmitted = true;
  }
  if (r) {
    r.closeEmitted = true;
  }

  if ((w && w.emitClose) || (r && r.emitClose)) {
    self.emit('close');
  }
}

function emitErrorNT(self, err) {
  const r = self._readableState;
  const w = self._writableState;

  if ((w && w.errorEmitted) || (r && r.errorEmitted)) {
    return;
  }

  if (w) {
    w.errorEmitted = true;
  }
  if (r) {
    r.errorEmitted = true;
  }

  self.emit('error', err);
}

export function undestroy() {
  const r = this._readableState;
  const w = this._writableState;

  if (r) {
    r.constructed = true;
    r.closed = false;
    r.closeEmitted = false;
    r.destroyed = false;
    r.errored = null;
    r.errorEmitted = false;
    r.reading = false;
    r.ended = r.readable === false;
    r.endEmitted = r.readable === false;
  }

  if (w) {
    w.constructed = true;
    w.destroyed = false;
    w.closed = false;
    w.closeEmitted = false;
    w.errored = null;
    w.errorEmitted = false;
    w.finalCalled = false;
    w.prefinished = false;
    w.ended = w.writable === false;
    w.ending = w.writable === false;
    w.finished = w.writable === false;
  }
}

export function errorOrDestroy(stream, err, sync) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.

  const r = stream._readableState;
  const w = stream._writableState;

  if ((w && w.destroyed) || (r && r.destroyed)) {
    return this;
  }

  if ((r && r.autoDestroy) || (w && w.autoDestroy))
    stream.destroy(err);
  else if (err) {
    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364
    err.stack; // eslint-disable-line no-unused-expressions

    if (w && !w.errored) {
      w.errored = err;
    }
    if (r && !r.errored) {
      r.errored = err;
    }
    if (sync) {
      process.nextTick(emitErrorNT, stream, err);
    } else {
      emitErrorNT(stream, err);
    }
  }
}

export function construct(stream, cb) {
  if (typeof stream._construct !== 'function') {
    return;
  }

  const r = stream._readableState;
  const w = stream._writableState;

  if (r) {
    r.constructed = false;
  }
  if (w) {
    w.constructed = false;
  }

  stream.once(kConstruct, cb);

  if (stream.listenerCount(kConstruct) > 1) {
    // Duplex
    return;
  }

  process.nextTick(constructNT, stream);
}

function constructNT(stream) {
  let called = false;

  function onConstruct(err) {
    if (called) {
      errorOrDestroy(stream, err ?? new ERR_MULTIPLE_CALLBACK());
      return;
    }
    called = true;

    const r = stream._readableState;
    const w = stream._writableState;
    const s = w || r;

    if (r) {
      r.constructed = true;
    }
    if (w) {
      w.constructed = true;
    }

    if (s.destroyed) {
      stream.emit(kDestroy, err);
    } else if (err) {
      errorOrDestroy(stream, err, true);
    } else {
      process.nextTick(emitConstructNT, stream);
    }
  }

  try {
    const result = stream._construct(onConstruct);
    if (result != null) {
      const then = result.then;
      if (typeof then === 'function') {
        then.call(
          result,
          function() {
            process.nextTick(onConstruct, null);
          },
          function(err) {
            process.nextTick(onConstruct, err);
          });
      }
    }
  } catch (err) {
    onConstruct(err);
  }
}

function emitConstructNT(stream) {
  stream.emit(kConstruct);
}

function isRequest(stream) {
  return stream && stream.setHeader && typeof stream.abort === 'function';
}

function emitCloseLegacy(stream) {
  stream.emit('close');
}

function emitErrorCloseLegacy(stream, err) {
  stream.emit('error', err);
  process.nextTick(emitCloseLegacy, stream);
}

// Normalize destroy for legacy.
export function destroyer(stream, err) {
  if (!stream || isDestroyed(stream)) {
    return;
  }

  if (!err && !isFinished(stream)) {
    err = new AbortError();
  }

  // TODO: Remove isRequest branches.
  if (isServerRequest(stream)) {
    stream.socket = null;
    stream.destroy(err);
  } else if (isRequest(stream)) {
    stream.abort();
  } else if (isRequest(stream.req)) {
    stream.req.abort();
  } else if (typeof stream.destroy === 'function') {
    stream.destroy(err);
  } else if (typeof stream.close === 'function') {
    // TODO: Don't lose err?
    stream.close();
  } else if (err) {
    process.nextTick(emitErrorCloseLegacy, stream);
  } else {
    process.nextTick(emitCloseLegacy, stream);
  }

  if (!stream.destroyed) {
    stream[kDestroyed] = true;
  }
}

âœ„
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototype inheritance, this class
// prototypically inherits from Readable, and then parasitically from
// Writable.

import { AbortController } from './abort_controller.js';
import { destroyer } from './destroy.js';
import eos from './end-of-stream.js';
import {
  AbortError,
  codes as errorCodes,
} from '../errors.js';
import from from './from.js';
import Readable from './readable.js';
import {
  isReadable,
  isWritable,
  isIterable,
  isNodeStream,
  isReadableNodeStream,
  isWritableNodeStream,
  isDuplexNodeStream,
} from './utils.js';
import Writable from './writable.js';

import process from 'process';

const {
  ERR_INVALID_ARG_TYPE,
  ERR_INVALID_RETURN_VALUE,
} = errorCodes;

Object.setPrototypeOf(Duplex.prototype, Readable.prototype);
Object.setPrototypeOf(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  for (const method of Object.keys(Writable.prototype)) {
    if (!Duplex.prototype[method])
      Duplex.prototype[method] = Writable.prototype[method];
  }
}

export default function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options) {
    this.allowHalfOpen = options.allowHalfOpen !== false;

    if (options.readable === false) {
      this._readableState.readable = false;
      this._readableState.ended = true;
      this._readableState.endEmitted = true;
    }

    if (options.writable === false) {
      this._writableState.writable = false;
      this._writableState.ending = true;
      this._writableState.ended = true;
      this._writableState.finished = true;
    }
  } else {
    this.allowHalfOpen = true;
  }
}

Object.defineProperties(Duplex.prototype, {
  writable:
    Object.getOwnPropertyDescriptor(Writable.prototype, 'writable'),
  writableHighWaterMark:
    Object.getOwnPropertyDescriptor(Writable.prototype, 'writableHighWaterMark'),
  writableObjectMode:
    Object.getOwnPropertyDescriptor(Writable.prototype, 'writableObjectMode'),
  writableBuffer:
    Object.getOwnPropertyDescriptor(Writable.prototype, 'writableBuffer'),
  writableLength:
    Object.getOwnPropertyDescriptor(Writable.prototype, 'writableLength'),
  writableFinished:
    Object.getOwnPropertyDescriptor(Writable.prototype, 'writableFinished'),
  writableCorked:
    Object.getOwnPropertyDescriptor(Writable.prototype, 'writableCorked'),
  writableEnded:
    Object.getOwnPropertyDescriptor(Writable.prototype, 'writableEnded'),
  writableNeedDrain:
    Object.getOwnPropertyDescriptor(Writable.prototype, 'writableNeedDrain'),

  destroyed: {
    get() {
      if (this._readableState === undefined ||
        this._writableState === undefined) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set(value) {
      // Backward compatibility, the user is explicitly
      // managing destroyed.
      if (this._readableState && this._writableState) {
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    }
  }
});

Duplex.from = function(body) {
  return duplexify(body, 'body');
};

// This is needed for pre node 17.
class Duplexify extends Duplex {
  constructor(options) {
    super(options);

    // https://github.com/nodejs/node/pull/34385

    if (options?.readable === false) {
      this._readableState.readable = false;
      this._readableState.ended = true;
      this._readableState.endEmitted = true;
    }

    if (options?.writable === false) {
      this._writableState.writable = false;
      this._writableState.ending = true;
      this._writableState.ended = true;
      this._writableState.finished = true;
    }
  }
}

function duplexify(body, name) {
  if (isDuplexNodeStream(body)) {
    return body;
  }

  if (isReadableNodeStream(body)) {
    return _duplexify({ readable: body });
  }

  if (isWritableNodeStream(body)) {
    return _duplexify({ writable: body });
  }

  if (isNodeStream(body)) {
    return _duplexify({ writable: false, readable: false });
  }

  if (typeof body === 'function') {
    const { value, write, final, destroy } = fromAsyncGen(body);

    if (isIterable(value)) {
      return from(Duplexify, value, {
        // TODO (ronag): highWaterMark?
        objectMode: true,
        write,
        final,
        destroy
      });
    }

    const then = value?.then;
    if (typeof then === 'function') {
      let d;

      const promise = then.call(value,
        (val) => {
          if (val != null) {
            throw new ERR_INVALID_RETURN_VALUE('nully', 'body', val);
          }
        },
        (err) => {
          destroyer(d, err);
        }
      );

      return d = new Duplexify({
        // TODO (ronag): highWaterMark?
        objectMode: true,
        readable: false,
        write,
        final(cb) {
          final(async () => {
            try {
              await promise;
              process.nextTick(cb, null);
            } catch (err) {
              process.nextTick(cb, err);
            }
          });
        },
        destroy
      });
    }

    throw new ERR_INVALID_RETURN_VALUE(
      'Iterable, AsyncIterable or AsyncFunction', name, value);
  }

  if (isIterable(body)) {
    return from(Duplexify, body, {
      // TODO (ronag): highWaterMark?
      objectMode: true,
      writable: false
    });
  }

  if (
    typeof body?.writable === 'object' ||
    typeof body?.readable === 'object'
  ) {
    const readable = body?.readable ?
      isReadableNodeStream(body?.readable) ? body?.readable :
        duplexify(body.readable) :
      undefined;

    const writable = body?.writable ?
      isWritableNodeStream(body?.writable) ? body?.writable :
        duplexify(body.writable) :
      undefined;

    return _duplexify({ readable, writable });
  }

  const then = body?.then;
  if (typeof then === 'function') {
    let d;

    then.call(body,
      (val) => {
        if (val != null) {
          d.push(val);
        }
        d.push(null);
      },
      (err) => {
        destroyer(d, err);
      }
    );

    return d = new Duplexify({
      objectMode: true,
      writable: false,
      read() {}
    });
  }

  throw new ERR_INVALID_ARG_TYPE(
    name,
    ['Blob', 'ReadableStream', 'WritableStream', 'Stream', 'Iterable',
     'AsyncIterable', 'Function', '{ readable, writable } pair', 'Promise'],
    body);
};

function fromAsyncGen(fn) {
  let { promise, resolve } = createDeferredPromise();
  const ac = new AbortController();
  const signal = ac.signal;
  const value = fn(async function*() {
    while (true) {
      const { chunk, done, cb } = await promise;
      process.nextTick(cb);
      if (done) return;
      if (signal.aborted) throw new AbortError();
      yield chunk;
      ({ promise, resolve } = createDeferredPromise());
    }
  }(), { signal });

  return {
    value,
    write(chunk, encoding, cb) {
      resolve({ chunk, done: false, cb });
    },
    final(cb) {
      resolve({ done: true, cb });
    },
    destroy(err, cb) {
      ac.abort();
      cb(err);
    }
  };
}

function _duplexify(pair) {
  const r = pair.readable && typeof pair.readable.read !== 'function' ?
    Readable.wrap(pair.readable) : pair.readable;
  const w = pair.writable;

  let readable = !!isReadable(r);
  let writable = !!isWritable(w);

  let ondrain;
  let onfinish;
  let onreadable;
  let onclose;
  let d;

  function onfinished(err) {
    const cb = onclose;
    onclose = null;

    if (cb) {
      cb(err);
    } else if (err) {
      d.destroy(err);
    } else if (!readable && !writable) {
      d.destroy();
    }
  }

  // TODO(ronag): Avoid double buffering.
  // Implement Writable/Readable/Duplex traits.
  // See, https://github.com/nodejs/node/pull/33515.
  d = new Duplexify({
    // TODO (ronag): highWaterMark?
    readableObjectMode: !!r?.readableObjectMode,
    writableObjectMode: !!w?.writableObjectMode,
    readable,
    writable,
  });

  if (writable) {
    eos(w, (err) => {
      writable = false;
      if (err) {
        destroyer(r, err);
      }
      onfinished(err);
    });

    d._write = function(chunk, encoding, callback) {
      if (w.write(chunk, encoding)) {
        callback();
      } else {
        ondrain = callback;
      }
    };

    d._final = function(callback) {
      w.end();
      onfinish = callback;
    };

    w.on('drain', function() {
      if (ondrain) {
        const cb = ondrain;
        ondrain = null;
        cb();
      }
    });

    w.on('finish', function() {
      if (onfinish) {
        const cb = onfinish;
        onfinish = null;
        cb();
      }
    });
  }

  if (readable) {
    eos(r, (err) => {
      readable = false;
      if (err) {
        destroyer(r, err);
      }
      onfinished(err);
    });

    r.on('readable', function() {
      if (onreadable) {
        const cb = onreadable;
        onreadable = null;
        cb();
      }
    });

    r.on('end', function() {
      d.push(null);
    });

    d._read = function() {
      while (true) {
        const buf = r.read();

        if (buf === null) {
          onreadable = d._read;
          return;
        }

        if (!d.push(buf)) {
          return;
        }
      }
    };
  }

  d._destroy = function(err, callback) {
    if (!err && onclose !== null) {
      err = new AbortError();
    }

    onreadable = null;
    ondrain = null;
    onfinish = null;

    if (onclose === null) {
      callback(err);
    } else {
      onclose = callback;
      destroyer(w, err);
      destroyer(r, err);
    }
  };

  return d;
}

function createDeferredPromise() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });

  return { promise, resolve, reject };
}

âœ„
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).

import {
  AbortError,
  codes as errorCodes,
} from '../errors.js';
import once from './once.js';
import {
  isClosed,
  isReadable,
  isReadableNodeStream,
  isReadableFinished,
  isWritable,
  isWritableNodeStream,
  isWritableFinished,
  isNodeStream,
  willEmitClose as _willEmitClose,
} from './utils.js';

import process from 'process';

const {
  ERR_STREAM_PREMATURE_CLOSE
} = errorCodes;

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

const nop = () => {};

export default function eos(stream, options, callback) {
  if (arguments.length === 2) {
    callback = options;
    options = {};
  } else if (options == null) {
    options = {};
  }

  callback = once(callback);

  const readable = options.readable ||
    (options.readable !== false && isReadableNodeStream(stream));
  const writable = options.writable ||
    (options.writable !== false && isWritableNodeStream(stream));

  if (isNodeStream(stream)) {
    // Do nothing...
  } else {
    // TODO: Webstreams.
    // TODO: Throw INVALID_ARG_TYPE.
  }

  const wState = stream._writableState;
  const rState = stream._readableState;

  const onlegacyfinish = () => {
    if (!stream.writable) onfinish();
  };

  // TODO (ronag): Improve soft detection to include core modules and
  // common ecosystem modules that do properly emit 'close' but fail
  // this generic check.
  let willEmitClose = (
    _willEmitClose(stream) &&
    isReadableNodeStream(stream) === readable &&
    isWritableNodeStream(stream) === writable
  );

  let writableFinished = isWritableFinished(stream, false);
  const onfinish = () => {
    writableFinished = true;
    // Stream should not be destroyed here. If it is that
    // means that user space is doing something differently and
    // we cannot trust willEmitClose.
    if (stream.destroyed) willEmitClose = false;

    if (willEmitClose && (!stream.readable || readable)) return;
    if (!readable || readableFinished) callback.call(stream);
  };

  let readableFinished = isReadableFinished(stream, false);
  const onend = () => {
    readableFinished = true;
    // Stream should not be destroyed here. If it is that
    // means that user space is doing something differently and
    // we cannot trust willEmitClose.
    if (stream.destroyed) willEmitClose = false;

    if (willEmitClose && (!stream.writable || writable)) return;
    if (!writable || writableFinished) callback.call(stream);
  };

  const onerror = (err) => {
    callback.call(stream, err);
  };

  let closed = isClosed(stream);

  const onclose = () => {
    closed = true;

    const errored = wState?.errored || rState?.errored;

    if (errored && typeof errored !== 'boolean') {
      return callback.call(stream, errored);
    }

    if (readable && !readableFinished) {
      if (!isReadableFinished(stream, false))
        return callback.call(stream,
                             new ERR_STREAM_PREMATURE_CLOSE());
    }
    if (writable && !writableFinished) {
      if (!isWritableFinished(stream, false))
        return callback.call(stream,
                             new ERR_STREAM_PREMATURE_CLOSE());
    }

    callback.call(stream);
  };

  const onrequest = () => {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    if (!willEmitClose) {
      stream.on('abort', onclose);
    }
    if (stream.req) onrequest();
    else stream.on('request', onrequest);
  } else if (writable && !wState) { // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  // Not all streams will emit 'close' after 'aborted'.
  if (!willEmitClose && typeof stream.aborted === 'boolean') {
    stream.on('aborted', onclose);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (options.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);

  if (closed) {
    process.nextTick(onclose);
  } else if (wState?.errorEmitted || rState?.errorEmitted) {
    if (!willEmitClose) {
      process.nextTick(onclose);
    }
  } else if (
    !readable &&
    (!willEmitClose || isReadable(stream)) &&
    (writableFinished || !isWritable(stream))
  ) {
    process.nextTick(onclose);
  } else if (
    !writable &&
    (!willEmitClose || isWritable(stream)) &&
    (readableFinished || !isReadable(stream))
  ) {
    process.nextTick(onclose);
  } else if ((rState && stream.req && stream.aborted)) {
    process.nextTick(onclose);
  }

  const cleanup = () => {
    callback = nop;
    stream.removeListener('aborted', onclose);
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };

  if (options.signal && !closed) {
    const abort = () => {
      // Keep it because cleanup removes it.
      const endCallback = callback;
      cleanup();
      endCallback.call(stream, new AbortError());
    };
    if (options.signal.aborted) {
      process.nextTick(abort);
    } else {
      const originalCallback = callback;
      callback = once((...args) => {
        options.signal.removeEventListener('abort', abort);
        originalCallback.apply(stream, args);
      });
      options.signal.addEventListener('abort', abort);
    }
  }

  return cleanup;
}

âœ„
import { codes as errorCodes } from '../errors.js';

import EventEmitter from 'events';
import process from 'process';
import { inspect } from 'util';

const {
  ERR_INVALID_ARG_TYPE,
  ERR_EVENT_RECURSION,
  ERR_MISSING_ARGS,
  ERR_INVALID_THIS,
} = errorCodes;

const kIsEventTarget = Symbol.for('nodejs.event_target');
const kIsNodeEventTarget = Symbol('kIsNodeEventTarget');

const {
  kMaxEventTargetListeners,
  kMaxEventTargetListenersWarned,
} = EventEmitter;

export const kEvents = Symbol('kEvents');
const kIsBeingDispatched = Symbol('kIsBeingDispatched');
const kStop = Symbol('kStop');
const kTarget = Symbol('kTarget');
const kHandlers = Symbol('khandlers');
export const kWeakHandler = Symbol('kWeak');

const kHybridDispatch = Symbol.for('nodejs.internal.kHybridDispatch');
export const kCreateEvent = Symbol('kCreateEvent');
export const kNewListener = Symbol('kNewListener');
export const kRemoveListener = Symbol('kRemoveListener');
const kIsNodeStyleListener = Symbol('kIsNodeStyleListener');
export const kTrustEvent = Symbol('kTrustEvent');

// TODO(joyeecheung): V8 snapshot does not support instance member
// initializers for now:
// https://bugs.chromium.org/p/v8/issues/detail?id=10704
const kType = Symbol('type');
const kDefaultPrevented = Symbol('defaultPrevented');
const kCancelable = Symbol('cancelable');
const kTimestamp = Symbol('timestamp');
const kBubbles = Symbol('bubbles');
const kComposed = Symbol('composed');
const kPropagationStopped = Symbol('propagationStopped');

const isTrustedSet = new WeakSet();
const isTrusted = Object.getOwnPropertyDescriptor({
  get isTrusted() {
    return isTrustedSet.has(this);
  }
}, 'isTrusted').get;

function isEvent(value) {
  return typeof value?.[kType] === 'string';
}

export class Event {
  constructor(type, options = null) {
    if (arguments.length === 0)
      throw new ERR_MISSING_ARGS('type');
    const { cancelable, bubbles, composed } = { ...options };
    this[kCancelable] = !!cancelable;
    this[kBubbles] = !!bubbles;
    this[kComposed] = !!composed;
    this[kType] = `${type}`;
    this[kDefaultPrevented] = false;
    this[kTimestamp] = Date.now();
    this[kPropagationStopped] = false;
    if (options?.[kTrustEvent]) {
      isTrustedSet.add(this);
    }

    // isTrusted is special (LegacyUnforgeable)
    Object.defineProperty(this, 'isTrusted', {
      get: isTrusted,
      enumerable: true,
      configurable: false
    });
    this[kTarget] = null;
    this[kIsBeingDispatched] = false;
  }

  [inspect.custom](depth, options) {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    const name = this.constructor.name;
    if (depth < 0)
      return name;

    const opts = Object.assign({}, options, {
      depth: Number.isInteger(options.depth) ? options.depth - 1 : options.depth
    });

    return `${name} ${inspect({
      type: this[kType],
      defaultPrevented: this[kDefaultPrevented],
      cancelable: this[kCancelable],
      timeStamp: this[kTimestamp],
    }, opts)}`;
  }

  stopImmediatePropagation() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    this[kStop] = true;
  }

  preventDefault() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    this[kDefaultPrevented] = true;
  }

  get target() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return this[kTarget];
  }

  get currentTarget() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return this[kTarget];
  }

  get srcElement() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return this[kTarget];
  }

  get type() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return this[kType];
  }

  get cancelable() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return this[kCancelable];
  }

  get defaultPrevented() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return this[kCancelable] && this[kDefaultPrevented];
  }

  get timeStamp() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return this[kTimestamp];
  }


  // The following are non-op and unused properties/methods from Web API Event.
  // These are not supported in Node.js and are provided purely for
  // API completeness.

  composedPath() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return this[kIsBeingDispatched] ? [this[kTarget]] : [];
  }

  get returnValue() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return !this.defaultPrevented;
  }

  get bubbles() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return this[kBubbles];
  }

  get composed() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return this[kComposed];
  }

  get eventPhase() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return this[kIsBeingDispatched] ? Event.AT_TARGET : Event.NONE;
  }

  get cancelBubble() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    return this[kPropagationStopped];
  }

  set cancelBubble(value) {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    if (value) {
      this.stopPropagation();
    }
  }

  stopPropagation() {
    if (!isEvent(this))
      throw new ERR_INVALID_THIS('Event');
    this[kPropagationStopped] = true;
  }

  static NONE = 0;
  static CAPTURING_PHASE = 1;
  static AT_TARGET = 2;
  static BUBBLING_PHASE = 3;
}

const kEnumerableProperty = Object.create(null);
kEnumerableProperty.enumerable = true;

Object.defineProperties(
  Event.prototype, {
    [Symbol.toStringTag]: {
      writable: false,
      enumerable: false,
      configurable: true,
      value: 'Event',
    },
    stopImmediatePropagation: kEnumerableProperty,
    preventDefault: kEnumerableProperty,
    target: kEnumerableProperty,
    currentTarget: kEnumerableProperty,
    srcElement: kEnumerableProperty,
    type: kEnumerableProperty,
    cancelable: kEnumerableProperty,
    defaultPrevented: kEnumerableProperty,
    timeStamp: kEnumerableProperty,
    composedPath: kEnumerableProperty,
    returnValue: kEnumerableProperty,
    bubbles: kEnumerableProperty,
    composed: kEnumerableProperty,
    eventPhase: kEnumerableProperty,
    cancelBubble: kEnumerableProperty,
    stopPropagation: kEnumerableProperty,
  });

class NodeCustomEvent extends Event {
  constructor(type, options) {
    super(type, options);
    if (options?.detail) {
      this.detail = options.detail;
    }
  }
}

// Weak listener cleanup
// This has to be lazy for snapshots to work
let weakListenersState = null;
// The resource needs to retain the callback so that it doesn't
// get garbage collected now that it's weak.
let objectToWeakListenerMap = null;
function weakListeners() {
  if (weakListenersState === null) {
    weakListenersState = new FinalizationRegistry(
      (listener) => listener.remove()
    );
  }
  if (objectToWeakListenerMap === null) {
    objectToWeakListenerMap = new WeakMap();
  }
  return { registry: weakListenersState, map: objectToWeakListenerMap };
}

// The listeners for an EventTarget are maintained as a linked list.
// Unfortunately, the way EventTarget is defined, listeners are accounted
// using the tuple [handler,capture], and even if we don't actually make
// use of capture or bubbling, in order to be spec compliant we have to
// take on the additional complexity of supporting it. Fortunately, using
// the linked list makes dispatching faster, even if adding/removing is
// slower.
class Listener {
  constructor(previous, listener, once, capture, passive,
              isNodeStyleListener, weak) {
    this.next = undefined;
    if (previous !== undefined)
      previous.next = this;
    this.previous = previous;
    this.listener = listener;
    // TODO(benjamingr) these 4 can be 'flags' to save 3 slots
    this.once = once;
    this.capture = capture;
    this.passive = passive;
    this.isNodeStyleListener = isNodeStyleListener;
    this.removed = false;
    this.weak = Boolean(weak); // Don't retain the object

    if (this.weak) {
      this.callback = new WeakRef(listener);
      weakListeners().registry.register(listener, this, this);
      // Make the retainer retain the listener in a WeakMap
      weakListeners().map.set(weak, listener);
      this.listener = this.callback;
    } else if (typeof listener === 'function') {
      this.callback = listener;
      this.listener = listener;
    } else {
      this.callback = listener.handleEvent.bind(listener);
      this.listener = listener;
    }
  }

  same(listener, capture) {
    const myListener = this.weak ? this.listener.deref() : this.listener;
    return myListener === listener && this.capture === capture;
  }

  remove() {
    if (this.previous !== undefined)
      this.previous.next = this.next;
    if (this.next !== undefined)
      this.next.previous = this.previous;
    this.removed = true;
    if (this.weak)
      weakListeners().registry.unregister(this);
  }
}

export function initEventTarget(self) {
  self[kEvents] = new Map();
  self[kMaxEventTargetListeners] = EventEmitter.defaultMaxListeners;
  self[kMaxEventTargetListenersWarned] = false;
}

export class EventTarget {
  // Used in checking whether an object is an EventTarget. This is a well-known
  // symbol as EventTarget may be used cross-realm.
  // Ref: https://github.com/nodejs/node/pull/33661
  static [kIsEventTarget] = true;

  constructor() {
    initEventTarget(this);
  }

  [kNewListener](size, type, listener, once, capture, passive) {
    if (this[kMaxEventTargetListeners] > 0 &&
        size > this[kMaxEventTargetListeners] &&
        !this[kMaxEventTargetListenersWarned]) {
      this[kMaxEventTargetListenersWarned] = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      const w = new Error('Possible EventTarget memory leak detected. ' +
                          `${size} ${type} listeners ` +
                          `added to ${inspect(this, { depth: -1 })}. Use ` +
                          'events.setMaxListeners() to increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.target = this;
      w.type = type;
      w.count = size;
      process.emitWarning(w);
    }
  }
  [kRemoveListener](size, type, listener, capture) {}

  addEventListener(type, listener, options = {}) {
    if (!isEventTarget(this))
      throw new ERR_INVALID_THIS('EventTarget');
    if (arguments.length < 2)
      throw new ERR_MISSING_ARGS('type', 'listener');

    // We validateOptions before the shouldAddListeners check because the spec
    // requires us to hit getters.
    const {
      once,
      capture,
      passive,
      signal,
      isNodeStyleListener,
      weak,
    } = validateEventListenerOptions(options);

    if (!shouldAddListener(listener)) {
      // The DOM silently allows passing undefined as a second argument
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      const w = new Error(`addEventListener called with ${listener}` +
                          ' which has no effect.');
      w.name = 'AddEventListenerArgumentTypeWarning';
      w.target = this;
      w.type = type;
      process.emitWarning(w);
      return;
    }
    type = String(type);

    if (signal) {
      if (signal.aborted) {
        return;
      }
      // TODO(benjamingr) make this weak somehow? ideally the signal would
      // not prevent the event target from GC.
      signal.addEventListener('abort', () => {
        this.removeEventListener(type, listener, options);
      }, { once: true, [kWeakHandler]: this });
    }

    let root = this[kEvents].get(type);

    if (root === undefined) {
      root = { size: 1, next: undefined };
      // This is the first handler in our linked list.
      new Listener(root, listener, once, capture, passive,
                   isNodeStyleListener, weak);
      this[kNewListener](root.size, type, listener, once, capture, passive);
      this[kEvents].set(type, root);
      return;
    }

    let handler = root.next;
    let previous = root;

    // We have to walk the linked list to see if we have a match
    while (handler !== undefined && !handler.same(listener, capture)) {
      previous = handler;
      handler = handler.next;
    }

    if (handler !== undefined) { // Duplicate! Ignore
      return;
    }

    new Listener(previous, listener, once, capture, passive,
                 isNodeStyleListener, weak);
    root.size++;
    this[kNewListener](root.size, type, listener, once, capture, passive);
  }

  removeEventListener(type, listener, options = {}) {
    if (!isEventTarget(this))
      throw new ERR_INVALID_THIS('EventTarget');
    if (!shouldAddListener(listener))
      return;

    type = String(type);
    const capture = options?.capture === true;

    const root = this[kEvents].get(type);
    if (root === undefined || root.next === undefined)
      return;

    let handler = root.next;
    while (handler !== undefined) {
      if (handler.same(listener, capture)) {
        handler.remove();
        root.size--;
        if (root.size === 0)
          this[kEvents].delete(type);
        this[kRemoveListener](root.size, type, listener, capture);
        break;
      }
      handler = handler.next;
    }
  }

  dispatchEvent(event) {
    if (!isEventTarget(this))
      throw new ERR_INVALID_THIS('EventTarget');

    if (!(event instanceof Event))
      throw new ERR_INVALID_ARG_TYPE('event', 'Event', event);

    if (event[kIsBeingDispatched])
      throw new ERR_EVENT_RECURSION(event.type);

    this[kHybridDispatch](event, event.type, event);

    return event.defaultPrevented !== true;
  }

  [kHybridDispatch](nodeValue, type, event) {
    const createEvent = () => {
      if (event === undefined) {
        event = this[kCreateEvent](nodeValue, type);
        event[kTarget] = this;
        event[kIsBeingDispatched] = true;
      }
      return event;
    };
    if (event !== undefined) {
      event[kTarget] = this;
      event[kIsBeingDispatched] = true;
    }

    const root = this[kEvents].get(type);
    if (root === undefined || root.next === undefined) {
      if (event !== undefined)
        event[kIsBeingDispatched] = false;
      return true;
    }

    let handler = root.next;
    let next;

    while (handler !== undefined &&
           (handler.passive || event?.[kStop] !== true)) {
      // Cache the next item in case this iteration removes the current one
      next = handler.next;

      if (handler.removed) {
        // Deal with the case an event is removed while event handlers are
        // Being processed (removeEventListener called from a listener)
        handler = next;
        continue;
      }
      if (handler.once) {
        handler.remove();
        root.size--;
        const { listener, capture } = handler;
        this[kRemoveListener](root.size, type, listener, capture);
      }

      try {
        let arg;
        if (handler.isNodeStyleListener) {
          arg = nodeValue;
        } else {
          arg = createEvent();
        }
        const callback = handler.weak ?
          handler.callback.deref() : handler.callback;
        let result;
        if (callback) {
          result = callback.call(this, arg);
          if (!handler.isNodeStyleListener) {
            arg[kIsBeingDispatched] = false;
          }
        }
        if (result !== undefined && result !== null)
          addCatch(result);
      } catch (err) {
        emitUncaughtException(err);
      }

      handler = next;
    }

    if (event !== undefined)
      event[kIsBeingDispatched] = false;
  }

  [kCreateEvent](nodeValue, type) {
    return new NodeCustomEvent(type, { detail: nodeValue });
  }
  [inspect.custom](depth, options) {
    if (!isEventTarget(this))
      throw new ERR_INVALID_THIS('EventTarget');
    const name = this.constructor.name;
    if (depth < 0)
      return name;

    const opts = Object.assign({}, options, {
      depth: Number.isInteger(options.depth) ? options.depth - 1 : options.depth
    });

    return `${name} ${inspect({}, opts)}`;
  }
}

Object.defineProperties(EventTarget.prototype, {
  addEventListener: kEnumerableProperty,
  removeEventListener: kEnumerableProperty,
  dispatchEvent: kEnumerableProperty,
  [Symbol.toStringTag]: {
    writable: false,
    enumerable: false,
    configurable: true,
    value: 'EventTarget',
  }
});

export function initNodeEventTarget(self) {
  initEventTarget(self);
}

export class NodeEventTarget extends EventTarget {
  static [kIsNodeEventTarget] = true;
  static defaultMaxListeners = 10;

  constructor() {
    super();
    initNodeEventTarget(this);
  }

  setMaxListeners(n) {
    if (!isNodeEventTarget(this))
      throw new ERR_INVALID_THIS('NodeEventTarget');
    EventEmitter.setMaxListeners(n, this);
  }

  getMaxListeners() {
    if (!isNodeEventTarget(this))
      throw new ERR_INVALID_THIS('NodeEventTarget');
    return this[kMaxEventTargetListeners];
  }

  eventNames() {
    if (!isNodeEventTarget(this))
      throw new ERR_INVALID_THIS('NodeEventTarget');
    return Array.from(this[kEvents].keys());
  }

  listenerCount(type) {
    if (!isNodeEventTarget(this))
      throw new ERR_INVALID_THIS('NodeEventTarget');
    const root = this[kEvents].get(String(type));
    return root !== undefined ? root.size : 0;
  }

  off(type, listener, options) {
    if (!isNodeEventTarget(this))
      throw new ERR_INVALID_THIS('NodeEventTarget');
    this.removeEventListener(type, listener, options);
    return this;
  }

  removeListener(type, listener, options) {
    if (!isNodeEventTarget(this))
      throw new ERR_INVALID_THIS('NodeEventTarget');
    this.removeEventListener(type, listener, options);
    return this;
  }

  on(type, listener) {
    if (!isNodeEventTarget(this))
      throw new ERR_INVALID_THIS('NodeEventTarget');
    this.addEventListener(type, listener, { [kIsNodeStyleListener]: true });
    return this;
  }

  addListener(type, listener) {
    if (!isNodeEventTarget(this))
      throw new ERR_INVALID_THIS('NodeEventTarget');
    this.addEventListener(type, listener, { [kIsNodeStyleListener]: true });
    return this;
  }
  emit(type, arg) {
    if (!isNodeEventTarget(this))
      throw new ERR_INVALID_THIS('NodeEventTarget');
    const hadListeners = this.listenerCount(type) > 0;
    this[kHybridDispatch](arg, type);
    return hadListeners;
  }

  once(type, listener) {
    if (!isNodeEventTarget(this))
      throw new ERR_INVALID_THIS('NodeEventTarget');
    this.addEventListener(type, listener,
                          { once: true, [kIsNodeStyleListener]: true });
    return this;
  }

  removeAllListeners(type) {
    if (!isNodeEventTarget(this))
      throw new ERR_INVALID_THIS('NodeEventTarget');
    if (type !== undefined) {
      this[kEvents].delete(String(type));
    } else {
      this[kEvents].clear();
    }

    return this;
  }
}

Object.defineProperties(NodeEventTarget.prototype, {
  setMaxListeners: kEnumerableProperty,
  getMaxListeners: kEnumerableProperty,
  eventNames: kEnumerableProperty,
  listenerCount: kEnumerableProperty,
  off: kEnumerableProperty,
  removeListener: kEnumerableProperty,
  on: kEnumerableProperty,
  addListener: kEnumerableProperty,
  once: kEnumerableProperty,
  emit: kEnumerableProperty,
  removeAllListeners: kEnumerableProperty,
});

// EventTarget API

function shouldAddListener(listener) {
  if (typeof listener === 'function' ||
      typeof listener?.handleEvent === 'function') {
    return true;
  }

  if (listener == null)
    return false;

  throw new ERR_INVALID_ARG_TYPE('listener', 'EventListener', listener);
}

function validateEventListenerOptions(options) {
  if (typeof options === 'boolean')
    return { capture: options };

  if (options === null)
    return {};
  return {
    once: Boolean(options.once),
    capture: Boolean(options.capture),
    passive: Boolean(options.passive),
    signal: options.signal,
    weak: options[kWeakHandler],
    isNodeStyleListener: Boolean(options[kIsNodeStyleListener])
  };
}

// Test whether the argument is an event object. This is far from a fool-proof
// test, for example this input will result in a false positive:
// > isEventTarget({ constructor: EventTarget })
// It stands in its current implementation as a compromise.
// Ref: https://github.com/nodejs/node/pull/33661
export function isEventTarget(obj) {
  return obj?.constructor?.[kIsEventTarget];
}

function isNodeEventTarget(obj) {
  return obj?.constructor?.[kIsNodeEventTarget];
}

function addCatch(promise) {
  const then = promise.then;
  if (typeof then === 'function') {
    then.call(promise, undefined, function(err) {
      // The callback is called with nextTick to avoid a follow-up
      // rejection from this promise.
      emitUncaughtException(err);
    });
  }
}

function emitUncaughtException(err) {
  process.nextTick(() => { throw err; });
}

function makeEventHandler(handler) {
  // Event handlers are dispatched in the order they were first set
  // See https://github.com/nodejs/node/pull/35949#issuecomment-722496598
  function eventHandler(...args) {
    if (typeof eventHandler.handler !== 'function') {
      return;
    }
    return Reflect.apply(eventHandler.handler, this, args);
  }
  eventHandler.handler = handler;
  return eventHandler;
}

export function defineEventHandler(emitter, name) {
  // 8.1.5.1 Event handlers - basically `on[eventName]` attributes
  Object.defineProperty(emitter, `on${name}`, {
    get() {
      return this[kHandlers]?.get(name)?.handler;
    },
    set(value) {
      if (!this[kHandlers]) {
        this[kHandlers] = new Map();
      }
      let wrappedHandler = this[kHandlers]?.get(name);
      if (wrappedHandler) {
        if (typeof wrappedHandler.handler === 'function') {
          this[kEvents].get(name).size--;
          const size = this[kEvents].get(name).size;
          this[kRemoveListener](size, name, wrappedHandler.handler, false);
        }
        wrappedHandler.handler = value;
        if (typeof wrappedHandler.handler === 'function') {
          this[kEvents].get(name).size++;
          const size = this[kEvents].get(name).size;
          this[kNewListener](size, name, value, false, false, false);
        }
      } else {
        wrappedHandler = makeEventHandler(value);
        this.addEventListener(name, wrappedHandler);
      }
      this[kHandlers].set(name, wrappedHandler);
    },
    configurable: true,
    enumerable: true
  });
}

export const EventEmitterMixin = (Superclass) => {
  class MixedEventEmitter extends Superclass {
    constructor(...args) {
      super(...args);
      EventEmitter.call(this);
    }
  }
  const protoProps = Object.getOwnPropertyDescriptors(EventEmitter.prototype);
  delete protoProps.constructor;
  Object.defineProperties(MixedEventEmitter.prototype, protoProps);
  return MixedEventEmitter;
};

âœ„
import { codes as errorCodes } from '../errors.js';

import { Buffer } from 'buffer';
import process from 'process';

const {
  ERR_INVALID_ARG_TYPE,
  ERR_STREAM_NULL_VALUES
} = errorCodes;

export default function from(Readable, iterable, opts) {
  let iterator;
  if (typeof iterable === 'string' || iterable instanceof Buffer) {
    return new Readable({
      objectMode: true,
      ...opts,
      read() {
        this.push(iterable);
        this.push(null);
      }
    });
  }

  let isAsync;
  if (iterable && iterable[Symbol.asyncIterator]) {
    isAsync = true;
    iterator = iterable[Symbol.asyncIterator]();
  } else if (iterable && iterable[Symbol.iterator]) {
    isAsync = false;
    iterator = iterable[Symbol.iterator]();
  } else {
    throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable);
  }

  const readable = new Readable({
    objectMode: true,
    highWaterMark: 1,
    // TODO(ronag): What options should be allowed?
    ...opts,
  });

  // Flag to protect against _read
  // being called before last iteration completion.
  let reading = false;

  readable._read = function() {
    if (!reading) {
      reading = true;
      next();
    }
  };

  readable._destroy = function(error, cb) {
    close(error).then(
      () => process.nextTick(cb, error), // nextTick is here in case cb throws
      (e) => process.nextTick(cb, e || error),
    );
  };

  async function close(error) {
    const hadError = (error !== undefined) && (error !== null);
    const hasThrow = typeof iterator.throw === 'function';
    if (hadError && hasThrow) {
      const { value, done } = await iterator.throw(error);
      await value;
      if (done) {
        return;
      }
    }
    if (typeof iterator.return === 'function') {
      const { value } = await iterator.return();
      await value;
    }
  }

  async function next() {
    for (;;) {
      try {
        const { value, done } = isAsync ?
          await iterator.next() :
          iterator.next();

        if (done) {
          readable.push(null);
        } else {
          const res = (value &&
            typeof value.then === 'function') ?
            await value :
            value;
          if (res === null) {
            reading = false;
            throw new ERR_STREAM_NULL_VALUES();
          } else if (readable.push(res)) {
            continue;
          } else {
            reading = false;
          }
        }
      } catch (err) {
        readable.destroy(err);
      }
      break;
    }
  }
  return readable;
}

âœ„
import EE from 'events';

export function Stream(opts) {
  EE.call(this, opts);
}
Object.setPrototypeOf(Stream.prototype, EE.prototype);
Object.setPrototypeOf(Stream, EE);

Stream.prototype.pipe = function(dest, options) {
  const source = this;

  function ondata(chunk) {
    if (dest.writable && dest.write(chunk) === false && source.pause) {
      source.pause();
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  let didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // Don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      this.emit('error', er);
    }
  }

  prependListener(source, 'error', onerror);
  prependListener(dest, 'error', onerror);

  // Remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);
  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

export function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function')
    return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event])
    emitter.on(event, fn);
  else if (Array.isArray(emitter._events[event]))
    emitter._events[event].unshift(fn);
  else
    emitter._events[event] = [fn, emitter._events[event]];
}

âœ„
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

export default function once(callback) {
  let called = false;
  return function(...args) {
    if (called) return;
    called = true;
    Reflect.apply(callback, this, args);
  };
}

âœ„
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

import Transform from './transform.js';
Object.setPrototypeOf(PassThrough.prototype, Transform.prototype);
Object.setPrototypeOf(PassThrough, Transform);

export default function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

âœ„
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).

import { AbortController } from './abort_controller.js';
import * as destroyImpl from './destroy.js';
import Duplex from './duplex.js';
import eos from './end-of-stream.js';
import {
  aggregateTwoErrors,
  codes as errorCodes,
  AbortError,
} from '../errors.js';
import once from './once.js';
import PassThrough from './passthrough.js';
import Readable from './readable.js';
import {
  isIterable,
  isReadableNodeStream,
  isNodeStream,
} from './utils.js';

import process from 'process';

const {
  ERR_INVALID_ARG_TYPE,
  ERR_INVALID_RETURN_VALUE,
  ERR_MISSING_ARGS,
  ERR_STREAM_DESTROYED,
} = errorCodes;

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);

  let finished = false;
  stream.on('close', () => {
    finished = true;
  });

  eos(stream, { readable: reading, writable: writing }, (err) => {
    finished = !err;

    const rState = stream._readableState;
    if (
      err &&
      err.code === 'ERR_STREAM_PREMATURE_CLOSE' &&
      reading &&
      (rState && rState.ended && !rState.errored && !rState.errorEmitted)
    ) {
      // Some readable streams will emit 'close' before 'end'. However, since
      // this is on the readable side 'end' should still be emitted if the
      // stream has been ended and no error emitted. This should be allowed in
      // favor of backwards compatibility. Since the stream is piped to a
      // destination this should not result in any observable difference.
      // We don't need to check if this is a writable premature close since
      // eos will only fail with premature close on the reading side for
      // duplex streams.
      stream
        .once('end', callback)
        .once('error', callback);
    } else {
      callback(err);
    }
  });

  return (err) => {
    if (finished) return;
    finished = true;
    destroyImpl.destroyer(stream, err);
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function popCallback(streams) {
  // Streams should never be an empty array. It should always contain at least
  // a single stream. Therefore optimize for the average case instead of
  // checking for length === 0 as well.
  return streams.pop();
}

function makeAsyncIterable(val) {
  if (isIterable(val)) {
    return val;
  } else if (isReadableNodeStream(val)) {
    // Legacy streams are not Iterable.
    return fromReadable(val);
  }
  throw new ERR_INVALID_ARG_TYPE(
    'val', ['Readable', 'Iterable', 'AsyncIterable'], val);
}

async function* fromReadable(val) {
  yield* Readable.prototype[Symbol.asyncIterator].call(val);
}

async function pump(iterable, writable, finish) {
  let error;
  let onresolve = null;

  const resume = (err) => {
    if (err) {
      error = err;
    }

    if (onresolve) {
      const callback = onresolve;
      onresolve = null;
      callback();
    }
  };

  const wait = () => new Promise((resolve, reject) => {
    if (error) {
      reject(error);
    } else {
      onresolve = () => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      };
    }
  });

  writable.on('drain', resume);
  const cleanup = eos(writable, { readable: false }, resume);

  try {
    if (writable.writableNeedDrain) {
      await wait();
    }

    for await (const chunk of iterable) {
      if (!writable.write(chunk)) {
        await wait();
      }
    }

    writable.end();

    await wait();

    finish();
  } catch (err) {
    finish(error !== err ? aggregateTwoErrors(error, err) : err);
  } finally {
    cleanup();
    writable.off('drain', resume);
  }
}

export default pipeline;

export function pipeline(...streams) {
  const callback = once(popCallback(streams));

  // stream.pipeline(streams, callback)
  if (Array.isArray(streams[0]) && streams.length === 1) {
    streams = streams[0];
  }

  return pipelineImpl(streams, callback);
}

export function pipelineImpl(streams, callback, opts) {
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  const ac = new AbortController();
  const signal = ac.signal;
  const outerSignal = opts?.signal;

  function abort() {
    finishImpl(new AbortError());
  }

  outerSignal?.addEventListener('abort', abort);

  let error;
  let value;
  const destroys = [];

  let finishCount = 0;

  function finish(err) {
    finishImpl(err, --finishCount === 0);
  }

  function finishImpl(err, final) {
    if (err && (!error || error.code === 'ERR_STREAM_PREMATURE_CLOSE')) {
      error = err;
    }

    if (!error && !final) {
      return;
    }

    while (destroys.length) {
      destroys.shift()(error);
    }

    outerSignal?.removeEventListener('abort', abort);
    ac.abort();

    if (final) {
      callback(error, value);
    }
  }

  let ret;
  for (let i = 0; i < streams.length; i++) {
    const stream = streams[i];
    const reading = i < streams.length - 1;
    const writing = i > 0;

    if (isNodeStream(stream)) {
      finishCount++;
      destroys.push(destroyer(stream, reading, writing, finish));
    }

    if (i === 0) {
      if (typeof stream === 'function') {
        ret = stream({ signal });
        if (!isIterable(ret)) {
          throw new ERR_INVALID_RETURN_VALUE(
            'Iterable, AsyncIterable or Stream', 'source', ret);
        }
      } else if (isIterable(stream) || isReadableNodeStream(stream)) {
        ret = stream;
      } else {
        ret = Duplex.from(stream);
      }
    } else if (typeof stream === 'function') {
      ret = makeAsyncIterable(ret);
      ret = stream(ret, { signal });

      if (reading) {
        if (!isIterable(ret, true)) {
          throw new ERR_INVALID_RETURN_VALUE(
            'AsyncIterable', `transform[${i - 1}]`, ret);
        }
      } else {
        if (!PassThrough) {
        }

        // If the last argument to pipeline is not a stream
        // we must create a proxy stream so that pipeline(...)
        // always returns a stream which can be further
        // composed through `.pipe(stream)`.

        const pt = new PassThrough({
          objectMode: true
        });

        // Handle Promises/A+ spec, `then` could be a getter that throws on
        // second use.
        const then = ret?.then;
        if (typeof then === 'function') {
          then.call(ret,
                    (val) => {
                      value = val;
                      pt.end(val);
                    }, (err) => {
                      pt.destroy(err);
                    },
          );
        } else if (isIterable(ret, true)) {
          finishCount++;
          pump(ret, pt, finish);
        } else {
          throw new ERR_INVALID_RETURN_VALUE(
            'AsyncIterable or Promise', 'destination', ret);
        }

        ret = pt;

        finishCount++;
        destroys.push(destroyer(ret, false, true, finish));
      }
    } else if (isNodeStream(stream)) {
      if (isReadableNodeStream(ret)) {
        ret.pipe(stream);

        // Compat. Before node v10.12.0 stdio used to throw an error so
        // pipe() did/does not end() stdio destinations.
        // Now they allow it but "secretly" don't close the underlying fd.
        if (stream === process.stdout || stream === process.stderr) {
          ret.on('end', () => stream.end());
        }
      } else {
        ret = makeAsyncIterable(ret);

        finishCount++;
        pump(ret, stream, finish);
      }
      ret = stream;
    } else {
      ret = Duplex.from(stream);
    }
  }

  if (signal?.aborted || outerSignal?.aborted) {
    process.nextTick(abort);
  }

  return ret;
}

âœ„
import eos from './end-of-stream.js';
import { pipelineImpl as pl } from './pipeline.js';
import {
  isIterable,
  isNodeStream,
} from './utils.js';

export function pipeline(...streams) {
  return new Promise((resolve, reject) => {
    let signal;
    const lastArg = streams[streams.length - 1];
    if (lastArg && typeof lastArg === 'object' &&
        !isNodeStream(lastArg) && !isIterable(lastArg)) {
      const options = streams.pop();
      signal = options.signal;
    }

    pl(streams, (err, value) => {
      if (err) {
        reject(err);
      } else {
        resolve(value);
      }
    }, { signal });
  });
}

export function finished(stream, opts) {
  return new Promise((resolve, reject) => {
    eos(stream, opts, (err) => {
      if (err) {
        reject(err);
      } else {
        resolve();
      }
    });
  });
}

âœ„
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

import { addAbortSignal } from './add-abort-signal.js';
import BufferList from './buffer_list.js';
import * as destroyImpl from './destroy.js';
import eos from './end-of-stream.js';
import {
  aggregateTwoErrors,
  codes as errorCodes,
} from '../errors.js';
import from from './from.js';
import { Stream, prependListener } from './legacy.js';
import {
  getHighWaterMark,
  getDefaultHighWaterMark
} from './state.js';

import { Buffer } from 'buffer';
import EE from 'events';
import process from 'process';
import { StringDecoder } from 'string_decoder';

export default Readable;

const {
  ERR_INVALID_ARG_TYPE,
  ERR_METHOD_NOT_IMPLEMENTED,
  ERR_OUT_OF_RANGE,
  ERR_STREAM_PUSH_AFTER_EOF,
  ERR_STREAM_UNSHIFT_AFTER_END_EVENT,
} = errorCodes;

const kPaused = Symbol('kPaused');

Object.setPrototypeOf(Readable.prototype, Stream.prototype);
Object.setPrototypeOf(Readable, Stream);
const nop = () => {};

const { errorOrDestroy } = destroyImpl;

export function ReadableState(options, stream, isDuplex) {
  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  if (typeof isDuplex !== 'boolean')
    isDuplex = stream instanceof Stream.Duplex;

  // Object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away.
  this.objectMode = !!(options && options.objectMode);

  if (isDuplex)
    this.objectMode = this.objectMode ||
      !!(options && options.readableObjectMode);

  // The point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  this.highWaterMark = options ?
    getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex) :
    getDefaultHighWaterMark(false);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift().
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = [];
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // Stream is still being constructed and cannot be
  // destroyed until construction finished or failed.
  // Async construction is opt in, therefore we start as
  // constructed.
  this.constructed = true;

  // A flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // Whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this[kPaused] = null;

  // True if the error was already emitted and should not be thrown again.
  this.errorEmitted = false;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = !options || options.emitClose !== false;

  // Should .destroy() be called after 'end' (and potentially 'finish').
  this.autoDestroy = !options || options.autoDestroy !== false;

  // Has it been destroyed.
  this.destroyed = false;

  // Indicates whether the stream has errored. When true no further
  // _read calls, 'data' or 'readable' events should occur. This is needed
  // since when autoDestroy is disabled we need a way to tell whether the
  // stream has failed.
  this.errored = null;

  // Indicates whether the stream has finished destroying.
  this.closed = false;

  // True if close has been emitted or would have been emitted
  // depending on emitClose.
  this.closeEmitted = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8';

  // Ref the piped dest which we need a drain event on it
  // type: null | Writable | Set<Writable>.
  this.awaitDrainWriters = null;
  this.multiAwaitDrain = false;

  // If true, a maybeReadMore has been scheduled.
  this.readingMore = false;

  this.dataEmitted = false;

  this.decoder = null;
  this.encoding = null;
  if (options && options.encoding) {
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}


export function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5.
  const isDuplex = this instanceof Stream.Duplex;

  this._readableState = new ReadableState(options, this, isDuplex);

  if (options) {
    if (typeof options.read === 'function')
      this._read = options.read;

    if (typeof options.destroy === 'function')
      this._destroy = options.destroy;

    if (typeof options.construct === 'function')
      this._construct = options.construct;

    if (options.signal && !isDuplex)
      addAbortSignal(options.signal, this);
  }

  Stream.call(this, options);

  destroyImpl.construct(this, () => {
    if (this._readableState.needReadable) {
      maybeReadMore(this, this._readableState);
    }
  });
}

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function(err, cb) {
  cb(err);
};

Readable.prototype[EE.captureRejectionSymbol] = function(err) {
  this.destroy(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  return readableAddChunk(this, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read().
Readable.prototype.unshift = function(chunk, encoding) {
  return readableAddChunk(this, chunk, encoding, true);
};

function readableAddChunk(stream, chunk, encoding, addToFront) {
  const state = stream._readableState;

  let err;
  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (state.encoding !== encoding) {
        if (addToFront && state.encoding) {
          // When unshifting, if state.encoding is set, we have to save
          // the string in the BufferList with the state encoding.
          chunk = Buffer.from(chunk, encoding).toString(state.encoding);
        } else {
          chunk = Buffer.from(chunk, encoding);
          encoding = '';
        }
      }
    } else if (chunk instanceof Buffer) {
      encoding = '';
    } else if (Stream._isUint8Array(chunk)) {
      chunk = Stream._uint8ArrayToBuffer(chunk);
      encoding = '';
    } else if (chunk != null) {
      err = new ERR_INVALID_ARG_TYPE(
        'chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
    }
  }

  if (err) {
    errorOrDestroy(stream, err);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || (chunk && chunk.length > 0)) {
    if (addToFront) {
      if (state.endEmitted)
        errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
      else if (state.destroyed || state.errored)
        return false;
      else
        addChunk(stream, state, chunk, true);
    } else if (state.ended) {
      errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
    } else if (state.destroyed || state.errored) {
      return false;
    } else {
      state.reading = false;
      if (state.decoder && !encoding) {
        chunk = state.decoder.write(chunk);
        if (state.objectMode || chunk.length !== 0)
          addChunk(stream, state, chunk, false);
        else
          maybeReadMore(stream, state);
      } else {
        addChunk(stream, state, chunk, false);
      }
    }
  } else if (!addToFront) {
    state.reading = false;
    maybeReadMore(stream, state);
  }

  // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.
  return !state.ended &&
    (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync &&
      stream.listenerCount('data') > 0) {
    // Use the guard to avoid creating `Set()` repeatedly
    // when we have multiple pipes.
    if (state.multiAwaitDrain) {
      state.awaitDrainWriters.clear();
    } else {
      state.awaitDrainWriters = null;
    }

    state.dataEmitted = true;
    stream.emit('data', chunk);
  } else {
    // Update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront)
      state.buffer.unshift(chunk);
    else
      state.buffer.push(chunk);

    if (state.needReadable)
      emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

Readable.prototype.isPaused = function() {
  const state = this._readableState;
  return state[kPaused] === true || state.flowing === false;
};

// Backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  const decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder;
  // If setEncoding(null), decoder.encoding equals utf8.
  this._readableState.encoding = this._readableState.decoder.encoding;

  const buffer = this._readableState.buffer;
  // Iterate over current buffer to convert already stored Buffers:
  let content = '';
  for (const data of buffer) {
    content += decoder.write(data);
  }
  buffer.clear();
  if (content !== '')
    buffer.push(content);
  this._readableState.length = content.length;
  return this;
};

// Don't raise the hwm > 1GB.
const MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
  if (n > MAX_HWM) {
    throw new ERR_OUT_OF_RANGE('size', '<= 1GiB', n);
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts.
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || (state.length === 0 && state.ended))
    return 0;
  if (state.objectMode)
    return 1;
  if (Number.isNaN(n)) {
    // Only flow one buffer at a time.
    if (state.flowing && state.length)
      return state.buffer.first().length;
    return state.length;
  }
  if (n <= state.length)
    return n;
  return state.ended ? state.length : 0;
}

// You can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  // Same as parseInt(undefined, 10), however V8 7.3 performance regressed
  // in this scenario, so we are doing it manually.
  if (n === undefined) {
    n = NaN;
  } else if (!Number.isInteger(n)) {
    n = Number.parseInt(n, 10);
  }
  const state = this._readableState;
  const nOrig = n;

  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark)
    state.highWaterMark = computeNewHighWaterMark(n);

  if (n !== 0)
    state.emittedReadable = false;

  // If we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      ((state.highWaterMark !== 0 ?
        state.length >= state.highWaterMark :
        state.length > 0) ||
       state.ended)) {
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // If we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  let doRead = state.needReadable;

  // If we currently have less than the highWaterMark, then also read some.
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
  }

  // However, if we've ended, then there's no point, if we're already
  // reading, then it's unnecessary, if we're constructing we have to wait,
  // and if we're destroyed or errored, then it's not allowed,
  if (state.ended || state.reading || state.destroyed || state.errored ||
      !state.constructed) {
    doRead = false;
  } else if (doRead) {
    state.reading = true;
    state.sync = true;
    // If the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;

    // Call internal read method
    try {
      const result = this._read(state.highWaterMark);
      if (result != null) {
        const then = result.then;
        if (typeof then === 'function') {
          then.call(
            result,
            nop,
            function(err) {
              errorOrDestroy(this, err);
            });
        }
      }
    } catch (err) {
      errorOrDestroy(this, err);
    }

    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading)
      n = howMuchToRead(nOrig, state);
  }

  let ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    if (state.multiAwaitDrain) {
      state.awaitDrainWriters.clear();
    } else {
      state.awaitDrainWriters = null;
    }
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended)
      state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended)
      endReadable(this);
  }

  if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
    state.dataEmitted = true;
    this.emit('data', ret);
  }

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    const chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  if (state.sync) {
    // If we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call.
    emitReadable(stream);
  } else {
    // Emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;
    state.emittedReadable = true;
    // We have to emit readable now that we are EOF. Modules
    // in the ecosystem (e.g. dicer) rely on this event being sync.
    emitReadable_(stream);
  }
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  const state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  const state = stream._readableState;
  if (!state.destroyed && !state.errored && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  }

  // The stream needs another readable event if:
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.
  state.needReadable =
    !state.flowing &&
    !state.ended &&
    state.length <= state.highWaterMark;
  flow(stream);
}


// At this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore && state.constructed) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended &&
         (state.length < state.highWaterMark ||
          (state.flowing && state.length === 0))) {
    const len = state.length;
    stream.read(0);
    if (len === state.length)
      // Didn't get any data, stop spinning.
      break;
  }
  state.readingMore = false;
}

// Abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  throw new ERR_METHOD_NOT_IMPLEMENTED('_read()');
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  const src = this;
  const state = this._readableState;

  if (state.pipes.length === 1) {
    if (!state.multiAwaitDrain) {
      state.multiAwaitDrain = true;
      state.awaitDrainWriters = new Set(
        state.awaitDrainWriters ? [state.awaitDrainWriters] : []
      );
    }
  }

  state.pipes.push(dest);

  const doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  const endFn = doEnd ? onend : unpipe;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    dest.end();
  }

  let ondrain;

  let cleanedUp = false;
  function cleanup() {
    // Cleanup event handlers once the pipe is broken.
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    if (ondrain) {
      dest.removeListener('drain', ondrain);
    }
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // If the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (ondrain && state.awaitDrainWriters &&
        (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }

  function pause() {
    // If the user unpiped during `dest.write()`, it is possible
    // to get stuck in a permanently paused state if that write
    // also returned false.
    // => Check whether `dest` is still a piping destination.
    if (!cleanedUp) {
      if (state.pipes.length === 1 && state.pipes[0] === dest) {
        state.awaitDrainWriters = dest;
        state.multiAwaitDrain = false;
      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
        state.awaitDrainWriters.add(dest);
      }
      src.pause();
    }
    if (!ondrain) {
      // When the dest drains, it reduces the awaitDrain counter
      // on the source.  This would be more elegant with a .once()
      // handler in flow(), but adding and removing repeatedly is
      // too slow.
      ondrain = pipeOnDrain(src, dest);
      dest.on('drain', ondrain);
    }
  }

  src.on('data', ondata);
  function ondata(chunk) {
    const ret = dest.write(chunk);
    if (ret === false) {
      pause();
    }
  }

  // If the dest has an error, then stop piping into it.
  // However, don't suppress the throwing behavior for this.
  function onerror(er) {
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0) {
      const s = dest._writableState || dest._readableState;
      if (s && !s.errorEmitted) {
        // User incorrectly emitted 'error' directly on the stream.
        errorOrDestroy(dest, er);
      } else {
        dest.emit('error', er);
      }
    }
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // Tell the dest that it's being piped to.
  dest.emit('pipe', src);

  // Start the flow if it hasn't been started already.

  if (dest.writableNeedDrain === true) {
    if (state.flowing) {
      pause();
    }
  } else if (!state.flowing) {
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src, dest) {
  return function pipeOnDrainFunctionResult() {
    const state = src._readableState;

    // `ondrain` will call directly,
    // `this` maybe not a reference to dest,
    // so we use the real dest here.
    if (state.awaitDrainWriters === dest) {
      state.awaitDrainWriters = null;
    } else if (state.multiAwaitDrain) {
      state.awaitDrainWriters.delete(dest);
    }

    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) &&
      EE.listenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}


Readable.prototype.unpipe = function(dest) {
  const state = this._readableState;
  const unpipeInfo = { hasUnpiped: false };

  // If we're not piping anywhere, then do nothing.
  if (state.pipes.length === 0)
    return this;

  if (!dest) {
    // remove all.
    const dests = state.pipes;
    state.pipes = [];
    this.pause();

    for (let i = 0; i < dests.length; i++)
      dests[i].emit('unpipe', this, { hasUnpiped: false });
    return this;
  }

  // Try to find the right one.
  const index = state.pipes.indexOf(dest);
  if (index === -1)
    return this;

  state.pipes.splice(index, 1);
  if (state.pipes.length === 0)
    this.pause();

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// Set up data events if they are asked for
// Ensure readable listeners eventually get something.
Readable.prototype.on = function(ev, fn) {
  const res = Stream.prototype.on.call(this, ev, fn);
  const state = this._readableState;

  if (ev === 'data') {
    // Update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0;

    // Try start flowing on next tick if stream isn't explicitly paused.
    if (state.flowing !== false)
      this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function(ev, fn) {
  const res = Stream.prototype.removeListener.call(this,
                                                   ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};
Readable.prototype.off = Readable.prototype.removeListener;

Readable.prototype.removeAllListeners = function(ev) {
  const res = Stream.prototype.removeAllListeners.apply(this,
                                                        arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  const state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && state[kPaused] === false) {
    // Flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true;

    // Crude way to check if we should resume.
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  } else if (!state.readableListening) {
    state.flowing = null;
  }
}

function nReadingNextTick(self) {
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  const state = this._readableState;
  if (!state.flowing) {
    // We flow only if there is no one listening
    // for readable, but we still have to call
    // resume().
    state.flowing = !state.readableListening;
    resume(this, state);
  }
  state[kPaused] = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}

Readable.prototype.pause = function() {
  if (this._readableState.flowing !== false) {
    this._readableState.flowing = false;
    this.emit('pause');
  }
  this._readableState[kPaused] = true;
  return this;
};

function flow(stream) {
  const state = stream._readableState;
  while (state.flowing && stream.read() !== null);
}

// Wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  let paused = false;

  // TODO (ronag): Should this.destroy(err) emit
  // 'error' on the wrapped stream? Would require
  // a static factory method, e.g. Readable.wrap(stream).

  stream.on('data', (chunk) => {
    if (!this.push(chunk) && stream.pause) {
      paused = true;
      stream.pause();
    }
  });

  stream.on('end', () => {
    this.push(null);
  });

  stream.on('error', (err) => {
    errorOrDestroy(this, err);
  });

  stream.on('close', () => {
    this.destroy();
  });

  stream.on('destroy', () => {
    this.destroy();
  });

  this._read = () => {
    if (paused && stream.resume) {
      paused = false;
      stream.resume();
    }
  };

  // Proxy all the other methods. Important when wrapping filters and duplexes.
  const streamKeys = Object.keys(stream);
  for (let j = 1; j < streamKeys.length; j++) {
    const i = streamKeys[j];
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = stream[i].bind(stream);
    }
  }

  return this;
};

Readable.prototype[Symbol.asyncIterator] = function() {
  return streamToAsyncIterator(this);
};

Readable.prototype.iterator = function(options) {
  return streamToAsyncIterator(this, options);
};

function streamToAsyncIterator(stream, options) {
  if (typeof stream.read !== 'function') {
    stream = Readable.wrap(stream, { objectMode: true });
  }

  const iter = createAsyncIterator(stream, options);
  iter.stream = stream;
  return iter;
}

async function* createAsyncIterator(stream, options) {
  let callback = nop;

  function next(resolve) {
    if (this === stream) {
      callback();
      callback = nop;
    } else {
      callback = resolve;
    }
  }

  stream.on('readable', next);

  let error;
  eos(stream, { writable: false }, (err) => {
    error = err ? aggregateTwoErrors(error, err) : null;
    callback();
    callback = nop;
  });

  try {
    while (true) {
      const chunk = stream.destroyed ? null : stream.read();
      if (chunk !== null) {
        yield chunk;
      } else if (error) {
        throw error;
      } else if (error === null) {
        return;
      } else {
        await new Promise(next);
      }
    }
  } catch (err) {
    error = aggregateTwoErrors(error, err);
    throw error;
  } finally {
    if (
      (error || options?.destroyOnReturn !== false) &&
      (error === undefined || stream._readableState.autoDestroy)
    ) {
      destroyImpl.destroyer(stream, null);
    }
  }
}

// Making it explicit these properties are not enumerable
// because otherwise some prototype manipulation in
// userland will fail.
Object.defineProperties(Readable.prototype, {
  readable: {
    get() {
      const r = this._readableState;
      // r.readable === false means that this is part of a Duplex stream
      // where the readable side was disabled upon construction.
      // Compat. The user might manually disable readable side through
      // deprecated setter.
      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted &&
        !r.endEmitted;
    },
    set(val) {
      // Backwards compat.
      if (this._readableState) {
        this._readableState.readable = !!val;
      }
    }
  },

  readableDidRead: {
    enumerable: false,
    get: function() {
      return this._readableState.dataEmitted;
    }
  },

  readableAborted: {
    enumerable: false,
    get: function() {
      return !!(this._readableState.destroyed || this._readableState.errored) &&
        !this._readableState.endEmitted;
    }
  },

  readableHighWaterMark: {
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  },

  readableBuffer: {
    enumerable: false,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  },

  readableFlowing: {
    enumerable: false,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  },

  readableLength: {
    enumerable: false,
    get() {
      return this._readableState.length;
    }
  },

  readableObjectMode: {
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.objectMode : false;
    }
  },

  readableEncoding: {
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.encoding : null;
    }
  },

  destroyed: {
    enumerable: false,
    get() {
      if (this._readableState === undefined) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set(value) {
      // We ignore the value if the stream
      // has not been initialized yet.
      if (!this._readableState) {
        return;
      }

      // Backward compatibility, the user is explicitly
      // managing destroyed.
      this._readableState.destroyed = value;
    }
  },

  readableEnded: {
    enumerable: false,
    get() {
      return this._readableState ? this._readableState.endEmitted : false;
    }
  },

});

Object.defineProperties(ReadableState.prototype, {
  // Legacy getter for `pipesCount`.
  pipesCount: {
    get() {
      return this.pipes.length;
    }
  },

  // Legacy property for `paused`.
  paused: {
    get() {
      return this[kPaused] !== false;
    },
    set(value) {
      this[kPaused] = !!value;
    }
  }
});

// Exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered.
  if (state.length === 0)
    return null;

  let ret;
  if (state.objectMode)
    ret = state.buffer.shift();
  else if (!n || n >= state.length) {
    // Read it all, truncate the list.
    if (state.decoder)
      ret = state.buffer.join('');
    else if (state.buffer.length === 1)
      ret = state.buffer.first();
    else
      ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list.
    ret = state.buffer.consume(n, state.decoder);
  }

  return ret;
}

function endReadable(stream) {
  const state = stream._readableState;

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.errored && !state.closeEmitted &&
      !state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.emit('end');

    if (stream.writable && stream.allowHalfOpen === false) {
      process.nextTick(endWritableNT, stream);
    } else if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well.
      const wState = stream._writableState;
      const autoDestroy = !wState || (
        wState.autoDestroy &&
        // We don't expect the writable to ever 'finish'
        // if writable is explicitly set to false.
        (wState.finished || wState.writable === false)
      );

      if (autoDestroy) {
        stream.destroy();
      }
    }
  }
}

function endWritableNT(stream) {
  const writable = stream.writable && !stream.writableEnded &&
    !stream.destroyed;
  if (writable) {
    stream.end();
  }
}

Readable.from = function(iterable, opts) {
  return from(Readable, iterable, opts);
};

Readable.wrap = function(src, options) {
  return new Readable({
    objectMode: src.readableObjectMode ?? src.objectMode ?? true,
    ...options,
    destroy(err, callback) {
      destroyImpl.destroyer(src, err);
      callback(err);
    }
  }).wrap(src);
};

âœ„
import { codes as errorCodes } from '../errors.js';

const { ERR_INVALID_ARG_VALUE } = errorCodes;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark :
    isDuplex ? options[duplexKey] : null;
}

export function getDefaultHighWaterMark(objectMode) {
  return objectMode ? 16 : 16 * 1024;
}

export function getHighWaterMark(state, options, duplexKey, isDuplex) {
  const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!Number.isInteger(hwm) || hwm < 0) {
      const name = isDuplex ? `options.${duplexKey}` : 'options.highWaterMark';
      throw new ERR_INVALID_ARG_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }

  // Default value
  return getDefaultHighWaterMark(state.objectMode);
}

âœ„
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

import Duplex from './duplex.js';
import { codes as errorCodes } from '../errors.js';

import process from 'process';

const {
  ERR_METHOD_NOT_IMPLEMENTED
} = errorCodes;

Object.setPrototypeOf(Transform.prototype, Duplex.prototype);
Object.setPrototypeOf(Transform, Duplex);

const kCallback = Symbol('kCallback');

export default function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  // We have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this[kCallback] = null;

  if (options) {
    if (typeof options.transform === 'function')
      this._transform = options.transform;

    if (typeof options.flush === 'function')
      this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  // Backwards compat. Some Transform streams incorrectly implement _final
  // instead of or in addition to _flush. By using 'prefinish' instead of
  // implementing _final we continue supporting this unfortunate use case.
  this.on('prefinish', prefinish);
}

function final(cb) {
  let called = false;
  if (typeof this._flush === 'function' && !this.destroyed) {
    const result = this._flush((er, data) => {
      called = true;
      if (er) {
        if (cb) {
          cb(er);
        } else {
          this.destroy(er);
        }
        return;
      }

      if (data != null) {
        this.push(data);
      }
      this.push(null);
      if (cb) {
        cb();
      }
    });
    if (result !== undefined && result !== null) {
      try {
        const then = result.then;
        if (typeof then === 'function') {
          then.call(
            result,
            (data) => {
              if (called)
                return;
              if (data != null)
                this.push(data);
              this.push(null);
              if (cb)
                process.nextTick(cb);
            },
            (err) => {
              if (cb) {
                process.nextTick(cb, err);
              } else {
                process.nextTick(() => this.destroy(err));
              }
            });
        }
      } catch (err) {
        process.nextTick(() => this.destroy(err));
      }
    }
  } else {
    this.push(null);
    if (cb) {
      cb();
    }
  }
}

function prefinish() {
  if (this._final !== final) {
    final.call(this);
  }
}

Transform.prototype._final = final;

Transform.prototype._transform = function(chunk, encoding, callback) {
  throw new ERR_METHOD_NOT_IMPLEMENTED('_transform()');
};

Transform.prototype._write = function(chunk, encoding, callback) {
  const rState = this._readableState;
  const wState = this._writableState;
  const length = rState.length;

  let called = false;
  const result = this._transform(chunk, encoding, (err, val) => {
    called = true;
    if (err) {
      callback(err);
      return;
    }

    if (val != null) {
      this.push(val);
    }

    if (
      wState.ended || // Backwards compat.
      length === rState.length || // Backwards compat.
      rState.length < rState.highWaterMark ||
      rState.length === 0
    ) {
      callback();
    } else {
      this[kCallback] = callback;
    }
  });
  if (result !== undefined && result != null) {
    try {
      const then = result.then;
      if (typeof then === 'function') {
        then.call(
          result,
          (val) => {
            if (called)
              return;

            if (val != null) {
              this.push(val);
            }

            if (
              wState.ended ||
              length === rState.length ||
              rState.length < rState.highWaterMark ||
              rState.length === 0) {
              process.nextTick(callback);
            } else {
              this[kCallback] = callback;
            }
          },
          (err) => {
            process.nextTick(callback, err);
          });
      }
    } catch (err) {
      process.nextTick(callback, err);
    }
  }
};

Transform.prototype._read = function() {
  if (this[kCallback]) {
    const callback = this[kCallback];
    this[kCallback] = null;
    callback();
  }
};

âœ„
export const kDestroyed = Symbol('kDestroyed');
export const kIsDisturbed = Symbol('kIsDisturbed');

export function isReadableNodeStream(obj) {
  return !!(
    obj &&
    typeof obj.pipe === 'function' &&
    typeof obj.on === 'function' &&
    (!obj._writableState || obj._readableState?.readable !== false) && // Duplex
    (!obj._writableState || obj._readableState) // Writable has .pipe.
  );
}

export function isWritableNodeStream(obj) {
  return !!(
    obj &&
    typeof obj.write === 'function' &&
    typeof obj.on === 'function' &&
    (!obj._readableState || obj._writableState?.writable !== false) // Duplex
  );
}

export function isDuplexNodeStream(obj) {
  return !!(
    obj &&
    (typeof obj.pipe === 'function' && obj._readableState) &&
    typeof obj.on === 'function' &&
    typeof obj.write === 'function'
  );
}

export function isNodeStream(obj) {
  return (
    obj &&
    (
      obj._readableState ||
      obj._writableState ||
      (typeof obj.write === 'function' && typeof obj.on === 'function') ||
      (typeof obj.pipe === 'function' && typeof obj.on === 'function')
    )
  );
}

export function isIterable(obj, isAsync) {
  if (obj == null) return false;
  if (isAsync === true) return typeof obj[Symbol.asyncIterator] === 'function';
  if (isAsync === false) return typeof obj[Symbol.iterator] === 'function';
  return typeof obj[Symbol.asyncIterator] === 'function' ||
    typeof obj[Symbol.iterator] === 'function';
}

export function isDestroyed(stream) {
  if (!isNodeStream(stream)) return null;
  const wState = stream._writableState;
  const rState = stream._readableState;
  const state = wState || rState;
  return !!(stream.destroyed || stream[kDestroyed] || state?.destroyed);
}

// Have been end():d.
export function isWritableEnded(stream) {
  if (!isWritableNodeStream(stream)) return null;
  if (stream.writableEnded === true) return true;
  const wState = stream._writableState;
  if (wState?.errored) return false;
  if (typeof wState?.ended !== 'boolean') return null;
  return wState.ended;
}

// Have emitted 'finish'.
export function isWritableFinished(stream, strict) {
  if (!isWritableNodeStream(stream)) return null;
  if (stream.writableFinished === true) return true;
  const wState = stream._writableState;
  if (wState?.errored) return false;
  if (typeof wState?.finished !== 'boolean') return null;
  return !!(
    wState.finished ||
    (strict === false && wState.ended === true && wState.length === 0)
  );
}

// Have been push(null):d.
export function isReadableEnded(stream) {
  if (!isReadableNodeStream(stream)) return null;
  if (stream.readableEnded === true) return true;
  const rState = stream._readableState;
  if (!rState || rState.errored) return false;
  if (typeof rState?.ended !== 'boolean') return null;
  return rState.ended;
}

// Have emitted 'end'.
export function isReadableFinished(stream, strict) {
  if (!isReadableNodeStream(stream)) return null;
  const rState = stream._readableState;
  if (rState?.errored) return false;
  if (typeof rState?.endEmitted !== 'boolean') return null;
  return !!(
    rState.endEmitted ||
    (strict === false && rState.ended === true && rState.length === 0)
  );
}

export function isReadable(stream) {
  const r = isReadableNodeStream(stream);
  if (r === null || typeof stream?.readable !== 'boolean') return null;
  if (isDestroyed(stream)) return false;
  return r && stream.readable && !isReadableFinished(stream);
}

export function isWritable(stream) {
  const r = isWritableNodeStream(stream);
  if (r === null || typeof stream?.writable !== 'boolean') return null;
  if (isDestroyed(stream)) return false;
  return r && stream.writable && !isWritableEnded(stream);
}

export function isFinished(stream, opts) {
  if (!isNodeStream(stream)) {
    return null;
  }

  if (isDestroyed(stream)) {
    return true;
  }

  if (opts?.readable !== false && isReadable(stream)) {
    return false;
  }

  if (opts?.writable !== false && isWritable(stream)) {
    return false;
  }

  return true;
}

export function isClosed(stream) {
  if (!isNodeStream(stream)) {
    return null;
  }

  const wState = stream._writableState;
  const rState = stream._readableState;

  if (
    typeof wState?.closed === 'boolean' ||
    typeof rState?.closed === 'boolean'
  ) {
    return wState?.closed || rState?.closed;
  }

  if (typeof stream._closed === 'boolean' && isOutgoingMessage(stream)) {
    return stream._closed;
  }

  return null;
}

function isOutgoingMessage(stream) {
  return (
    typeof stream._closed === 'boolean' &&
    typeof stream._defaultKeepAlive === 'boolean' &&
    typeof stream._removedConnection === 'boolean' &&
    typeof stream._removedContLen === 'boolean'
  );
}

export function isServerResponse(stream) {
  return (
    typeof stream._sent100 === 'boolean' &&
    isOutgoingMessage(stream)
  );
}

export function isServerRequest(stream) {
  return (
    typeof stream._consuming === 'boolean' &&
    typeof stream._dumped === 'boolean' &&
    stream.req?.upgradeOrConnect === undefined
  );
}

export function willEmitClose(stream) {
  if (!isNodeStream(stream)) return null;

  const wState = stream._writableState;
  const rState = stream._readableState;
  const state = wState || rState;

  return (!state && isServerResponse(stream)) || !!(
    state &&
    state.autoDestroy &&
    state.emitClose &&
    state.closed === false
  );
}

export function isDisturbed(stream) {
  return !!(stream && (
    stream.readableDidRead ||
    stream.readableAborted ||
    stream[kIsDisturbed]
  ));
}

âœ„
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

import { addAbortSignal } from './add-abort-signal.js';
import * as destroyImpl from './destroy.js';
import { codes as errorCodes } from '../errors.js';
import { Stream } from './legacy.js';
import {
  getHighWaterMark,
  getDefaultHighWaterMark
} from './state.js';

import { Buffer } from 'buffer';
import EE from 'events';
import process from 'process';

export default Writable;

const {
  ERR_INVALID_ARG_TYPE,
  ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK,
  ERR_STREAM_CANNOT_PIPE,
  ERR_STREAM_DESTROYED,
  ERR_STREAM_ALREADY_FINISHED,
  ERR_STREAM_NULL_VALUES,
  ERR_STREAM_WRITE_AFTER_END,
  ERR_UNKNOWN_ENCODING
} = errorCodes;

const { errorOrDestroy } = destroyImpl;

Object.setPrototypeOf(Writable.prototype, Stream.prototype);
Object.setPrototypeOf(Writable, Stream);

function nop() {}

const kOnFinished = Symbol('kOnFinished');

export function WritableState(options, stream, isDuplex) {
  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
  if (typeof isDuplex !== 'boolean')
    isDuplex = stream instanceof Stream.Duplex;

  // Object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!(options && options.objectMode);

  if (isDuplex)
    this.objectMode = this.objectMode ||
      !!(options && options.writableObjectMode);

  // The point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write().
  this.highWaterMark = options ?
    getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex) :
    getDefaultHighWaterMark(false);

  // if _final has been called.
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // At the start of calling end()
  this.ending = false;
  // When end() has been called, and returned.
  this.ended = false;
  // When 'finish' is emitted.
  this.finished = false;

  // Has it been destroyed
  this.destroyed = false;

  // Should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  const noDecode = !!(options && options.decodeStrings === false);
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8';

  // Not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // A flag to see when we're in the middle of a write.
  this.writing = false;

  // When true all writes will be buffered until .uncork() call.
  this.corked = 0;

  // A flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // A flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // The callback that's passed to _write(chunk, cb).
  this.onwrite = onwrite.bind(undefined, stream);

  // The callback that the user supplies to write(chunk, encoding, cb).
  this.writecb = null;

  // The amount that is being written when _write is called.
  this.writelen = 0;

  // Storage for data passed to the afterWrite() callback in case of
  // synchronous _write() completion.
  this.afterWriteTickInfo = null;

  resetBuffer(this);

  // Number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted.
  this.pendingcb = 0;

  // Stream is still being constructed and cannot be
  // destroyed until construction finished or failed.
  // Async construction is opt in, therefore we start as
  // constructed.
  this.constructed = true;

  // Emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams.
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again.
  this.errorEmitted = false;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = !options || options.emitClose !== false;

  // Should .destroy() be called after 'finish' (and potentially 'end').
  this.autoDestroy = !options || options.autoDestroy !== false;

  // Indicates whether the stream has errored. When true all write() calls
  // should return false. This is needed since when autoDestroy
  // is disabled we need a way to tell whether the stream has failed.
  this.errored = null;

  // Indicates whether the stream has finished destroying.
  this.closed = false;

  // True if close has been emitted or would have been emitted
  // depending on emitClose.
  this.closeEmitted = false;

  this[kOnFinished] = [];
}

function resetBuffer(state) {
  state.buffered = [];
  state.bufferedIndex = 0;
  state.allBuffers = true;
  state.allNoop = true;
}

WritableState.prototype.getBuffer = function getBuffer() {
  return this.buffered.slice(this.bufferedIndex);
};

Object.defineProperty(WritableState.prototype, 'bufferedRequestCount', {
  get() {
    return this.buffered.length - this.bufferedIndex;
  }
});

const realHasInstance = Function.prototype[Symbol.hasInstance];

export function Writable(options) {
  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5.
  const isDuplex = (this instanceof Stream.Duplex);

  if (!isDuplex && !realHasInstance.call(Writable, this))
    return new Writable(options);

  this._writableState = new WritableState(options, this, isDuplex);

  if (options) {
    if (typeof options.write === 'function')
      this._write = options.write;

    if (typeof options.writev === 'function')
      this._writev = options.writev;

    if (typeof options.destroy === 'function')
      this._destroy = options.destroy;

    if (typeof options.final === 'function')
      this._final = options.final;

    if (typeof options.construct === 'function')
      this._construct = options.construct;

    if (options.signal)
      addAbortSignal(options.signal, this);
  }

  Stream.call(this, options);

  destroyImpl.construct(this, () => {
    const state = this._writableState;

    if (!state.writing) {
      clearBuffer(this, state);
    }

    finishMaybe(this, state);
  });
}

Object.defineProperty(Writable, Symbol.hasInstance, {
  value: function(object) {
    if (realHasInstance.call(this, object)) return true;
    if (this !== Writable) return false;

    return object && object._writableState instanceof WritableState;
  },
});

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function _write(stream, chunk, encoding, cb) {
  const state = stream._writableState;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = state.defaultEncoding;
  } else {
    if (!encoding)
      encoding = state.defaultEncoding;
    else if (encoding !== 'buffer' && !Buffer.isEncoding(encoding))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    if (typeof cb !== 'function')
      cb = nop;
  }

  if (chunk === null) {
    throw new ERR_STREAM_NULL_VALUES();
  } else if (!state.objectMode) {
    if (typeof chunk === 'string') {
      if (state.decodeStrings !== false) {
        chunk = Buffer.from(chunk, encoding);
        encoding = 'buffer';
      }
    } else if (chunk instanceof Buffer) {
      encoding = 'buffer';
    } else if (Stream._isUint8Array(chunk)) {
      chunk = Stream._uint8ArrayToBuffer(chunk);
      encoding = 'buffer';
    } else {
      throw new ERR_INVALID_ARG_TYPE(
        'chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
    }
  }

  let err;
  if (state.ending) {
    err = new ERR_STREAM_WRITE_AFTER_END();
  } else if (state.destroyed) {
    err = new ERR_STREAM_DESTROYED('write');
  }

  if (err) {
    process.nextTick(cb, err);
    errorOrDestroy(stream, err, true);
    return err;
  }
  state.pendingcb++;
  return writeOrBuffer(stream, state, chunk, encoding, cb);
}

Writable.prototype.write = function(chunk, encoding, cb) {
  return _write(this, chunk, encoding, cb) === true;
};

Writable.prototype.cork = function() {
  this._writableState.corked++;
};

Writable.prototype.uncork = function() {
  const state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing)
      clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string')
    encoding = encoding.toLowerCase();
  if (!Buffer.isEncoding(encoding))
    throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

// If we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, callback) {
  const len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  // stream._write resets state.length
  const ret = state.length < state.highWaterMark;
  // We must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing || state.corked || state.errored || !state.constructed) {
    state.buffered.push({ chunk, encoding, callback });
    if (state.allBuffers && encoding !== 'buffer') {
      state.allBuffers = false;
    }
    if (state.allNoop && callback !== nop) {
      state.allNoop = false;
    }
  } else {
    state.writelen = len;
    state.writecb = callback;
    state.writing = true;
    state.sync = true;
    stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }

  // Return false if errored or destroyed in order to break
  // any synchronous while(stream.write(data)) loops.
  return ret && !state.errored && !state.destroyed;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed)
    state.onwrite(new ERR_STREAM_DESTROYED('write'));
  else if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, er, cb) {
  --state.pendingcb;

  cb(er);
  // Ensure callbacks are invoked even when autoDestroy is
  // not enabled. Passing `er` here doesn't make sense since
  // it's related to one specific write, not to the buffered
  // writes.
  errorBuffer(state);
  // This can emit error, but error must always follow cb.
  errorOrDestroy(stream, er);
}

function onwrite(stream, er) {
  const state = stream._writableState;
  const sync = state.sync;
  const cb = state.writecb;

  if (typeof cb !== 'function') {
    errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
    return;
  }

  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;

  if (er) {
    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364
    er.stack; // eslint-disable-line no-unused-expressions

    if (!state.errored) {
      state.errored = er;
    }

    // In case of duplex streams we need to notify the readable side of the
    // error.
    if (stream._readableState && !stream._readableState.errored) {
      stream._readableState.errored = er;
    }

    if (sync) {
      process.nextTick(onwriteError, stream, state, er, cb);
    } else {
      onwriteError(stream, state, er, cb);
    }
  } else {
    if (state.buffered.length > state.bufferedIndex) {
      clearBuffer(stream, state);
    }

    if (sync) {
      // It is a common case that the callback passed to .write() is always
      // the same. In that case, we do not schedule a new nextTick(), but
      // rather just increase a counter, to improve performance and avoid
      // memory allocations.
      if (state.afterWriteTickInfo !== null &&
          state.afterWriteTickInfo.cb === cb) {
        state.afterWriteTickInfo.count++;
      } else {
        state.afterWriteTickInfo = { count: 1, cb, stream, state };
        process.nextTick(afterWriteTick, state.afterWriteTickInfo);
      }
    } else {
      afterWrite(stream, state, 1, cb);
    }
  }
}

function afterWriteTick({ stream, state, count, cb }) {
  state.afterWriteTickInfo = null;
  return afterWrite(stream, state, count, cb);
}

function afterWrite(stream, state, count, cb) {
  const needDrain = !state.ending && !stream.destroyed && state.length === 0 &&
    state.needDrain;
  if (needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }

  while (count-- > 0) {
    state.pendingcb--;
    cb();
  }

  if (state.destroyed) {
    errorBuffer(state);
  }

  finishMaybe(stream, state);
}

// If there's something in the buffer waiting, then invoke callbacks.
function errorBuffer(state) {
  if (state.writing) {
    return;
  }

  for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
    const { chunk, callback } = state.buffered[n];
    const len = state.objectMode ? 1 : chunk.length;
    state.length -= len;
    callback(state.errored ?? new ERR_STREAM_DESTROYED('write'));
  }

  const onfinishCallbacks = state[kOnFinished].splice(0);
  for (let i = 0; i < onfinishCallbacks.length; i++) {
    onfinishCallbacks[i](state.errored ?? new ERR_STREAM_DESTROYED('end'));
  }

  resetBuffer(state);
}

// If there's something in the buffer waiting, then process it.
function clearBuffer(stream, state) {
  if (state.corked ||
      state.bufferProcessing ||
      state.destroyed ||
      !state.constructed) {
    return;
  }

  const { buffered, bufferedIndex, objectMode } = state;
  const bufferedLength = buffered.length - bufferedIndex;

  if (!bufferedLength) {
    return;
  }

  let i = bufferedIndex;

  state.bufferProcessing = true;
  if (bufferedLength > 1 && stream._writev) {
    state.pendingcb -= bufferedLength - 1;

    const callback = state.allNoop ? nop : (err) => {
      for (let n = i; n < buffered.length; ++n) {
        buffered[n].callback(err);
      }
    };
    // Make a copy of `buffered` if it's going to be used by `callback` above,
    // since `doWrite` will mutate the array.
    const chunks = state.allNoop && i === 0 ? buffered : buffered.slice(i);
    chunks.allBuffers = state.allBuffers;

    doWrite(stream, state, true, state.length, chunks, '', callback);

    resetBuffer(state);
  } else {
    do {
      const { chunk, encoding, callback } = buffered[i];
      buffered[i++] = null;
      const len = objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, callback);
    } while (i < buffered.length && !state.writing);

    if (i === buffered.length) {
      resetBuffer(state);
    } else if (i > 256) {
      buffered.splice(0, i);
      state.bufferedIndex = 0;
    } else {
      state.bufferedIndex = i;
    }
  }
  state.bufferProcessing = false;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  if (this._writev) {
    this._writev([{ chunk, encoding }], cb);
  } else {
    throw new ERR_METHOD_NOT_IMPLEMENTED('_write()');
  }
};

Writable.prototype._writev = null;

Writable.prototype.end = function(chunk, encoding, cb) {
  const state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  let err;

  if (chunk !== null && chunk !== undefined) {
    const ret = _write(this, chunk, encoding);
    if (ret instanceof Error) {
      err = ret;
    }
  }

  // .end() fully uncorks.
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  if (err) {
    // Do nothing...
  } else if (!state.errored && !state.ending) {
    // This is forgiving in terms of unnecessary calls to end() and can hide
    // logic errors. However, usually such errors are harmless and causing a
    // hard error can be disproportionately destructive. It is not always
    // trivial for the user to determine whether end() needs to be called
    // or not.

    state.ending = true;
    finishMaybe(this, state, true);
    state.ended = true;
  } else if (state.finished) {
    err = new ERR_STREAM_ALREADY_FINISHED('end');
  } else if (state.destroyed) {
    err = new ERR_STREAM_DESTROYED('end');
  }

  if (typeof cb === 'function') {
    if (err || state.finished) {
      process.nextTick(cb, err);
    } else {
      state[kOnFinished].push(cb);
    }
  }

  return this;
};

function needFinish(state) {
  return (state.ending &&
          state.constructed &&
          state.length === 0 &&
          !state.errored &&
          state.buffered.length === 0 &&
          !state.finished &&
          !state.writing &&
          !state.errorEmitted &&
          !state.closeEmitted);
}

function callFinal(stream, state) {
  let called = false;

  function onFinish(err) {
    if (called) {
      errorOrDestroy(stream, err ?? ERR_MULTIPLE_CALLBACK());
      return;
    }
    called = true;

    state.pendingcb--;
    if (err) {
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i](err);
      }
      errorOrDestroy(stream, err, state.sync);
    } else if (needFinish(state)) {
      state.prefinished = true;
      stream.emit('prefinish');
      // Backwards compat. Don't check state.sync here.
      // Some streams assume 'finish' will be emitted
      // asynchronously relative to _final callback.
      state.pendingcb++;
      process.nextTick(finish, stream, state);
    }
  }

  state.sync = true;
  state.pendingcb++;

  try {
    const result = stream._final(onFinish);
    if (result != null) {
      const then = result.then;
      if (typeof then === 'function') {
        then.call(
          result,
          function() {
            process.nextTick(onFinish, null);
          },
          function(err) {
            process.nextTick(onFinish, err);
          });
      }
    }
  } catch (err) {
    onFinish(stream, state, err);
  }

  state.sync = false;
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.finalCalled = true;
      callFinal(stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state, sync) {
  if (needFinish(state)) {
    prefinish(stream, state);
    if (state.pendingcb === 0 && needFinish(state)) {
      state.pendingcb++;
      if (sync) {
        process.nextTick(finish, stream, state);
      } else {
        finish(stream, state);
      }
    }
  }
}

function finish(stream, state) {
  state.pendingcb--;
  state.finished = true;

  const onfinishCallbacks = state[kOnFinished].splice(0);
  for (let i = 0; i < onfinishCallbacks.length; i++) {
    onfinishCallbacks[i]();
  }

  stream.emit('finish');

  if (state.autoDestroy) {
    // In case of duplex streams we need a way to detect
    // if the readable side is ready for autoDestroy as well.
    const rState = stream._readableState;
    const autoDestroy = !rState || (
      rState.autoDestroy &&
      // We don't expect the readable to ever 'end'
      // if readable is explicitly set to false.
      (rState.endEmitted || rState.readable === false)
    );
    if (autoDestroy) {
      stream.destroy();
    }
  }
}

Object.defineProperties(Writable.prototype, {

  destroyed: {
    get() {
      return this._writableState ? this._writableState.destroyed : false;
    },
    set(value) {
      // Backward compatibility, the user is explicitly managing destroyed.
      if (this._writableState) {
        this._writableState.destroyed = value;
      }
    }
  },

  writable: {
    get() {
      const w = this._writableState;
      // w.writable === false means that this is part of a Duplex stream
      // where the writable side was disabled upon construction.
      // Compat. The user might manually disable writable side through
      // deprecated setter.
      return !!w && w.writable !== false && !w.destroyed && !w.errored &&
        !w.ending && !w.ended;
    },
    set(val) {
      // Backwards compatible.
      if (this._writableState) {
        this._writableState.writable = !!val;
      }
    }
  },

  writableFinished: {
    get() {
      return this._writableState ? this._writableState.finished : false;
    }
  },

  writableObjectMode: {
    get() {
      return this._writableState ? this._writableState.objectMode : false;
    }
  },

  writableBuffer: {
    get() {
      return this._writableState && this._writableState.getBuffer();
    }
  },

  writableEnded: {
    get() {
      return this._writableState ? this._writableState.ending : false;
    }
  },

  writableNeedDrain: {
    get() {
      const wState = this._writableState;
      if (!wState) return false;
      return !wState.destroyed && !wState.ending && wState.needDrain;
    }
  },

  writableHighWaterMark: {
    get() {
      return this._writableState && this._writableState.highWaterMark;
    }
  },

  writableCorked: {
    get() {
      return this._writableState ? this._writableState.corked : 0;
    }
  },

  writableLength: {
    get() {
      return this._writableState && this._writableState.length;
    }
  }
});

const destroy = destroyImpl.destroy;
Writable.prototype.destroy = function(err, cb) {
  const state = this._writableState;

  // Invoke pending callbacks.
  if (!state.destroyed &&
    (state.bufferedIndex < state.buffered.length ||
      state[kOnFinished].length)) {
    process.nextTick(errorBuffer, state);
  }

  destroy.call(this, err, cb);
  return this;
};

Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function(err, cb) {
  cb(err);
};

Writable.prototype[EE.captureRejectionSymbol] = function(err) {
  this.destroy(err);
};

âœ„
import { addAbortSignal } from './lib/add-abort-signal.js';
import compose from './lib/compose.js';
import { destroyer } from './lib/destroy.js';
import Duplex from './lib/duplex.js';
import eos from './lib/end-of-stream.js';
import { Stream as LegacyStream } from './lib/legacy.js';
import PassThrough from './lib/passthrough.js';
import pipeline from './lib/pipeline.js';
import * as promises from './lib/promises.js';
import Readable from './lib/readable.js';
import Transform from './lib/transform.js';
import { isDisturbed } from './lib/utils.js';
import Writable from './lib/writable.js';

import { Buffer } from 'buffer';
import { promisify, types } from 'util';

export default Readable;
export {
  isDisturbed,
  Readable as Stream,
  LegacyStream,
  Readable,
  Writable,
  Duplex,
  Transform,
  PassThrough,
  pipeline,
  addAbortSignal,
  eos as finished,
  destroyer as destroy,
  compose,
  promises,
};

LegacyStream.isDisturbed = isDisturbed;
LegacyStream.Readable = Readable;
LegacyStream.Writable = Writable;
LegacyStream.Duplex = Duplex;
LegacyStream.Transform = Transform;
LegacyStream.PassThrough = PassThrough;
LegacyStream.pipeline = pipeline;
LegacyStream.addAbortSignal = addAbortSignal;
LegacyStream.finished = eos;
LegacyStream.destroy = destroyer;
LegacyStream.compose = compose;

Object.defineProperty(LegacyStream, 'promises', {
  configurable: true,
  enumerable: true,
  get() {
    return promises;
  }
});

Object.defineProperty(pipeline, promisify.custom, {
  enumerable: true,
  get() {
    return promises.pipeline;
  }
});

Object.defineProperty(eos, promisify.custom, {
  enumerable: true,
  get() {
    return promises.finished;
  }
});

// Backwards-compat with node 0.4.x
LegacyStream.Stream = LegacyStream;

LegacyStream._isUint8Array = types.isUint8Array;
LegacyStream._uint8ArrayToBuffer = Buffer.from;

âœ„
import {
  isDisturbed,
  LegacyStream,
  Readable,
  Writable,
  Duplex,
  Transform,
  PassThrough,
  pipeline,
  addAbortSignal,
  finished,
  destroy,
  compose,
  promises,
} from '@frida/readable-stream';

export default LegacyStream;
export {
  isDisturbed,
  LegacyStream as Stream,
  Readable,
  Writable,
  Duplex,
  Transform,
  PassThrough,
  pipeline,
  addAbortSignal,
  finished,
  destroy,
  compose,
  promises,
};

âœ„
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

import { Buffer } from 'buffer';

export default { StringDecoder };

const isEncoding = Buffer.isEncoding;

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  let retried = false;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  const nenc = _normalizeEncoding(enc);
  if (nenc === undefined && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
export function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  let nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  let r;
  let i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  let j = buf.length - 1;
  if (j < i) return 0;
  let nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  const p = this.lastTotal - this.lastNeed;
  const r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  const total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  const end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  const r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    const r = buf.toString('utf16le', i);
    if (r) {
      const c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  const r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    const end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  const n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  const r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

âœ„
// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9

const ObjectToString = uncurryThis(Object.prototype.toString);

const numberValue = uncurryThis(Number.prototype.valueOf);
const stringValue = uncurryThis(String.prototype.valueOf);
const booleanValue = uncurryThis(Boolean.prototype.valueOf);

const bigIntValue = uncurryThis(BigInt.prototype.valueOf);

const symbolValue = uncurryThis(Symbol.prototype.valueOf);

const generatorPrototype = Object.getPrototypeOf(function* () {});
const typedArrayPrototype = Object.getPrototypeOf(Int8Array);

export function isArgumentsObject(value) {
  if (value !== null && typeof value === 'object' && Symbol.toStringTag in value) {
    return false;
  }
  return ObjectToString(value) === '[object Arguments]';
}

export function isGeneratorFunction(value) {
  return Object.getPrototypeOf(value) === generatorPrototype;
}

export function isTypedArray(value) {
  return value instanceof typedArrayPrototype;
}

export function isPromise(input) {
  return input instanceof Promise;
}

export function isArrayBufferView(value) {
  return ArrayBuffer.isView(value);
}

export function isUint8Array(value) {
  return value instanceof Uint8Array;
}

export function isUint8ClampedArray(value) {
  return value instanceof Uint8ClampedArray;
}

export function isUint16Array(value) {
  return value instanceof Uint16Array;
}

export function isUint32Array(value) {
  return value instanceof Uint32Array;
}

export function isInt8Array(value) {
  return value instanceof Int8Array;
}

export function isInt16Array(value) {
  return value instanceof Int16Array;
}

export function isInt32Array(value) {
  return value instanceof Int32Array;
}

export function isFloat32Array(value) {
  return value instanceof Float32Array;
}

export function isFloat64Array(value) {
  return value instanceof Float64Array;
}

export function isBigInt64Array(value) {
  return value instanceof BigInt64Array;
}

export function isBigUint64Array(value) {
  return value instanceof BigUint64Array;
}

export function isMap(value) {
  return ObjectToString(value) === '[object Map]';
}

export function isSet(value) {
  return ObjectToString(value) === '[object Set]';
}

export function isWeakMap(value) {
  return ObjectToString(value) === '[object WeakMap]';
}

export function isWeakSet(value) {
  return ObjectToString(value) === '[object WeakSet]';
}

export function isArrayBuffer(value) {
  return ObjectToString(value) === '[object ArrayBuffer]';
}

export function isDataView(value) {
  return ObjectToString(value) === '[object DataView]';
}

export function isSharedArrayBuffer(value) {
  return ObjectToString(value) === '[object SharedArrayBuffer]';
}

export function isAsyncFunction(value) {
  return ObjectToString(value) === '[object AsyncFunction]';
}

export function isMapIterator(value) {
  return ObjectToString(value) === '[object Map Iterator]';
}

export function isSetIterator(value) {
  return ObjectToString(value) === '[object Set Iterator]';
}

export function isGeneratorObject(value) {
  return ObjectToString(value) === '[object Generator]';
}

export function isWebAssemblyCompiledModule(value) {
  return ObjectToString(value) === '[object WebAssembly.Module]';
}

export function isNumberObject(value) {
  return checkBoxedPrimitive(value, numberValue);
}

export function isStringObject(value) {
  return checkBoxedPrimitive(value, stringValue);
}

export function isBooleanObject(value) {
  return checkBoxedPrimitive(value, booleanValue);
}

export function isBigIntObject(value) {
  return checkBoxedPrimitive(value, bigIntValue);
}

export function isSymbolObject(value) {
  return checkBoxedPrimitive(value, symbolValue);
}

function checkBoxedPrimitive(value, prototypeValueOf) {
  if (typeof value !== 'object') {
    return false;
  }
  try {
    prototypeValueOf(value);
    return true;
  } catch(e) {
    return false;
  }
}

export function isBoxedPrimitive(value) {
  return (
    isNumberObject(value) ||
    isStringObject(value) ||
    isBooleanObject(value) ||
    isBigIntObject(value) ||
    isSymbolObject(value)
  );
}

export function isAnyArrayBuffer(value) {
  return isArrayBuffer(value) || isSharedArrayBuffer(value);
}

export function isProxy(value) {
  throwNotSupported('isProxy');
}

export function isExternal(value) {
  throwNotSupported('isExternal');
}

export function isModuleNamespaceObject(value) {
  throwNotSupported('isModuleNamespaceObject');
}

function throwNotSupported(method) {
  throw new Error(`${method} is not supported in userland`);
}

function uncurryThis(f) {
  return f.call.bind(f);
}

âœ„
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

import * as _types from './support/types.js';

import process from 'process';

export const types = {
  ..._types,
  isRegExp,
  isDate,
  isNativeError: isError,
};

export default {
  format,
  deprecate,
  debuglog,
  inspect,
  types,
  isArray,
  isBoolean,
  isNull,
  isNullOrUndefined,
  isNumber,
  isString,
  isSymbol,
  isUndefined,
  isRegExp,
  isObject,
  isDate,
  isError,
  isFunction,
  isPrimitive,
  isBuffer,
  log,
  inherits,
  _extend,
  promisify,
  callbackify,
};

const formatRegExp = /%[sdj%]/g;

export function format(f) {
  if (!isString(f)) {
    const objects = [];
    for (let i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  let i = 1;
  const args = arguments;
  const len = args.length;
  let str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (let x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
}


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
export function deprecate(fn, msg) {
  if (process.noDeprecation === true) {
    return fn;
  }

  let warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}


const debugs = {};
let debugEnvRegex = /^$/;

if (process.env.NODE_DEBUG) {
  let debugEnv = process.env.NODE_DEBUG;
  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/,/g, '$|^')
    .toUpperCase();
  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}

export function debuglog(set) {
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (debugEnvRegex.test(set)) {
      const pid = process.pid;
      debugs[set] = function() {
        const msg = format.apply(null, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
}


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
export function inspect(obj, opts) {
  // default options
  const ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    _extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
inspect.custom = Symbol.for('nodejs.util.inspect.custom');


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  const style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  const hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    let ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  const primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  let keys = Object.keys(value);
  const visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      const name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  let base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    const n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  let output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    const simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  const output = [];
  for (let i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  let name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  let numLinesEst = 0;
  const length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

export function isArray(ar) {
  return Array.isArray(ar);
}

export function isBoolean(arg) {
  return typeof arg === 'boolean';
}

export function isNull(arg) {
  return arg === null;
}

export function isNullOrUndefined(arg) {
  return arg == null;
}

export function isNumber(arg) {
  return typeof arg === 'number';
}

export function isString(arg) {
  return typeof arg === 'string';
}

export function isSymbol(arg) {
  return typeof arg === 'symbol';
}

export function isUndefined(arg) {
  return arg === void 0;
}

export function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}

export function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

export function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}

export function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}

export function isFunction(arg) {
  return typeof arg === 'function';
}

export function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}

export function isBuffer(arg) {
  return arg instanceof Buffer;
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
                'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  const d = new Date();
  const time = [pad(d.getHours()),
                pad(d.getMinutes()),
                pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
export function log() {
  console.log('%s - %s', timestamp(), format.apply(null, arguments));
}


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
export function inherits(ctor, superCtor) {
  Object.defineProperty(ctor, 'super_', {
    value: superCtor,
    writable: true,
    configurable: true
  });
  Object.setPrototypeOf(ctor.prototype, superCtor.prototype);
}

export function _extend(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  const keys = Object.keys(add);
  let i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
}

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

const kCustomPromisifiedSymbol = Symbol('util.promisify.custom');

export function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    const fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    let promiseResolve, promiseReject;
    const promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    const args = [];
    for (let i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    Object.getOwnPropertyDescriptors(original)
  );
}

promisify.custom = kCustomPromisifiedSymbol;

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    const newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

export function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    const args = [];
    for (let i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    const maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    const self = this;
    const cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },
            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          Object.getOwnPropertyDescriptors(original));
  return callbackified;
}

âœ„
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ReadStream_input, _ReadStream_readRequest, _WriteStream_output, _WriteStream_writeRequest;
import { Buffer } from "buffer";
import fsPath from "path";
import process from "process";
import stream from "stream";
const getWindowsApi = memoize(_getWindowsApi);
const getPosixApi = memoize(_getPosixApi);
const platform = Process.platform;
const pointerSize = Process.pointerSize;
const isWindows = platform === "windows";
const S_IFMT = 0xf000;
const S_IFREG = 0x8000;
const S_IFDIR = 0x4000;
const S_IFCHR = 0x2000;
const S_IFBLK = 0x6000;
const S_IFIFO = 0x1000;
const S_IFLNK = 0xa000;
const S_IFSOCK = 0xc000;
const universalConstants = {
    S_IFMT,
    S_IFREG,
    S_IFDIR,
    S_IFCHR,
    S_IFBLK,
    S_IFIFO,
    S_IFLNK,
    S_IFSOCK,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    DT_UNKNOWN: 0,
    DT_FIFO: 1,
    DT_CHR: 2,
    DT_DIR: 4,
    DT_BLK: 6,
    DT_REG: 8,
    DT_LNK: 10,
    DT_SOCK: 12,
    DT_WHT: 14,
};
const platformConstants = {
    darwin: {
        O_RDONLY: 0x0,
        O_WRONLY: 0x1,
        O_RDWR: 0x2,
        O_CREAT: 0x200,
        O_EXCL: 0x800,
        O_NOCTTY: 0x20000,
        O_TRUNC: 0x400,
        O_APPEND: 0x8,
        O_DIRECTORY: 0x100000,
        O_NOFOLLOW: 0x100,
        O_SYNC: 0x80,
        O_DSYNC: 0x400000,
        O_SYMLINK: 0x200000,
        O_NONBLOCK: 0x4,
    },
    linux: {
        O_RDONLY: 0x0,
        O_WRONLY: 0x1,
        O_RDWR: 0x2,
        O_CREAT: 0x40,
        O_EXCL: 0x80,
        O_NOCTTY: 0x100,
        O_TRUNC: 0x200,
        O_APPEND: 0x400,
        O_DIRECTORY: 0x10000,
        O_NOATIME: 0x40000,
        O_NOFOLLOW: 0x20000,
        O_SYNC: 0x101000,
        O_DSYNC: 0x1000,
        O_DIRECT: 0x4000,
        O_NONBLOCK: 0x800,
    },
};
const constants = {
    ...universalConstants,
    ...platformConstants[platform]
};
const INVALID_HANDLE_VALUE = -1;
const GENERIC_READ = 0x80000000;
const GENERIC_WRITE = 0x40000000;
const FILE_SHARE_READ = 0x1;
const FILE_SHARE_WRITE = 0x2;
const FILE_SHARE_DELETE = 0x4;
const CREATE_ALWAYS = 2;
const OPEN_EXISTING = 3;
const FILE_ATTRIBUTE_NORMAL = 0x80;
const FILE_ATTRIBUTE_DIRECTORY = 0x10;
const FILE_ATTRIBUTE_REPARSE_POINT = 0x400;
const IO_REPARSE_TAG_MOUNT_POINT = 0xa0000003;
const IO_REPARSE_TAG_SYMLINK = 0xa000000c;
const FILE_FLAG_OVERLAPPED = 0x40000000;
const FILE_FLAG_BACKUP_SEMANTICS = 0x2000000;
const ERROR_NOT_ENOUGH_MEMORY = 8;
const ERROR_SHARING_VIOLATION = 32;
const SEEK_SET = 0;
const SEEK_CUR = 1;
const SEEK_END = 2;
const EINTR = 4;
class ReadStream extends stream.Readable {
    constructor(path) {
        super({
            highWaterMark: 4 * 1024 * 1024
        });
        _ReadStream_input.set(this, null);
        _ReadStream_readRequest.set(this, null);
        if (isWindows) {
            const api = getWindowsApi();
            const result = api.CreateFileW(Memory.allocUtf16String(path), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
            const handle = result.value;
            if (handle.equals(INVALID_HANDLE_VALUE)) {
                process.nextTick(() => {
                    this.destroy(makeWindowsError(result.lastError));
                });
                return;
            }
            __classPrivateFieldSet(this, _ReadStream_input, new Win32InputStream(handle, { autoClose: true }), "f");
        }
        else {
            const api = getPosixApi();
            const result = api.open(Memory.allocUtf8String(path), constants.O_RDONLY, 0);
            const fd = result.value;
            if (fd === -1) {
                process.nextTick(() => {
                    this.destroy(makePosixError(result.errno));
                });
                return;
            }
            __classPrivateFieldSet(this, _ReadStream_input, new UnixInputStream(fd, { autoClose: true }), "f");
        }
    }
    _destroy(error, callback) {
        __classPrivateFieldGet(this, _ReadStream_input, "f")?.close();
        __classPrivateFieldSet(this, _ReadStream_input, null, "f");
        callback(error);
    }
    _read(size) {
        if (__classPrivateFieldGet(this, _ReadStream_readRequest, "f") !== null)
            return;
        __classPrivateFieldSet(this, _ReadStream_readRequest, __classPrivateFieldGet(this, _ReadStream_input, "f").read(size)
            .then(buffer => {
            __classPrivateFieldSet(this, _ReadStream_readRequest, null, "f");
            if (buffer.byteLength === 0) {
                this.push(null);
                return;
            }
            if (this.push(Buffer.from(buffer)))
                this._read(size);
        })
            .catch(error => {
            __classPrivateFieldSet(this, _ReadStream_readRequest, null, "f");
            this.destroy(error);
        }), "f");
    }
}
_ReadStream_input = new WeakMap(), _ReadStream_readRequest = new WeakMap();
class WriteStream extends stream.Writable {
    constructor(path) {
        super({
            highWaterMark: 4 * 1024 * 1024
        });
        _WriteStream_output.set(this, null);
        _WriteStream_writeRequest.set(this, null);
        if (isWindows) {
            const api = getWindowsApi();
            const result = api.CreateFileW(Memory.allocUtf16String(path), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
            const handle = result.value;
            if (handle.equals(INVALID_HANDLE_VALUE)) {
                process.nextTick(() => {
                    this.destroy(makeWindowsError(result.lastError));
                });
                return;
            }
            __classPrivateFieldSet(this, _WriteStream_output, new Win32OutputStream(handle, { autoClose: true }), "f");
        }
        else {
            const api = getPosixApi();
            const pathStr = Memory.allocUtf8String(path);
            const flags = constants.O_WRONLY | constants.O_CREAT | constants.O_TRUNC;
            const mode = constants.S_IRUSR | constants.S_IWUSR | constants.S_IRGRP | constants.S_IROTH;
            const result = api.open(pathStr, flags, mode);
            const fd = result.value;
            if (fd === -1) {
                process.nextTick(() => {
                    this.destroy(makePosixError(result.errno));
                });
                return;
            }
            __classPrivateFieldSet(this, _WriteStream_output, new UnixOutputStream(fd, { autoClose: true }), "f");
        }
    }
    _destroy(error, callback) {
        __classPrivateFieldGet(this, _WriteStream_output, "f")?.close();
        __classPrivateFieldSet(this, _WriteStream_output, null, "f");
        callback(error);
    }
    _write(chunk, encoding, callback) {
        if (__classPrivateFieldGet(this, _WriteStream_writeRequest, "f") !== null)
            return;
        __classPrivateFieldSet(this, _WriteStream_writeRequest, __classPrivateFieldGet(this, _WriteStream_output, "f").writeAll(chunk)
            .then(size => {
            __classPrivateFieldSet(this, _WriteStream_writeRequest, null, "f");
            callback();
        })
            .catch(error => {
            __classPrivateFieldSet(this, _WriteStream_writeRequest, null, "f");
            callback(error);
        }), "f");
    }
}
_WriteStream_output = new WeakMap(), _WriteStream_writeRequest = new WeakMap();
const windowsBackend = {
    enumerateDirectoryEntries(path, callback) {
        enumerateWindowsDirectoryEntriesMatching(path + "\\*", callback);
    },
    readFileSync(path, options = {}) {
        if (typeof options === "string")
            options = { encoding: options };
        const { encoding = null } = options;
        const { CreateFileW, GetFileSizeEx, ReadFile, CloseHandle } = getWindowsApi();
        const createRes = CreateFileW(Memory.allocUtf16String(path), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        const handle = createRes.value;
        if (handle.equals(INVALID_HANDLE_VALUE))
            throwWindowsError(createRes.lastError);
        try {
            const scratchBuf = Memory.alloc(8);
            const fileSizeBuf = scratchBuf;
            const getRes = GetFileSizeEx(handle, fileSizeBuf);
            if (getRes.value === 0)
                throwWindowsError(getRes.lastError);
            const fileSize = fileSizeBuf.readU64().valueOf();
            const buf = Memory.alloc(fileSize);
            const numBytesReadBuf = scratchBuf;
            const readRes = ReadFile(handle, buf, fileSize, numBytesReadBuf, NULL);
            if (readRes.value === 0)
                throwWindowsError(readRes.lastError);
            const n = numBytesReadBuf.readU32();
            if (n !== fileSize)
                throw new Error("Short read");
            return parseReadFileResult(buf, fileSize, encoding);
        }
        finally {
            CloseHandle(handle);
        }
    },
    readlinkSync(path) {
        const { CreateFileW, GetFinalPathNameByHandleW, CloseHandle } = getWindowsApi();
        const createRes = CreateFileW(Memory.allocUtf16String(path), 0, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
        const handle = createRes.value;
        if (handle.equals(INVALID_HANDLE_VALUE))
            throwWindowsError(createRes.lastError);
        try {
            let maxLength = 256;
            while (true) {
                const buf = Memory.alloc(maxLength * 2);
                const { value, lastError } = GetFinalPathNameByHandleW(handle, buf, maxLength, 0);
                if (value === 0)
                    throwWindowsError(lastError);
                if (lastError === ERROR_NOT_ENOUGH_MEMORY) {
                    maxLength *= 2;
                    continue;
                }
                return buf.readUtf16String().substring(4);
            }
        }
        finally {
            CloseHandle(handle);
        }
    },
    rmdirSync(path) {
        const result = getWindowsApi().RemoveDirectoryW(Memory.allocUtf16String(path));
        if (result.value === 0)
            throwWindowsError(result.lastError);
    },
    unlinkSync(path) {
        const result = getWindowsApi().DeleteFileW(Memory.allocUtf16String(path));
        if (result.value === 0)
            throwWindowsError(result.lastError);
    },
    statSync(path) {
        const s = windowsBackend.lstatSync(path);
        if (!s.isSymbolicLink())
            return s;
        const target = windowsBackend.readlinkSync(path);
        return windowsBackend.lstatSync(target);
    },
    lstatSync(path) {
        const getFileExInfoStandard = 0;
        const buf = Memory.alloc(36);
        const result = getWindowsApi().GetFileAttributesExW(Memory.allocUtf16String(path), getFileExInfoStandard, buf);
        if (result.value === 0) {
            if (result.lastError === ERROR_SHARING_VIOLATION) {
                let fileAttrData;
                enumerateWindowsDirectoryEntriesMatching(path, data => {
                    // WIN32_FIND_DATAW starts with the exact same fields as WIN32_FILE_ATTRIBUTE_DATA
                    fileAttrData = Memory.dup(data, 36);
                });
                return makeStatsProxy(path, fileAttrData);
            }
            throwWindowsError(result.lastError);
        }
        return makeStatsProxy(path, buf);
    },
};
function enumerateWindowsDirectoryEntriesMatching(filename, callback) {
    const { FindFirstFileW, FindNextFileW, FindClose } = getWindowsApi();
    const data = Memory.alloc(592);
    const result = FindFirstFileW(Memory.allocUtf16String(filename), data);
    const handle = result.value;
    if (handle.equals(INVALID_HANDLE_VALUE))
        throwWindowsError(result.lastError);
    try {
        do {
            callback(data);
        } while (FindNextFileW(handle, data) !== 0);
    }
    finally {
        FindClose(handle);
    }
}
const posixBackend = {
    enumerateDirectoryEntries(path, callback) {
        const { opendir, opendir$INODE64, closedir, readdir, readdir$INODE64 } = getPosixApi();
        const opendirImpl = opendir$INODE64 || opendir;
        const readdirImpl = readdir$INODE64 || readdir;
        const dir = opendirImpl(Memory.allocUtf8String(path));
        const dirHandle = dir.value;
        if (dirHandle.isNull())
            throwPosixError(dir.errno);
        try {
            let entry;
            while (!((entry = readdirImpl(dirHandle)).isNull())) {
                callback(entry);
            }
        }
        finally {
            closedir(dirHandle);
        }
    },
    readFileSync(path, options = {}) {
        if (typeof options === "string")
            options = { encoding: options };
        const { encoding = null } = options;
        const { open, close, lseek, read } = getPosixApi();
        const openResult = open(Memory.allocUtf8String(path), constants.O_RDONLY, 0);
        const fd = openResult.value;
        if (fd === -1)
            throwPosixError(openResult.errno);
        try {
            const fileSize = lseek(fd, 0, SEEK_END).valueOf();
            lseek(fd, 0, SEEK_SET);
            const buf = Memory.alloc(fileSize);
            let readResult, n, readFailed;
            do {
                readResult = read(fd, buf, fileSize);
                n = readResult.value.valueOf();
                readFailed = n === -1;
            } while (readFailed && readResult.errno === EINTR);
            if (readFailed)
                throwPosixError(readResult.errno);
            if (n !== fileSize.valueOf())
                throw new Error("Short read");
            return parseReadFileResult(buf, fileSize, encoding);
        }
        finally {
            close(fd);
        }
    },
    readlinkSync(path) {
        const pathStr = Memory.allocUtf8String(path);
        const linkSize = posixBackend.lstatSync(path).size.valueOf();
        const buf = Memory.alloc(linkSize);
        const result = getPosixApi().readlink(pathStr, buf, linkSize);
        const n = result.value.valueOf();
        if (n === -1)
            throwPosixError(result.errno);
        return buf.readUtf8String(n);
    },
    rmdirSync(path) {
        const result = getPosixApi().rmdir(Memory.allocUtf8String(path));
        if (result.value === -1)
            throwPosixError(result.errno);
    },
    unlinkSync(path) {
        const result = getPosixApi().unlink(Memory.allocUtf8String(path));
        if (result.value === -1)
            throwPosixError(result.errno);
    },
    statSync(path) {
        return performStatPosix(getStatSpec()._stat, path);
    },
    lstatSync(path) {
        return performStatPosix(getStatSpec()._lstat, path);
    },
};
function writeFileSync(path, data, options = {}) {
    if (typeof options === "string")
        options = { encoding: options };
    const { encoding = null } = options;
    let rawData;
    if (typeof data === "string") {
        if (encoding !== null && !encodingIsUtf8(encoding))
            rawData = Buffer.from(data, encoding).buffer;
        else
            rawData = data;
    }
    else {
        rawData = data.buffer;
    }
    const file = new File(path, "wb");
    try {
        file.write(rawData);
    }
    finally {
        file.close();
    }
}
function performStatPosix(impl, path) {
    const buf = Memory.alloc(statBufSize);
    const result = impl(Memory.allocUtf8String(path), buf);
    if (result.value !== 0)
        throwPosixError(result.errno);
    return makeStatsProxy(path, buf);
}
function parseReadFileResult(buf, fileSize, encoding) {
    if (encodingIsUtf8(encoding))
        return buf.readUtf8String(fileSize);
    const value = Buffer.from(buf.readByteArray(fileSize));
    if (encoding !== null)
        return value.toString(encoding);
    return value;
}
function encodingIsUtf8(encoding) {
    return encoding === "utf8" || encoding === "utf-8";
}
const backend = isWindows ? windowsBackend : posixBackend;
const { enumerateDirectoryEntries, readFileSync, readlinkSync, rmdirSync, unlinkSync, statSync, lstatSync, } = backend;
const direntSpecs = {
    "windows": {
        "d_name": [44, "Utf16String"],
        "d_type": [0, readWindowsFileAttributes],
        "atime": [12, readWindowsFileTime],
        "mtime": [20, readWindowsFileTime],
        "ctime": [4, readWindowsFileTime],
        "size": [28, readWindowsFileSize],
    },
    "linux-32": {
        "d_name": [11, "Utf8String"],
        "d_type": [10, "U8"]
    },
    "linux-64": {
        "d_name": [19, "Utf8String"],
        "d_type": [18, "U8"]
    },
    "darwin-32": {
        "d_name": [21, "Utf8String"],
        "d_type": [20, "U8"]
    },
    "darwin-64": {
        "d_name": [21, "Utf8String"],
        "d_type": [20, "U8"]
    }
};
const direntSpec = isWindows ? direntSpecs.windows : direntSpecs[`${platform}-${pointerSize * 8}`];
function readdirSync(path) {
    const entries = [];
    enumerateDirectoryEntries(path, entry => {
        const name = readDirentField(entry, "d_name");
        entries.push(name);
    });
    return entries;
}
function list(path) {
    const extraFieldNames = Object.keys(direntSpec).filter(k => !k.startsWith("d_"));
    const entries = [];
    enumerateDirectoryEntries(path, entry => {
        const name = readDirentField(entry, "d_name");
        const type = readDirentField(entry, "d_type", fsPath.join(path, name));
        const extras = {};
        for (const f of extraFieldNames)
            extras[f] = readDirentField(entry, f);
        entries.push({
            name,
            type,
            ...extras
        });
    });
    return entries;
}
function readDirentField(entry, name, ...args) {
    const fieldSpec = direntSpec[name];
    const [offset, type] = fieldSpec;
    const read = (typeof type === "string") ? NativePointer.prototype["read" + type] : type;
    const value = read.call(entry.add(offset), ...args);
    if (value instanceof Int64 || value instanceof UInt64)
        return value.valueOf();
    return value;
}
const statFields = new Set([
    "dev",
    "mode",
    "nlink",
    "uid",
    "gid",
    "rdev",
    "blksize",
    "ino",
    "size",
    "blocks",
    "atimeMs",
    "mtimeMs",
    "ctimeMs",
    "birthtimeMs",
    "atime",
    "mtime",
    "ctime",
    "birthtime",
]);
const statSpecGenericLinux32 = {
    size: 88,
    fields: {
        "dev": [0, "U64"],
        "mode": [16, "U32"],
        "nlink": [20, "U32"],
        "ino": [12, "U32"],
        "uid": [24, "U32"],
        "gid": [28, "U32"],
        "rdev": [32, "U64"],
        "atime": [56, readTimespec32],
        "mtime": [64, readTimespec32],
        "ctime": [72, readTimespec32],
        "size": [44, "S32"],
        "blocks": [52, "S32"],
        "blksize": [48, "S32"],
    }
};
const statSpecs = {
    "windows": {
        size: 36,
        fields: {
            "dev": [0, returnZero],
            "mode": [0, readWindowsFileAttributes],
            "nlink": [0, returnOne],
            "ino": [0, returnZero],
            "uid": [0, returnZero],
            "gid": [0, returnZero],
            "rdev": [0, returnZero],
            "atime": [12, readWindowsFileTime],
            "mtime": [20, readWindowsFileTime],
            "ctime": [20, readWindowsFileTime],
            "birthtime": [4, readWindowsFileTime],
            "size": [28, readWindowsFileSize],
            "blocks": [28, readWindowsFileSize],
            "blksize": [0, returnOne],
        },
    },
    "darwin-32": {
        size: 108,
        fields: {
            "dev": [0, "S32"],
            "mode": [4, "U16"],
            "nlink": [6, "U16"],
            "ino": [8, "U64"],
            "uid": [16, "U32"],
            "gid": [20, "U32"],
            "rdev": [24, "S32"],
            "atime": [28, readTimespec32],
            "mtime": [36, readTimespec32],
            "ctime": [44, readTimespec32],
            "birthtime": [52, readTimespec32],
            "size": [60, "S64"],
            "blocks": [68, "S64"],
            "blksize": [76, "S32"],
        }
    },
    "darwin-64": {
        size: 144,
        fields: {
            "dev": [0, "S32"],
            "mode": [4, "U16"],
            "nlink": [6, "U16"],
            "ino": [8, "U64"],
            "uid": [16, "U32"],
            "gid": [20, "U32"],
            "rdev": [24, "S32"],
            "atime": [32, readTimespec64],
            "mtime": [48, readTimespec64],
            "ctime": [64, readTimespec64],
            "birthtime": [80, readTimespec64],
            "size": [96, "S64"],
            "blocks": [104, "S64"],
            "blksize": [112, "S32"],
        }
    },
    "linux-ia32": statSpecGenericLinux32,
    "linux-ia32-stat64": {
        size: 96,
        fields: {
            "dev": [0, "U64"],
            "mode": [16, "U32"],
            "nlink": [20, "U32"],
            "ino": [88, "U64"],
            "uid": [24, "U32"],
            "gid": [28, "U32"],
            "rdev": [32, "U64"],
            "atime": [64, readTimespec32],
            "mtime": [72, readTimespec32],
            "ctime": [80, readTimespec32],
            "size": [44, "S64"],
            "blocks": [56, "S64"],
            "blksize": [52, "S32"],
        },
    },
    "linux-x64": {
        size: 144,
        fields: {
            "dev": [0, "U64"],
            "mode": [24, "U32"],
            "nlink": [16, "U64"],
            "ino": [8, "U64"],
            "uid": [28, "U32"],
            "gid": [32, "U32"],
            "rdev": [40, "U64"],
            "atime": [72, readTimespec64],
            "mtime": [88, readTimespec64],
            "ctime": [104, readTimespec64],
            "size": [48, "S64"],
            "blocks": [64, "S64"],
            "blksize": [56, "S64"],
        },
    },
    "linux-arm": statSpecGenericLinux32,
    "linux-arm-stat64": {
        size: 104,
        fields: {
            "dev": [0, "U64"],
            "mode": [16, "U32"],
            "nlink": [20, "U32"],
            "ino": [96, "U64"],
            "uid": [24, "U32"],
            "gid": [28, "U32"],
            "rdev": [32, "U64"],
            "atime": [72, readTimespec32],
            "mtime": [80, readTimespec32],
            "ctime": [88, readTimespec32],
            "size": [48, "S64"],
            "blocks": [64, "S64"],
            "blksize": [56, "S32"],
        }
    },
    "linux-arm64": {
        size: 128,
        fields: {
            "dev": [0, "U64"],
            "mode": [16, "U32"],
            "nlink": [20, "U32"],
            "ino": [8, "U64"],
            "uid": [24, "U32"],
            "gid": [28, "U32"],
            "rdev": [32, "U64"],
            "atime": [72, readTimespec64],
            "mtime": [88, readTimespec64],
            "ctime": [104, readTimespec64],
            "size": [48, "S64"],
            "blocks": [64, "S64"],
            "blksize": [56, "S32"],
        },
    },
};
const linuxStatVersions = {
    ia32: 3,
    x64: 1,
    arm: 3,
    arm64: 0,
    mips: 3,
};
const STAT_VER_LINUX = linuxStatVersions[Process.arch];
let cachedStatSpec = null;
const statBufSize = 256;
function getStatSpec() {
    if (cachedStatSpec !== null)
        return cachedStatSpec;
    let statSpec;
    if (isWindows) {
        statSpec = statSpecs.windows;
    }
    else {
        const api = getPosixApi();
        const stat64Impl = api.stat64 ?? api.__xstat64;
        let platformId;
        if (platform === "darwin") {
            platformId = `darwin-${pointerSize * 8}`;
        }
        else {
            platformId = `${platform}-${Process.arch}`;
            if (pointerSize === 4 && stat64Impl !== undefined) {
                platformId += "-stat64";
            }
        }
        statSpec = statSpecs[platformId];
        if (statSpec === undefined)
            throw new Error("Current OS/arch combo is not yet supported; please open a PR");
        statSpec._stat = stat64Impl ?? api.stat;
        statSpec._lstat = api.lstat64 ?? api.__lxstat64 ?? api.lstat;
    }
    cachedStatSpec = statSpec;
    return statSpec;
}
class Stats {
    isFile() {
        return (this.mode & S_IFMT) === S_IFREG;
    }
    isDirectory() {
        return (this.mode & S_IFMT) === S_IFDIR;
    }
    isCharacterDevice() {
        return (this.mode & S_IFMT) === S_IFCHR;
    }
    isBlockDevice() {
        return (this.mode & S_IFMT) === S_IFBLK;
    }
    isFIFO() {
        return (this.mode & S_IFMT) === S_IFIFO;
    }
    isSymbolicLink() {
        return (this.mode & S_IFMT) === S_IFLNK;
    }
    isSocket() {
        return (this.mode & S_IFMT) === S_IFSOCK;
    }
}
function makeStatsProxy(path, buf) {
    return new Proxy(new Stats(), {
        has(target, property) {
            if (typeof property === "symbol")
                return property in target;
            return statsHasField(property);
        },
        get(target, property, receiver) {
            switch (property) {
                case "prototype":
                    return undefined;
                case "constructor":
                case "toString":
                    return target[property];
                case "hasOwnProperty":
                    return statsHasField;
                case "valueOf":
                    return receiver;
                case "buffer":
                    return buf;
                default:
                    if (typeof property === "symbol" || property in target)
                        return target[property];
                    return statsReadField.call(receiver, property, path);
            }
        },
        set(target, property, value, receiver) {
            return false;
        },
        ownKeys(target) {
            return Array.from(statFields);
        },
        getOwnPropertyDescriptor(target, property) {
            return {
                writable: false,
                configurable: true,
                enumerable: true
            };
        },
    });
}
function statsHasField(name) {
    return statFields.has(name);
}
function statsReadField(name, path) {
    let field = getStatSpec().fields[name];
    if (field === undefined) {
        if (name === "birthtime") {
            return statsReadField.call(this, "ctime", path);
        }
        const msPos = name.lastIndexOf("Ms");
        if (msPos === name.length - 2) {
            return statsReadField.call(this, name.substring(0, msPos), path).getTime();
        }
        return undefined;
    }
    const [offset, type] = field;
    const read = (typeof type === "string") ? NativePointer.prototype["read" + type] : type;
    const value = read.call(this.buffer.add(offset), path);
    if (value instanceof Int64 || value instanceof UInt64)
        return value.valueOf();
    return value;
}
function readWindowsFileAttributes(path) {
    const attributes = this.readU32();
    let isLink = false;
    if ((attributes & FILE_ATTRIBUTE_REPARSE_POINT) !== 0) {
        enumerateWindowsDirectoryEntriesMatching(path, data => {
            const reserved0 = data.add(36).readU32();
            isLink = (reserved0 === IO_REPARSE_TAG_MOUNT_POINT || reserved0 === IO_REPARSE_TAG_SYMLINK);
        });
    }
    const isDir = (attributes & FILE_ATTRIBUTE_DIRECTORY) !== 0;
    let mode;
    if (isLink)
        mode = S_IFLNK;
    else if (isDir)
        mode = S_IFDIR;
    else
        mode = S_IFREG;
    if (isDir)
        mode |= 0x1ed;
    else
        mode |= 0x1a4;
    return mode;
}
function readWindowsFileTime() {
    const fileTime = BigInt(this.readU64().toString()).valueOf();
    const ticksPerMsec = 10000n;
    const msecToUnixEpoch = 11644473600000n;
    const unixTime = (fileTime / ticksPerMsec) - msecToUnixEpoch;
    return new Date(parseInt(unixTime.toString()));
}
function readWindowsFileSize() {
    const high = this.readU32();
    const low = this.add(4).readU32();
    return uint64(high).shl(32).or(low);
}
function readTimespec32() {
    const sec = this.readU32();
    const nsec = this.add(4).readU32();
    const msec = nsec / 1000000;
    return new Date((sec * 1000) + msec);
}
function readTimespec64() {
    // FIXME: Improve UInt64 to support division
    const sec = this.readU64().valueOf();
    const nsec = this.add(8).readU64().valueOf();
    const msec = nsec / 1000000;
    return new Date((sec * 1000) + msec);
}
function returnZero() {
    return 0;
}
function returnOne() {
    return 1;
}
function throwWindowsError(lastError) {
    throw makeWindowsError(lastError);
}
function throwPosixError(errno) {
    throw makePosixError(errno);
}
function makeWindowsError(lastError) {
    const maxLength = 256;
    const FORMAT_MESSAGE_FROM_SYSTEM = 0x00001000;
    const FORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200;
    const buf = Memory.alloc(maxLength * 2);
    getWindowsApi().FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, lastError, 0, buf, maxLength, NULL);
    return new Error(buf.readUtf16String());
}
function makePosixError(errno) {
    const message = getPosixApi().strerror(errno).readUtf8String();
    return new Error(message);
}
function callbackify(original) {
    return function (...args) {
        const numArgsMinusOne = args.length - 1;
        const implArgs = args.slice(0, numArgsMinusOne);
        const callback = args[numArgsMinusOne];
        process.nextTick(function () {
            try {
                const result = original(...implArgs);
                callback(null, result);
            }
            catch (e) {
                callback(e);
            }
        });
    };
}
const ssizeType = (pointerSize === 8) ? "int64" : "int32";
const sizeType = "u" + ssizeType;
const offsetType = (platform === "darwin" || pointerSize === 8) ? "int64" : "int32";
function _getWindowsApi() {
    const SF = SystemFunction;
    const NF = NativeFunction;
    return makeApi([
        ["CreateFileW", SF, "pointer", ["pointer", "uint", "uint", "pointer", "uint", "uint", "pointer"]],
        ["DeleteFileW", SF, "uint", ["pointer"]],
        ["GetFileSizeEx", SF, "uint", ["pointer", "pointer"]],
        ["ReadFile", SF, "uint", ["pointer", "pointer", "uint", "pointer", "pointer"]],
        ["RemoveDirectoryW", SF, "uint", ["pointer"]],
        ["CloseHandle", NF, "uint", ["pointer"]],
        ["FindFirstFileW", SF, "pointer", ["pointer", "pointer"]],
        ["FindNextFileW", NF, "uint", ["pointer", "pointer"]],
        ["FindClose", NF, "uint", ["pointer"]],
        ["GetFileAttributesExW", SF, "uint", ["pointer", "uint", "pointer"]],
        ["GetFinalPathNameByHandleW", SF, "uint", ["pointer", "pointer", "uint", "uint"]],
        ["FormatMessageW", NF, "uint", ["uint", "pointer", "uint", "uint", "pointer", "uint", "pointer"]],
    ]);
}
function _getPosixApi() {
    const SF = SystemFunction;
    const NF = NativeFunction;
    return makeApi([
        ["open", SF, "int", ["pointer", "int", "...", "int"]],
        ["close", NF, "int", ["int"]],
        ["lseek", NF, offsetType, ["int", offsetType, "int"]],
        ["read", SF, ssizeType, ["int", "pointer", sizeType]],
        ["opendir", SF, "pointer", ["pointer"]],
        ["opendir$INODE64", SF, "pointer", ["pointer"]],
        ["closedir", NF, "int", ["pointer"]],
        ["readdir", NF, "pointer", ["pointer"]],
        ["readdir$INODE64", NF, "pointer", ["pointer"]],
        ["readlink", SF, ssizeType, ["pointer", "pointer", sizeType]],
        ["rmdir", SF, "int", ["pointer"]],
        ["unlink", SF, "int", ["pointer"]],
        ["stat", SF, "int", ["pointer", "pointer"]],
        ["stat64", SF, "int", ["pointer", "pointer"]],
        ["__xstat64", SF, "int", ["int", "pointer", "pointer"], invokeXstat],
        ["lstat", SF, "int", ["pointer", "pointer"]],
        ["lstat64", SF, "int", ["pointer", "pointer"]],
        ["__lxstat64", SF, "int", ["int", "pointer", "pointer"], invokeXstat],
        ["strerror", NF, "pointer", ["int"]],
    ]);
}
function invokeXstat(impl, path, buf) {
    return impl(STAT_VER_LINUX, path, buf);
}
function makeApi(spec) {
    return spec.reduce((api, entry) => {
        addApiPlaceholder(api, entry);
        return api;
    }, {});
}
const nativeOpts = (isWindows && pointerSize === 4) ? { abi: "stdcall" } : {};
function addApiPlaceholder(api, entry) {
    const [name] = entry;
    Object.defineProperty(api, name, {
        configurable: true,
        get() {
            const [, Ctor, retType, argTypes, wrapper] = entry;
            let impl = null;
            const address = isWindows
                ? Module.findExportByName("kernel32.dll", name)
                : Module.findExportByName(null, name);
            if (address !== null)
                impl = new Ctor(address, retType, argTypes, nativeOpts);
            if (wrapper !== undefined)
                impl = wrapper.bind(null, impl);
            Object.defineProperty(api, name, { value: impl });
            return impl;
        }
    });
}
export function createReadStream(path) {
    return new ReadStream(path);
}
export function createWriteStream(path) {
    return new WriteStream(path);
}
export const readdir = callbackify(readdirSync);
export const readFile = callbackify(readFileSync);
export const writeFile = callbackify(writeFileSync);
export const readlink = callbackify(readlinkSync);
export const rmdir = callbackify(rmdirSync);
export const unlink = callbackify(unlinkSync);
export const stat = callbackify(statSync);
export const lstat = callbackify(lstatSync);
function memoize(compute) {
    let value;
    let computed = false;
    return function (...args) {
        if (!computed) {
            value = compute(...args);
            computed = true;
        }
        return value;
    };
}
export { constants, readdirSync, list, readFileSync, writeFileSync, readlinkSync, rmdirSync, unlinkSync, statSync, lstatSync, Stats, };
export default {
    constants,
    createReadStream,
    createWriteStream,
    readdir,
    readdirSync,
    list,
    readFile,
    readFileSync,
    writeFile,
    writeFileSync,
    readlink,
    readlinkSync,
    rmdir,
    rmdirSync,
    unlink,
    unlinkSync,
    stat,
    statSync,
    lstat,
    lstatSync,
    Stats,
};

âœ„
{"version":3,"file":"index.js","sourceRoot":"./","sources":["utils/android.ts","utils/console.ts","utils/decorate.ts","utils/getter.ts","utils/lazy.ts","utils/native-struct.ts","utils/native-wait.ts","utils/offset-of.ts","utils/read-native-iterator.ts","utils/read-native-list.ts","utils/recycle.ts","utils/unity-version.ts","il2cpp/api.ts","il2cpp/application.ts","il2cpp/dump.ts","il2cpp/exception-listener.ts","il2cpp/filters.ts","il2cpp/gc.ts","il2cpp/memory.ts","il2cpp/module.ts","il2cpp/perform.ts","il2cpp/tracer.ts","il2cpp/structs/array.ts","il2cpp/structs/assembly.ts","il2cpp/structs/class.ts","il2cpp/structs/delegate.ts","il2cpp/structs/domain.ts","il2cpp/structs/field.ts","il2cpp/structs/gc-handle.ts","il2cpp/structs/image.ts","il2cpp/structs/memory-snapshot.ts","il2cpp/structs/method.ts","il2cpp/structs/object.ts","il2cpp/structs/parameter.ts","il2cpp/structs/pointer.ts","il2cpp/structs/reference.ts","il2cpp/structs/string.ts","il2cpp/structs/thread.ts","il2cpp/structs/type.ts","il2cpp/structs/value-type.ts","index.ts"],"names":[],"mappings":";;;;;;;AAAA,gBAAgB;AAChB,IAAU,OAAO,CAoBhB;AApBD,WAAU,OAAO;IAEb,kBAAkB;IAClB,MAAM,CAAC,OAAO,EAAE,UAAU,EAAE,GAAG,EAAE;QAC7B,MAAM,KAAK,GAAG,WAAW,CAAC,sBAAsB,CAAC,CAAC;QAClD,OAAO,KAAK,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;IAC1C,CAAC,EAAE,IAAI,CAAC,CAAC;IAET,SAAS,WAAW,CAAC,IAAY;QAC7B,MAAM,MAAM,GAAG,MAAM,CAAC,gBAAgB,CAAC,SAAS,EAAE,uBAAuB,CAAC,CAAC;QAE3E,IAAI,MAAM,EAAE;YACR,MAAM,qBAAqB,GAAG,IAAI,cAAc,CAAC,MAAM,EAAE,MAAM,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;YAEzF,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;YAClD,qBAAqB,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,EAAE,KAAK,CAAC,CAAC;YAE3D,OAAO,KAAK,CAAC,WAAW,EAAE,IAAI,SAAS,CAAC;SAC3C;IACL,CAAC;AACL,CAAC,EApBS,OAAO,KAAP,OAAO,QAoBhB;ACrBD,gBAAgB;AAChB,SAAS,KAAK,CAAC,OAAY;IACvB,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,UAAU,OAAO,EAAE,CAAC,CAAC;IAC7C,KAAK,CAAC,IAAI,GAAG,kCAAkC,CAAC;IAChD,KAAK,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK;QACrB,EAAE,OAAO,CAAC,QAAQ,EAAE,KAAK,CAAC,IAAI,CAAC;QAC/B,EAAE,OAAO,CAAC,6BAA6B,EAAE,gBAAgB,CAAC;QAC1D,EAAE,MAAM,CAAC,SAAS,CAAC,CAAC;IAExB,MAAM,KAAK,CAAC;AAChB,CAAC;AAED,gBAAgB;AAChB,SAAS,IAAI,CAAC,OAAY;IACrB,UAAkB,CAAC,OAAO,CAAC,GAAG,CAAC,+BAA+B,OAAO,EAAE,CAAC,CAAC;AAC9E,CAAC;AAED,gBAAgB;AAChB,SAAS,EAAE,CAAC,OAAY;IACnB,UAAkB,CAAC,OAAO,CAAC,GAAG,CAAC,+BAA+B,OAAO,EAAE,CAAC,CAAC;AAC9E,CAAC;AAED,gBAAgB;AAChB,SAAS,MAAM,CAAC,OAAY;IACvB,UAAkB,CAAC,OAAO,CAAC,GAAG,CAAC,+BAA+B,OAAO,EAAE,CAAC,CAAC;AAC9E,CAAC;ACzBD,gBAAgB;AAChB,SAAS,QAAQ,CACb,MAAS,EACT,SAAyF,EACzF,cAAc,MAAM,CAAC,yBAAyB,CAAC,MAAa,CAAC;IAE7D,KAAK,MAAM,GAAG,IAAI,WAAW,EAAE;QAC3B,WAAW,CAAC,GAAG,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,GAAG,EAAE,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC;KAC/D;IAED,MAAM,CAAC,gBAAgB,CAAC,MAAM,EAAE,WAAW,CAAC,CAAC;IAE7C,OAAO,MAAM,CAAC;AAClB,CAAC;ACbD,gBAAgB;AAChB,SAAS,MAAM,CACX,MAAS,EACT,GAAM,EACN,GAAe,EACf,SAAqF;IAErF,UAAU,CAAC,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,GAAG,EAAE,SAAS,EAAE,CAAC,MAAM,EAAE,GAAG,EAAE,EAAE,GAAG,EAAE,YAAY,EAAE,IAAI,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,YAAY,EAAE,IAAI,EAAE,CAAC,CAAC;AACxI,CAAC;ACRD,gBAAgB;AAChB,SAAS,IAAI,CAAC,CAAM,EAAE,WAAwB,EAAE,UAA8B;IAC1E,MAAM,MAAM,GAAG,UAAU,CAAC,GAAG,CAAC;IAE9B,IAAI,CAAC,MAAM,EAAE;QACT,MAAM,IAAI,KAAK,CAAC,+CAA+C,CAAC,CAAC;KACpE;IAED,UAAU,CAAC,GAAG,GAAG;QACb,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAChC,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,WAAW,EAAE;YACrC,KAAK;YACL,YAAY,EAAE,UAAU,CAAC,YAAY;YACrC,UAAU,EAAE,UAAU,CAAC,UAAU;YACjC,QAAQ,EAAE,KAAK;SAClB,CAAC,CAAC;QACH,OAAO,KAAK,CAAC;IACjB,CAAC,CAAC;IACF,OAAO,UAAU,CAAC;AACtB,CAAC;ACnBD,sBAAsB;AACtB,MAAM,YAAY;IACL,MAAM,CAAgB;IAE/B,YAAY,eAAmC;QAC3C,IAAI,eAAe,YAAY,aAAa,EAAE;YAC1C,IAAI,CAAC,MAAM,GAAG,eAAe,CAAC;SACjC;aAAM;YACH,IAAI,CAAC,MAAM,GAAG,eAAe,CAAC,MAAM,CAAC;SACxC;IACL,CAAC;IAED,MAAM,CAAC,KAAmB;QACtB,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;IAC5C,CAAC;IAED,MAAM;QACF,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC;IAChC,CAAC;IAED,UAAU;QACN,OAAO,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;IACvC,CAAC;CACJ;ACjBD,gBAAgB;AAChB,SAAS,SAAS,CAAC,GAAG,WAAqB;IACvC,SAAS,IAAI,CACT,UAAyB,EACzB,IAAY,EACZ,aAAuD,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,cAAc,EAAE;QAE9E,MAAM,MAAM,GAAG,MAAM,CAAC,gBAAgB,CAAC,UAAU,EAAE,IAAI,CAAC,IAAI,IAAI,CAAC;QACjE,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,EAAE;YAClB,OAAO,EAAE,MAAM,EAAE,UAAU,EAAE,CAAC;SACjC;IACL,CAAC;IAED,OAAO,IAAI,OAAO,CAAS,OAAO,CAAC,EAAE;QACjC,KAAK,MAAM,UAAU,IAAI,WAAW,EAAE;YAClC,MAAM,MAAM,GAAG,OAAO,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;YACpD,IAAI,MAAM,IAAI,IAAI,EAAE;gBAChB,OAAO,CAAC,MAAM,CAAC,CAAC;gBAChB,OAAO;aACV;SACJ;QAED,IAAI,OAAO,GAAmC,EAAE,CAAC;QAEjD,QAAQ,OAAO,CAAC,QAAQ,EAAE;YACtB,KAAK,OAAO;gBACR,IAAI,OAAO,CAAC,QAAQ,IAAI,IAAI,EAAE;oBAC1B,OAAO,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC;oBACjC,MAAM;iBACT;gBAED,wCAAwC;gBACxC,oBAAoB;gBACpB,oCAAoC;gBACpC,0CAA0C;gBAC1C,OAAO,GAAG,CAAC,OAAO,CAAC,gBAAgB,CAAC,UAAU,CAAC,IAAI,OAAO,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;qBAChF,gBAAgB,EAAE;qBAClB,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,sBAAsB,EAAE,yBAAyB,EAAE,WAAW,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;qBAC9F,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,MAAM,EAAE,CAAC,CAAC,OAAO,EAAE,UAAU,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC,CAAC;gBACzE,MAAM;YACV,KAAK,QAAQ;gBACT,OAAO,GAAG,CAAC,IAAI,CAAC,eAAe,EAAE,QAAQ,CAAC,CAAC,CAAC;gBAC5C,MAAM;YACV,KAAK,SAAS;gBACV,OAAO,GAAG;oBACN,IAAI,CAAC,cAAc,EAAE,cAAc,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,eAAe,EAAE,CAAC;oBAC9D,IAAI,CAAC,cAAc,EAAE,gBAAgB,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,eAAe,EAAE,CAAC;oBAChE,IAAI,CAAC,cAAc,EAAE,cAAc,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,cAAc,EAAE,CAAC;oBAC7D,IAAI,CAAC,cAAc,EAAE,gBAAgB,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,cAAc,EAAE,CAAC;iBAClE,CAAC;gBACF,MAAM;SACb;QAED,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QAEjC,IAAI,OAAO,CAAC,MAAM,IAAI,CAAC,EAAE;YACrB,KAAK,CAAC,sDAAsD,WAAW,4BAA4B,CAAC,CAAC;SACxG;QAED,MAAM,OAAO,GAAG,UAAU,CAAC,GAAG,EAAE;YAC5B,KAAK,MAAM,UAAU,IAAI,WAAW,EAAE;gBAClC,MAAM,MAAM,GAAG,OAAO,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC;gBACpD,IAAI,MAAM,IAAI,IAAI,EAAE;oBAChB,IAAI,CAAC,UAAU,MAAM,CAAC,IAAI,kFAAkF,CAAC,CAAC;oBAC9G,YAAY,CAAC,OAAO,CAAC,CAAC;oBACtB,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC;oBACtC,OAAO,CAAC,MAAM,CAAC,CAAC;oBAChB,OAAO;iBACV;aACJ;YAED,IAAI,CAAC,qCAAqC,WAAW,sDAAsD,CAAC,CAAC;QACjH,CAAC,EAAE,KAAK,CAAC,CAAC;QAEV,MAAM,YAAY,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CACjC,WAAW,CAAC,MAAM,CAAC,CAAE,CAAC,MAAM,EAAE;YAC1B,OAAO,CAAC,IAAyB;gBAC7B,IAAI,CAAC,UAAU,GAAG,CAAE,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;YACnD,CAAC;YACD,OAAO,CAAC,CAAwB;gBAC5B,KAAK,MAAM,UAAU,IAAI,WAAW,EAAE;oBAClC,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE;wBACtC,MAAM,MAAM,GAAG,OAAO,CAAC,gBAAgB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;wBAEzD,IAAI,MAAM,IAAI,IAAI,EAAE;4BAChB,YAAY,CAAC,GAAG,EAAE;gCACd,YAAY,CAAC,OAAO,CAAC,CAAC;gCACtB,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC;4BAC1C,CAAC,CAAC,CAAC;4BACH,OAAO,CAAC,MAAM,CAAC,CAAC;4BAChB,MAAM;yBACT;qBACJ;iBACJ;YACL,CAAC;SACJ,CAAC,CACL,CAAC;IACN,CAAC,CAAC,CAAC;AACP,CAAC;ACnGD,aAAa,CAAC,SAAS,CAAC,QAAQ,GAAG,UAAU,SAAS,EAAE,KAAK;IACzD,KAAK,KAAK,GAAG,CAAC;IAEd,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE;QACrD,IAAI,SAAS,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE;YAClD,OAAO,CAAC,CAAC;SACZ;KACJ;IAED,OAAO,IAAI,CAAC;AAChB,CAAC,CAAC;ACfF,gBAAgB;AAChB,SAAS,kBAAkB,CAAC,KAAwD;IAChF,MAAM,KAAK,GAAG,EAAE,CAAC;IACjB,MAAM,QAAQ,GAAG,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;IAEnD,IAAI,MAAM,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC;IAE7B,OAAO,CAAC,MAAM,CAAC,MAAM,EAAE,EAAE;QACrB,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACnB,MAAM,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC;KAC5B;IAED,OAAO,KAAK,CAAC;AACjB,CAAC;ACbD,gBAAgB;AAChB,SAAS,cAAc,CAAC,KAAsD;IAC1E,MAAM,aAAa,GAAG,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;IACxD,MAAM,YAAY,GAAG,KAAK,CAAC,aAAa,CAAC,CAAC;IAE1C,IAAI,YAAY,CAAC,MAAM,EAAE,EAAE;QACvB,OAAO,EAAE,CAAC;KACb;IAED,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,aAAa,CAAC,OAAO,EAAE,CAAC,CAAC;IAEjD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACnC,KAAK,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,WAAW,CAAC,CAAC,WAAW,EAAE,CAAC;KACtE;IAED,OAAO,KAAK,CAAC;AACjB,CAAC;AChBD,gBAAgB;AAChB,SAAS,OAAO,CAAsE,KAAQ;IAC1F,OAAO,IAAI,KAAK,CAAC,KAAK,EAAE;QACpB,KAAK,EAAE,IAAI,GAAG,EAAE;QAChB,SAAS,CAAC,MAAS,EAAE,QAAyB;YAC1C,MAAM,MAAM,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC;YAEtC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;gBACzB,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;aACnD;YACD,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,CAAE,CAAC;QACnC,CAAC;KAC2C,CAAC,CAAC;AACtD,CAAC;ACbD,gBAAgB;AAChB,IAAU,YAAY,CA6BrB;AA7BD,WAAU,YAAY;IAClB,MAAM,OAAO,GAAG,qDAAqD,CAAC;IAEtE,SAAgB,IAAI,CAAC,MAAqB;QACtC,OAAO,MAAM,EAAE,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IACvC,CAAC;IAFe,iBAAI,OAEnB,CAAA;IAED,SAAgB,GAAG,CAAC,CAAS,EAAE,CAAS;QACpC,OAAO,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC;IAC9B,CAAC;IAFe,gBAAG,MAElB,CAAA;IAED,SAAgB,EAAE,CAAC,CAAS,EAAE,CAAS;QACnC,OAAO,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC;IAC7B,CAAC;IAFe,eAAE,KAEjB,CAAA;IAED,SAAS,OAAO,CAAC,CAAS,EAAE,CAAS;QACjC,MAAM,QAAQ,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;QAClC,MAAM,QAAQ,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;QAElC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;YACzB,MAAM,CAAC,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACtC,MAAM,CAAC,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAEtC,IAAI,CAAC,GAAG,CAAC;gBAAE,OAAO,CAAC,CAAC;iBACf,IAAI,CAAC,GAAG,CAAC;gBAAE,OAAO,CAAC,CAAC,CAAC;SAC7B;QAED,OAAO,CAAC,CAAC;IACb,CAAC;AACL,CAAC,EA7BS,YAAY,KAAZ,YAAY,QA6BrB;AC9BD,IAAU,MAAM,CAwff;AAxfD,WAAU,MAAM;IACC,UAAG,GAAG;QACf,IAAI,KAAK;YACL,OAAO,CAAC,CAAC,cAAc,EAAE,SAAS,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;QACpD,CAAC;QAED,IAAI,cAAc;YACd,OAAO,CAAC,CAAC,qBAAqB,EAAE,QAAQ,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC3D,CAAC;QAED,IAAI,QAAQ;YACR,OAAO,CAAC,CAAC,kBAAkB,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC,CAAC;QACnE,CAAC;QAED,IAAI,gBAAgB;YAChB,OAAO,CAAC,CAAC,2BAA2B,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAClE,CAAC;QAED,IAAI,YAAY;YACZ,OAAO,CAAC,CAAC,uBAAuB,EAAE,MAAM,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QACtE,CAAC;QAED,IAAI,aAAa;YACb,OAAO,CAAC,CAAC,wBAAwB,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QACrF,CAAC;QAED,IAAI,eAAe;YACf,OAAO,CAAC,CAAC,+BAA+B,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QACtE,CAAC;QAED,IAAI,kBAAkB;YAClB,OAAO,CAAC,CAAC,wBAAwB,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC,CAAC;QACzE,CAAC;QAED,IAAI,wBAAwB;YACxB,OAAO,CAAC,CAAC,iCAAiC,EAAE,KAAK,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QACpE,CAAC;QAED,IAAI,oBAAoB;YACpB,OAAO,CAAC,CAAC,+BAA+B,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QACtE,CAAC;QAED,IAAI,gBAAgB;YAChB,OAAO,CAAC,CAAC,4BAA4B,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QACnE,CAAC;QAED,IAAI,qBAAqB;YACrB,OAAO,CAAC,CAAC,iCAAiC,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QACxE,CAAC;QAED,IAAI,oBAAoB;YACpB,OAAO,CAAC,CAAC,gCAAgC,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QACvE,CAAC;QAED,IAAI,qBAAqB;YACrB,OAAO,CAAC,CAAC,kCAAkC,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QACpF,CAAC;QAED,IAAI,cAAc;YACd,OAAO,CAAC,CAAC,yBAAyB,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QAC3E,CAAC;QAED,IAAI,aAAa;YACb,OAAO,CAAC,CAAC,wBAAwB,EAAE,KAAK,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC3D,CAAC;QAED,IAAI,aAAa;YACb,OAAO,CAAC,CAAC,wBAAwB,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC/D,CAAC;QAED,IAAI,oBAAoB;YACpB,OAAO,CAAC,CAAC,4BAA4B,EAAE,OAAO,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QACjE,CAAC;QAED,IAAI,kBAAkB;YAClB,OAAO,CAAC,CAAC,6BAA6B,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QAC/E,CAAC;QAED,IAAI,sBAAsB;YACtB,OAAO,CAAC,CAAC,mCAAmC,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC,CAAC;QAC5F,CAAC;QAED,IAAI,eAAe;YACf,OAAO,CAAC,CAAC,0BAA0B,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QAC5E,CAAC;QAED,IAAI,YAAY;YACZ,OAAO,CAAC,CAAC,uBAAuB,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC9D,CAAC;QAED,IAAI,iBAAiB;YACjB,OAAO,CAAC,CAAC,4BAA4B,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QACnE,CAAC;QAED,IAAI,qBAAqB;YACrB,OAAO,CAAC,CAAC,+BAA+B,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QACjF,CAAC;QAED,IAAI,cAAc;YACd,OAAO,CAAC,CAAC,yBAAyB,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAChE,CAAC;QAED,IAAI,uBAAuB;YACvB,OAAO,CAAC,CAAC,oCAAoC,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC3E,CAAC;QAED,IAAI,qBAAqB;YACrB,OAAO,CAAC,CAAC,yBAAyB,EAAE,OAAO,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QACzE,CAAC;QAED,IAAI,YAAY;YACZ,OAAO,CAAC,CAAC,uBAAuB,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC9D,CAAC;QAED,IAAI,kBAAkB;YAClB,OAAO,CAAC,CAAC,6BAA6B,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QACjE,CAAC;QAED,IAAI,eAAe;YACf,OAAO,CAAC,CAAC,2BAA2B,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC/D,CAAC;QAED,IAAI,eAAe;YACf,OAAO,CAAC,CAAC,0BAA0B,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC9D,CAAC;QAED,IAAI,qBAAqB;YACrB,OAAO,CAAC,CAAC,iCAAiC,EAAE,MAAM,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QAChF,CAAC;QAED,IAAI,gBAAgB;YAChB,OAAO,CAAC,CAAC,2BAA2B,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC/D,CAAC;QAED,IAAI,WAAW;YACX,OAAO,CAAC,CAAC,sBAAsB,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC1D,CAAC;QAED,IAAI,cAAc;YACd,OAAO,CAAC,CAAC,yBAAyB,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC7D,CAAC;QAED,IAAI,eAAe;YACf,OAAO,CAAC,CAAC,0BAA0B,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC9D,CAAC;QAED,IAAI,gBAAgB;YAChB,OAAO,CAAC,CAAC,2BAA2B,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC/D,CAAC;QAED,IAAI,iBAAiB;YACjB,OAAO,CAAC,CAAC,6BAA6B,EAAE,MAAM,EAAE,CAAC,SAAS,EAAE,SAAS,EAAE,MAAM,CAAC,CAAC,CAAC;QACpF,CAAC;QAED,IAAI,gBAAgB;YAChB,OAAO,CAAC,CAAC,2BAA2B,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC/D,CAAC;QAED,IAAI,yBAAyB;YACzB,OAAO,CAAC,CAAC,6BAA6B,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QAC/E,CAAC;QAED,IAAI,SAAS;YACT,OAAO,CAAC,CAAC,mBAAmB,EAAE,SAAS,EAAE,EAAE,CAAC,CAAC;QACjD,CAAC;QAED,IAAI,mBAAmB;YACnB,OAAO,CAAC,CAAC,8BAA8B,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QAChF,CAAC;QAED,IAAI,aAAa;YACb,OAAO,CAAC,CAAC,yBAAyB,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAChE,CAAC;QAED,IAAI,aAAa;YACb,OAAO,CAAC,CAAC,wBAAwB,EAAE,KAAK,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC3D,CAAC;QAED,IAAI,YAAY;YACZ,OAAO,CAAC,CAAC,uBAAuB,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC9D,CAAC;QAED,IAAI,cAAc;YACd,OAAO,CAAC,CAAC,yBAAyB,EAAE,OAAO,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC9D,CAAC;QAED,IAAI,mBAAmB;YACnB,OAAO,CAAC,CAAC,+BAA+B,EAAE,MAAM,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QAC9E,CAAC;QAED,IAAI,YAAY;YACZ,OAAO,CAAC,CAAC,uBAAuB,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC9D,CAAC;QAED,IAAI,mBAAmB;YACnB,OAAO,CAAC,CAAC,+BAA+B,EAAE,MAAM,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QAC9E,CAAC;QAED,IAAI,IAAI;YACJ,OAAO,CAAC,CAAC,aAAa,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QACjD,CAAC;QAED,IAAI,SAAS;YACT,OAAO,CAAC,CAAC,mBAAmB,EAAE,MAAM,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;QACnD,CAAC;QAED,IAAI,gBAAgB;YAChB,OAAO,CAAC,CAAC,4BAA4B,EAAE,MAAM,EAAE,EAAE,CAAC,CAAC;QACvD,CAAC;QAED,IAAI,SAAS;YACT,OAAO,CAAC,CAAC,mBAAmB,EAAE,MAAM,EAAE,EAAE,CAAC,CAAC;QAC9C,CAAC;QAED,IAAI,QAAQ;YACR,OAAO,CAAC,CAAC,kBAAkB,EAAE,MAAM,EAAE,EAAE,CAAC,CAAC;QAC7C,CAAC;QAED,IAAI,aAAa;YACb,OAAO,CAAC,CAAC,yBAAyB,EAAE,OAAO,EAAE,EAAE,CAAC,CAAC;QACrD,CAAC;QAED,IAAI,iBAAiB;YACjB,OAAO,CAAC,CAAC,iCAAiC,EAAE,OAAO,EAAE,EAAE,CAAC,CAAC;QAC7D,CAAC;QAED,IAAI,aAAa;YACb,OAAO,CAAC,CAAC,yBAAyB,EAAE,OAAO,EAAE,EAAE,CAAC,CAAC;QACrD,CAAC;QAED,IAAI,iBAAiB;YACjB,OAAO,CAAC,CAAC,4BAA4B,EAAE,SAAS,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;QAClE,CAAC;QAED,IAAI,YAAY;YACZ,OAAO,CAAC,CAAC,sBAAsB,EAAE,MAAM,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;QACzD,CAAC;QAED,IAAI,WAAW;YACX,OAAO,CAAC,CAAC,qBAAqB,EAAE,QAAQ,EAAE,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC,CAAC;QACnE,CAAC;QAED,IAAI,kBAAkB;YAClB,OAAO,CAAC,CAAC,6BAA6B,EAAE,QAAQ,EAAE,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC,CAAC;QAC3E,CAAC;QAED,IAAI,YAAY;YACZ,OAAO,CAAC,CAAC,uBAAuB,EAAE,MAAM,EAAE,EAAE,CAAC,CAAC;QAClD,CAAC;QAED,IAAI,eAAe;YACf,OAAO,CAAC,CAAC,0BAA0B,EAAE,MAAM,EAAE,EAAE,CAAC,CAAC;QACrD,CAAC;QAED,IAAI,iBAAiB;YACjB,OAAO,CAAC,CAAC,iCAAiC,EAAE,MAAM,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC;QACnE,CAAC;QAED,IAAI,4BAA4B;YAC5B,OAAO,CAAC,CAAC,wCAAwC,EAAE,MAAM,EAAE,EAAE,CAAC,CAAC;QACnE,CAAC;QAED,IAAI,YAAY;YACZ,OAAO,CAAC,CAAC,uBAAuB,EAAE,MAAM,EAAE,EAAE,CAAC,CAAC;QAClD,CAAC;QAED,IAAI,WAAW;YACX,OAAO,CAAC,CAAC,sBAAsB,EAAE,MAAM,EAAE,EAAE,CAAC,CAAC;QACjD,CAAC;QAED,IAAI,SAAS;YACT,OAAO,CAAC,CAAC,mBAAmB,EAAE,SAAS,EAAE,EAAE,CAAC,CAAC;QACjD,CAAC;QAED,IAAI,gBAAgB;YAChB,OAAO,CAAC,CAAC,2BAA2B,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAClE,CAAC;QAED,IAAI,aAAa;YACb,OAAO,CAAC,CAAC,wBAAwB,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC,CAAC;QACvE,CAAC;QAED,IAAI,kBAAkB;YAClB,OAAO,CAAC,CAAC,8BAA8B,EAAE,QAAQ,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QACpE,CAAC;QAED,IAAI,YAAY;YACZ,OAAO,CAAC,CAAC,uBAAuB,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC9D,CAAC;QAED,IAAI,UAAU;YACV,OAAO,CAAC,CAAC,aAAa,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QACjD,CAAC;QAED,IAAI,sBAAsB;YACtB,OAAO,CAAC,CAAC,uCAAuC,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,KAAK,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QACtH,CAAC;QAED,IAAI,wBAAwB;YACxB,OAAO,CAAC,CAAC,yCAAyC,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,KAAK,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QACnI,CAAC;QAED,IAAI,sBAAsB;YACtB,OAAO,CAAC,CAAC,uCAAuC,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC3E,CAAC;QAED,IAAI,8BAA8B;YAC9B,OAAO,CAAC,CAAC,gDAAgD,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QACpF,CAAC;QAED,IAAI,gBAAgB;YAChB,OAAO,CAAC,CAAC,gCAAgC,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QACpE,CAAC;QAED,IAAI,kBAAkB;YAClB,OAAO,CAAC,CAAC,mCAAmC,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QACvE,CAAC;QAED,IAAI,qBAAqB;YACrB,OAAO,CAAC,CAAC,gCAAgC,EAAE,SAAS,EAAE,EAAE,CAAC,CAAC;QAC9D,CAAC;QAED,IAAI,kBAAkB;YAClB,OAAO,CAAC,CAAC,sCAAsC,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC1E,CAAC;QAED,IAAI,wBAAwB;YACxB,OAAO,CAAC,CAAC,oCAAoC,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QACtF,CAAC;QAED,IAAI,wBAAwB;YACxB,OAAO,CAAC,CAAC,oCAAoC,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QACtF,CAAC;QAED,IAAI,cAAc;YACd,OAAO,CAAC,CAAC,yBAAyB,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAChE,CAAC;QAED,IAAI,cAAc;YACd,OAAO,CAAC,CAAC,yBAAyB,EAAE,QAAQ,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QAC1E,CAAC;QAED,IAAI,aAAa;YACb,OAAO,CAAC,CAAC,wBAAwB,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC/D,CAAC;QAED,IAAI,eAAe;YACf,OAAO,CAAC,CAAC,0BAA0B,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QAC5E,CAAC;QAED,IAAI,uBAAuB;YACvB,OAAO,CAAC,CAAC,+BAA+B,EAAE,OAAO,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QACpE,CAAC;QAED,IAAI,sBAAsB;YACtB,OAAO,CAAC,CAAC,8BAA8B,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC,CAAC;QAC/E,CAAC;QAED,IAAI,mBAAmB;YACnB,OAAO,CAAC,CAAC,8BAA8B,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QAChF,CAAC;QAED,IAAI,sBAAsB;YACtB,OAAO,CAAC,CAAC,yBAAyB,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC,CAAC;QAC1E,CAAC;QAED,IAAI,mBAAmB;YACnB,OAAO,CAAC,CAAC,+BAA+B,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QACtE,CAAC;QAED,IAAI,eAAe;YACf,OAAO,CAAC,CAAC,0BAA0B,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC9D,CAAC;QAED,IAAI,gBAAgB;YAChB,OAAO,CAAC,CAAC,2BAA2B,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC/D,CAAC;QAED,IAAI,gBAAgB;YAChB,OAAO,CAAC,CAAC,2BAA2B,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC/D,CAAC;QAED,IAAI,YAAY;YACZ,OAAO,CAAC,CAAC,sBAAsB,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC1D,CAAC;QAED,IAAI,WAAW;YACX,OAAO,CAAC,CAAC,qBAAqB,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QACzD,CAAC;QAED,IAAI,YAAY;YACZ,OAAO,CAAC,CAAC,sBAAsB,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC1D,CAAC;QAED,IAAI,eAAe;YACf,OAAO,CAAC,CAAC,0BAA0B,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC9D,CAAC;QAED,IAAI,eAAe;YACf,OAAO,CAAC,CAAC,0BAA0B,EAAE,MAAM,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC,CAAC;QACxE,CAAC;QAED,IAAI,cAAc;YACd,OAAO,CAAC,CAAC,yBAAyB,EAAE,MAAM,EAAE,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC,CAAC;QACvE,CAAC;QAED,IAAI,WAAW;YACX,OAAO,CAAC,CAAC,qBAAqB,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QACzD,CAAC;QAED,IAAI,cAAc;YACd,OAAO,CAAC,CAAC,yBAAyB,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAChE,CAAC;QAED,IAAI,sBAAsB;YACtB,OAAO,CAAC,CAAC,kCAAkC,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QACpF,CAAC;QAED,IAAI,gBAAgB;YAChB,OAAO,CAAC,CAAC,sCAAsC,EAAE,MAAM,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QACrF,CAAC;QAED,IAAI,SAAS;YACT,OAAO,CAAC,CAAC,mBAAmB,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC1D,CAAC;QAED,IAAI,aAAa;YACb,OAAO,CAAC,CAAC,wBAAwB,EAAE,QAAQ,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC9D,CAAC;QAED,IAAI,WAAW;YACX,OAAO,CAAC,CAAC,qBAAqB,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC5D,CAAC;QAED,IAAI,mBAAmB;YACnB,OAAO,CAAC,CAAC,sBAAsB,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC7D,CAAC;QAED,IAAI,cAAc;YACd,OAAO,CAAC,CAAC,qBAAqB,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC5D,CAAC;QAED,IAAI,eAAe;YACf,OAAO,CAAC,CAAC,sBAAsB,EAAE,OAAO,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC3D,CAAC;QAED,IAAI,SAAS;YACT,OAAO,CAAC,CAAC,mBAAmB,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC1D,CAAC;QAED,IAAI,YAAY;YACZ,OAAO,CAAC,CAAC,kBAAkB,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;QACpE,CAAC;QAED,IAAI,YAAY;YACZ,OAAO,CAAC,CAAC,sBAAsB,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC7D,CAAC;QAED,IAAI,YAAY;YACZ,OAAO,CAAC,CAAC,sBAAsB,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC1D,CAAC;QAED,IAAI,wBAAwB;YACxB,OAAO,CAAC,CAAC,wCAAwC,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC/E,CAAC;QAED,IAAI,gBAAgB;YAChB,OAAO,CAAC,CAAC,uBAAuB,EAAE,SAAS,EAAE,EAAE,CAAC,CAAC;QACrD,CAAC;QAED,IAAI,UAAU;YACV,OAAO,CAAC,CAAC,qBAAqB,EAAE,MAAM,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QACzD,CAAC;QAED,IAAI,YAAY;YACZ,OAAO,CAAC,CAAC,wBAAwB,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC/D,CAAC;QAED,IAAI,WAAW;YACX,OAAO,CAAC,CAAC,sBAAsB,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC7D,CAAC;QAED,IAAI,aAAa;YACb,OAAO,CAAC,CAAC,wBAAwB,EAAE,SAAS,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QAC/D,CAAC;QAED,IAAI,eAAe;YACf,OAAO,CAAC,CAAC,sBAAsB,EAAE,KAAK,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;QACzD,CAAC;KACJ,CAAC;IAEF,QAAQ,CAAC,OAAA,GAAG,EAAE,IAAI,CAAC,CAAC;IAIpB,MAAM,CAAC,MAAM,EAAE,mBAAmB,EAAE,GAAG,EAAE,CAAC,IAAI,OAAO,+qEAA4C,EAAE,IAAI,CAAC,CAAC;IAEzG,SAAS,CAAC,CAAkF,UAAkB,EAAE,OAAU,EAAE,QAAW;QACnI,MAAM,MAAM,GAAI,UAAkB,CAAC,cAAc,EAAE,CAAC,UAAU,CAAC,EAAE,EAAE,IAAI,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC,UAAU,CAAC,IAAI,OAAA,iBAAiB,CAAC,UAAU,CAAC,CAAC;QAEnJ,OAAO,IAAI,cAAc,CAAC,MAAM,IAAI,KAAK,CAAC,2BAA2B,UAAU,EAAE,CAAC,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;IAC3G,CAAC;AAGL,CAAC,EAxfS,MAAM,KAAN,MAAM,QAwff;ACxfD,IAAU,MAAM,CAqEf;AArED,WAAU,MAAM;IACC,kBAAW,GAAG;QACvB,MAAM;QACN,IAAI,QAAQ;YACR,OAAO,eAAe,CAAC,wBAAwB,CAAC,CAAC;QACrD,CAAC;QAED,MAAM;QACN,IAAI,UAAU;YACV,OAAO,eAAe,CAAC,gBAAgB,CAAC,IAAI,eAAe,CAAC,sBAAsB,CAAC,CAAC;QACxF,CAAC;QAED,0CAA0C;QAC1C,IAAI,OAAO;YACP,OAAO,eAAe,CAAC,aAAa,CAAC,CAAC;QAC1C,CAAC;KACJ,CAAC;IAIF,kBAAkB;IAClB,MAAM,CAAC,MAAM,EAAE,cAAc,EAAE,GAAG,EAAE;QAChC,IAAI;YACA,MAAM,YAAY,GAAI,UAAkB,CAAC,oBAAoB,IAAI,eAAe,CAAC,kBAAkB,CAAC,CAAC;YAErG,IAAI,YAAY,IAAI,IAAI,EAAE;gBACtB,OAAO,YAAY,CAAC;aACvB;SACJ;QAAC,OAAM,CAAC,EAAE;SACV;QAED,MAAM,aAAa,GAAG,mBAAmB,CAAC;QAE1C,KAAK,MAAM,KAAK,IAAI,OAAA,MAAM,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,iBAAiB,CAAC,OAAA,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE;YAC9F,KAAK,IAAI,EAAE,OAAO,EAAE,IAAI,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,IAAI,EAAE,aAAa,CAAC,EAAE;gBAC5E,OAAO,OAAO,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE;oBAC1B,OAAO,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;iBAC5B;gBACD,MAAM,KAAK,GAAG,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC,CAAC;gBAE9D,IAAI,KAAK,IAAI,SAAS,EAAE;oBACpB,OAAO,KAAK,CAAC;iBAChB;aACJ;SACJ;QAED,KAAK,CAAC,kEAAkE,CAAC,CAAC;IAC9E,CAAC,EAAE,IAAI,CAAC,CAAC;IAIT,kBAAkB;IAClB,MAAM,CAAC,MAAM,EAAE,2BAA2B,EAAE,GAAG,EAAE;QAC7C,OAAO,YAAY,CAAC,EAAE,CAAC,OAAA,YAAY,EAAE,UAAU,CAAC,CAAC;IACrD,CAAC,EAAE,IAAI,CAAC,CAAC;IAIT,kBAAkB;IAClB,MAAM,CAAC,MAAM,EAAE,2BAA2B,EAAE,GAAG,EAAE;QAC7C,OAAO,YAAY,CAAC,EAAE,CAAC,OAAA,YAAY,EAAE,UAAU,CAAC,CAAC;IACrD,CAAC,EAAE,IAAI,CAAC,CAAC;IAET,SAAS,eAAe,CAAC,MAAc;QACnC,MAAM,MAAM,GAAG,MAAM,CAAC,GAAG,CAAC,mBAAmB,CAAC,MAAM,CAAC,eAAe,CAAC,2BAA2B,GAAG,MAAM,CAAC,CAAC,CAAC;QAC5G,MAAM,cAAc,GAAG,IAAI,cAAc,CAAC,MAAM,EAAE,SAAS,EAAE,EAAE,CAAC,CAAC;QAEjE,OAAO,cAAc,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,cAAc,EAAE,CAAC,CAAC,UAAU,EAAE,EAAE,OAAO,IAAI,IAAI,CAAC;IAC9G,CAAC;AACL,CAAC,EArES,MAAM,KAAN,MAAM,QAqEf;ACrED,IAAU,MAAM,CAoBf;AApBD,WAAU,MAAM;IACZ,6BAA6B;IAC7B,SAAgB,IAAI,CAAC,QAAiB,EAAE,IAAa;QACjD,QAAQ,GAAG,QAAQ,IAAI,GAAG,MAAM,CAAC,WAAW,CAAC,UAAU,IAAI,SAAS,IAAI,MAAM,CAAC,WAAW,CAAC,OAAO,IAAI,SAAS,KAAK,CAAC;QAErH,MAAM,WAAW,GAAG,GAAG,IAAI,IAAI,MAAM,CAAC,WAAW,CAAC,QAAQ,IAAI,QAAQ,EAAE,CAAC;QACzE,MAAM,IAAI,GAAG,IAAI,IAAI,CAAC,WAAW,EAAE,GAAG,CAAC,CAAC;QAExC,KAAK,MAAM,QAAQ,IAAI,MAAM,CAAC,MAAM,CAAC,UAAU,EAAE;YAC7C,MAAM,CAAC,WAAW,QAAQ,CAAC,IAAI,KAAK,CAAC,CAAC;YAEtC,KAAK,MAAM,KAAK,IAAI,QAAQ,CAAC,KAAK,CAAC,OAAO,EAAE;gBACxC,IAAI,CAAC,KAAK,CAAC,GAAG,KAAK,MAAM,CAAC,CAAC;aAC9B;SACJ;QAED,IAAI,CAAC,KAAK,EAAE,CAAC;QACb,IAAI,CAAC,KAAK,EAAE,CAAC;QACb,EAAE,CAAC,iBAAiB,WAAW,EAAE,CAAC,CAAC;IACvC,CAAC;IAjBe,WAAI,OAiBnB,CAAA;AACL,CAAC,EApBS,MAAM,KAAN,MAAM,QAoBf;ACpBD,IAAU,MAAM,CAaf;AAbD,WAAU,MAAM;IACZ,MAAM;IACN,SAAgB,wBAAwB,CAAC,eAAkC,SAAS;QAChF,MAAM,aAAa,GAAG,MAAM,CAAC,GAAG,CAAC,gBAAgB,EAAE,CAAC;QAEpD,OAAO,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,eAAe,CAAC,aAAa,CAAC,EAAE,UAAU,IAAI;YAClF,IAAI,YAAY,IAAI,SAAS,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,gBAAgB,EAAE,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE;gBACnF,OAAO;aACV;YAED,MAAM,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;QACrD,CAAC,CAAC,CAAC;IACP,CAAC;IAVe,+BAAwB,2BAUvC,CAAA;AACL,CAAC,EAbS,MAAM,KAAN,MAAM,QAaf;ACbD,IAAU,MAAM,CAsBf;AAtBD,WAAU,MAAM;IACZ,kGAAkG;IAClG,SAAgB,EAAE,CAAuD,KAAmB;QACxF,OAAO,CAAC,OAAU,EAAW,EAAE;YAC3B,IAAI,OAAO,YAAY,MAAM,CAAC,KAAK,EAAE;gBACjC,OAAO,KAAK,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC;aAC1C;iBAAM;gBACH,OAAO,KAAK,CAAC,gBAAgB,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;aAChD;QACL,CAAC,CAAC;IACN,CAAC;IARe,SAAE,KAQjB,CAAA;IAED,yFAAyF;IACzF,SAAgB,SAAS,CAAuD,KAAmB;QAC/F,OAAO,CAAC,OAAU,EAAW,EAAE;YAC3B,IAAI,OAAO,YAAY,MAAM,CAAC,KAAK,EAAE;gBACjC,OAAO,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;aAChC;iBAAM;gBACH,OAAO,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;aACtC;QACL,CAAC,CAAC;IACN,CAAC;IARe,gBAAS,YAQxB,CAAA;AACL,CAAC,EAtBS,MAAM,KAAN,MAAM,QAsBf;ACtBD,IAAU,MAAM,CA0Gf;AA1GD,WAAU,MAAM;IACC,SAAE,GAAG;QACd,mCAAmC;QACnC,IAAI,QAAQ;YACR,OAAO,MAAM,CAAC,GAAG,CAAC,aAAa,EAAE,CAAC;QACtC,CAAC;QAED,4DAA4D;QAC5D,IAAI,SAAS;YACT,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,YAAY,EAAE,CAAC;QACtC,CAAC;QAED,+DAA+D;QAC/D,IAAI,aAAa;YACb,OAAO,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,eAAe,EAAE,CAAC;QAC1C,CAAC;QAED,2FAA2F;QAC3F,IAAI,YAAY;YACZ,OAAO,MAAM,CAAC,GAAG,CAAC,iBAAiB,EAAE,CAAC;QAC1C,CAAC;QAED,wCAAwC;QACxC,IAAI,YAAY;YACZ,OAAO,MAAM,CAAC,GAAG,CAAC,aAAa,EAAE,CAAC;QACtC,CAAC;QAED,iDAAiD;QACjD,IAAI,SAAS,CAAC,KAAc;YACxB,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC;QAC3D,CAAC;QAED,2FAA2F;QAC3F,IAAI,YAAY,CAAC,WAA2B;YACxC,MAAM,CAAC,GAAG,CAAC,iBAAiB,CAAC,WAAW,CAAC,CAAC;QAC9C,CAAC;QAED,oGAAoG;QACpG,MAAM,CAAC,KAAmB;YACtB,MAAM,OAAO,GAAoB,EAAE,CAAC;YAEpC,MAAM,QAAQ,GAAG,CAAC,OAAsB,EAAE,IAAY,EAAE,EAAE;gBACtD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,EAAE,CAAC,EAAE,EAAE;oBAC3B,OAAO,CAAC,IAAI,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,WAAW,CAAC,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;iBACvF;YACL,CAAC,CAAC;YAEF,MAAM,cAAc,GAAG,IAAI,cAAc,CAAC,QAAQ,EAAE,MAAM,EAAE,CAAC,SAAS,EAAE,KAAK,EAAE,SAAS,CAAC,CAAC,CAAC;YAE3F,IAAI,MAAM,CAAC,yBAAyB,EAAE;gBAClC,MAAM,OAAO,GAAG,IAAI,cAAc,CAAC,GAAG,EAAE,GAAE,CAAC,EAAE,MAAM,EAAE,EAAE,CAAC,CAAC;gBACzD,MAAM,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,wBAAwB,CAAC,KAAK,EAAE,CAAC,EAAE,cAAc,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;gBAEpG,MAAM,CAAC,GAAG,CAAC,8BAA8B,CAAC,KAAK,CAAC,CAAC;gBACjD,MAAM,CAAC,GAAG,CAAC,sBAAsB,CAAC,KAAK,CAAC,CAAC;aAC5C;iBAAM;gBACH,MAAM,OAAO,GAAG,CAAC,MAAqB,EAAE,IAAY,EAAE,EAAE;oBACpD,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,IAAI,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE;wBAC1C,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;wBACpB,OAAO,IAAI,CAAC;qBACf;yBAAM;wBACH,OAAO,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;qBAC7B;gBACL,CAAC,CAAC;gBAEF,MAAM,eAAe,GAAG,IAAI,cAAc,CAAC,OAAO,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,QAAQ,EAAE,SAAS,CAAC,CAAC,CAAC;gBAEjG,IAAI,CAAC,SAAS,EAAE,CAAC;gBAEjB,MAAM,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,sBAAsB,CAAC,KAAK,EAAE,CAAC,EAAE,cAAc,EAAE,IAAI,EAAE,eAAe,CAAC,CAAC;gBACjG,MAAM,CAAC,GAAG,CAAC,8BAA8B,CAAC,KAAK,CAAC,CAAC;gBACjD,MAAM,CAAC,GAAG,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;gBAEnC,IAAI,CAAC,UAAU,EAAE,CAAC;gBAElB,MAAM,CAAC,GAAG,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;aACxC;YAED,OAAO,OAAO,CAAC;QACnB,CAAC;QAED,+DAA+D;QAC/D,OAAO,CAAC,UAAqB;YACzB,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC;QAC/E,CAAC;QAED,mCAAmC;QACnC,cAAc;YACV,MAAM,CAAC,GAAG,CAAC,gBAAgB,EAAE,CAAC;QAClC,CAAC;QAED,kDAAkD;QAClD,UAAU;YACN,OAAO,MAAM,CAAC,GAAG,CAAC,YAAY,EAAE,CAAC;QACrC,CAAC;QAED,kDAAkD;QAClD,0BAA0B;YACtB,OAAO,MAAM,CAAC,GAAG,CAAC,4BAA4B,EAAE,CAAC;QACrD,CAAC;QAED,4FAA4F;QAC5F,SAAS;YACL,OAAO,MAAM,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC;QACpC,CAAC;KACJ,CAAC;AACN,CAAC,EA1GS,MAAM,KAAN,MAAM,QA0Gf;AC1GD,IAAU,MAAM,CAgLf;AAhLD,WAAU,MAAM;IACZ,2CAA2C;IAC3C,SAAgB,KAAK,CAAC,OAAwB,OAAO,CAAC,WAAW;QAC7D,OAAO,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IAClC,CAAC;IAFe,YAAK,QAEpB,CAAA;IAED,oBAAoB;IACpB,SAAgB,IAAI,CAAC,OAA2B;QAC5C,OAAO,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IACpC,CAAC;IAFe,WAAI,OAEnB,CAAA;IAED,gBAAgB;IAChB,SAAgB,IAAI,CAAC,OAAsB,EAAE,IAAiB;QAC1D,QAAQ,IAAI,CAAC,QAAQ,EAAE;YACnB,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO;gBACzB,OAAO,CAAC,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;YAC9B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI;gBACtB,OAAO,OAAO,CAAC,MAAM,EAAE,CAAC;YAC5B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY;gBAC9B,OAAO,OAAO,CAAC,MAAM,EAAE,CAAC;YAC5B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK;gBACvB,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;YAC7B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa;gBAC/B,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;YAC7B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG;gBACrB,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;YAC7B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW;gBAC7B,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;YAC7B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI;gBACtB,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;YAC7B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI;gBACtB,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;YAC7B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY;gBAC9B,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;YAC7B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK;gBACvB,OAAO,OAAO,CAAC,SAAS,EAAE,CAAC;YAC/B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM;gBACxB,OAAO,OAAO,CAAC,UAAU,EAAE,CAAC;YAChC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC;YACpC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,qBAAqB;gBACvC,OAAO,OAAO,CAAC,WAAW,EAAE,CAAC;YACjC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO;gBACzB,OAAO,IAAI,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE,IAAI,CAAC,KAAK,CAAC,QAAS,CAAC,CAAC;YAC3E,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS;gBAC3B,OAAO,IAAI,MAAM,CAAC,SAAS,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;YAC/C,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;YAC7B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK;gBACvB,OAAO,IAAI,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC,CAAC;YACpD,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe;gBACjC,OAAO,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC,SAAS,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC,CAAC;YACnH,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM;gBACxB,OAAO,IAAI,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC,CAAC;YACpD,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;YAC5B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,qBAAqB;gBACvC,OAAO,IAAI,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC,CAAC;SACtD;QAED,KAAK,CAAC,gCAAgC,OAAO,uCAAuC,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,QAAQ,yBAAyB,CAAC,CAAC;IAC9I,CAAC;IA9Ce,WAAI,OA8CnB,CAAA;IAED,gBAAgB;IAChB,SAAgB,KAAK,CAAC,OAAsB,EAAE,KAAU,EAAE,IAAiB;QACvE,QAAQ,IAAI,CAAC,QAAQ,EAAE;YACnB,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO;gBACzB,OAAO,OAAO,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC,CAAC;YACnC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI;gBACtB,OAAO,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;YAClC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY;gBAC9B,OAAO,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;YAClC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK;gBACvB,OAAO,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YACnC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa;gBAC/B,OAAO,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YACnC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG;gBACrB,OAAO,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YACnC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW;gBAC7B,OAAO,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YACnC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI;gBACtB,OAAO,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YACnC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI;gBACtB,OAAO,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YACnC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY;gBAC9B,OAAO,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YACnC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK;gBACvB,OAAO,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;YACrC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM;gBACxB,OAAO,OAAO,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;YACtC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC;YACpC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,qBAAqB,CAAC;YAC5C,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC;YAC9B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;YAC7B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;YAC5B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,qBAAqB;gBACvC,OAAO,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;YACvC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS;gBAC3B,OAAO,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,EAAE,OAAO,CAAC;YAC1E,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;YAC7B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;YAC5B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe;gBACjC,OAAO,KAAK,YAAY,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;SACjJ;QAED,KAAK,CAAC,wBAAwB,KAAK,OAAO,OAAO,uCAAuC,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,QAAQ,yBAAyB,CAAC,CAAC;IAClJ,CAAC;IA1Ce,YAAK,QA0CpB,CAAA;IAQD,gBAAgB;IAChB,SAAgB,cAAc,CAC1B,KAA8D,EAC9D,IAAiB;QAEjB,IAAI,UAAU,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YACjC,MAAM,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC;YACtD,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;YAE1D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACpC,MAAM,cAAc,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;gBAChE,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,EAAE,cAAc,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;aACrG;YAED,OAAO,IAAI,MAAM,CAAC,SAAS,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;SAC7C;aAAM,IAAI,KAAK,YAAY,aAAa,EAAE;YACvC,IAAI,IAAI,CAAC,aAAa,EAAE;gBACpB,OAAO,IAAI,MAAM,CAAC,SAAS,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;aAC5C;YAED,QAAQ,IAAI,CAAC,QAAQ,EAAE;gBACnB,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO;oBACzB,OAAO,IAAI,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,QAAS,CAAC,CAAC;gBAC3D,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM;oBACxB,OAAO,IAAI,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACpC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;gBAC5B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC;gBACtC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM;oBACxB,OAAO,IAAI,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACpC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;gBAC5B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,qBAAqB;oBACvC,OAAO,IAAI,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;gBACnC;oBACI,OAAO,KAAK,CAAC;aACpB;SACJ;aAAM,IAAI,IAAI,CAAC,QAAQ,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YAClD,OAAO,CAAC,CAAE,KAAgB,CAAC;SAC9B;aAAM,IAAI,IAAI,CAAC,QAAQ,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;YACzE,OAAO,cAAc,CAAC,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;SACxC;aAAM;YACH,OAAO,KAAK,CAAC;SAChB;IACL,CAAC;IAzCe,qBAAc,iBAyC7B,CAAA;IAQD,gBAAgB;IAChB,SAAgB,YAAY,CAAC,KAAuD;QAChF,IAAI,OAAO,KAAK,IAAI,SAAS,EAAE;YAC3B,OAAO,CAAC,KAAK,CAAC;SACjB;aAAM,IAAI,KAAK,YAAY,MAAM,CAAC,SAAS,EAAE;YAC1C,IAAI,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;gBACzB,OAAO,KAAK,CAAC,KAAK,CAA0B,SAAS,CAAC,CAAC,KAAK,CAAC;aAChE;iBAAM;gBACH,MAAM,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,YAAY,CAAC,CAAC,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;gBAC7G,OAAO,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;aAClC;SACJ;aAAM;YACH,OAAO,KAAK,CAAC;SAChB;IACL,CAAC;IAbe,mBAAY,eAa3B,CAAA;AACL,CAAC,EAhLS,MAAM,KAAN,MAAM,QAgLf;AChLD,IAAU,MAAM,CAgDf;AAhDD,WAAU,MAAM;IAGZ,MAAM,CAAC,MAAM,EAAE,QAAQ,EAAE,GAAG,EAAE;QAC1B,MAAM,CAAC,UAAU,EAAE,QAAQ,CAAC,GAAG,sBAAsB,EAAE,CAAC;QACxD,OAAO,OAAO,CAAC,gBAAgB,CAAC,UAAU,CAAC,IAAI,OAAO,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;IACrF,CAAC,CAAC,CAAC;IAEH,0FAA0F;IACnF,KAAK,UAAU,UAAU,CAAC,QAAQ,GAAG,KAAK;QAC7C,OAAO,CAAC,cAAc,CAAC,MAAM,EAAE,QAAQ,EAAE;YACrC,kBAAkB;YAClB,KAAK,EAAE,OAAO,CAAC,QAAQ,IAAI,QAAQ;gBAC/B,CAAC,CAAC,OAAO,CAAC,mBAAmB,CAAC,WAAW,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC,OAAO,CAAC;uBACnE,MAAM,SAAS,CAAC,GAAG,sBAAsB,EAAE,CAAC;gBACnD,CAAC,CAAC,MAAM,SAAS,CAAC,GAAG,sBAAsB,EAAE,CAAC;SACrD,CAAC,CAAC;QAEH,IAAI,MAAM,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,MAAM,EAAE,EAAE;YACjC,OAAO,MAAM,IAAI,OAAO,CAAU,OAAO,CAAC,EAAE;gBACxC,MAAM,WAAW,GAAG,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,UAAU,EAAE;oBAC1D,OAAO;wBACH,WAAW,CAAC,MAAM,EAAE,CAAC;wBACrB,QAAQ,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;oBAClE,CAAC;iBACJ,CAAC,CAAC;YACP,CAAC,CAAC,CAAC;SACN;QAED,OAAO,KAAK,CAAC;IACjB,CAAC;IArBqB,iBAAU,aAqB/B,CAAA;IAED,SAAS,sBAAsB;QAC3B,IAAK,UAAkB,CAAC,kBAAkB,EAAE;YACxC,OAAO,CAAE,UAAkB,CAAC,kBAAkB,CAAC,CAAC;SACnD;QAED,QAAQ,OAAO,CAAC,QAAQ,EAAE;YACtB,KAAK,OAAO;gBACR,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC,iBAAiB,CAAC,CAAC;YACnE,KAAK,SAAS;gBACV,OAAO,CAAC,kBAAkB,CAAC,CAAC;YAChC,KAAK,QAAQ;gBACT,OAAO,CAAC,gBAAgB,EAAE,oBAAoB,CAAC,CAAC;SACvD;QAED,KAAK,CAAC,GAAG,OAAO,CAAC,QAAQ,uBAAuB,CAAC,CAAC;IACtD,CAAC;AACL,CAAC,EAhDS,MAAM,KAAN,MAAM,QAgDf;AChDD,IAAU,MAAM,CA8Bf;AA9BD,WAAU,MAAM;IACZ,iFAAiF;IAC1E,KAAK,UAAU,OAAO,CAAI,KAA2B,EAAE,OAA0C,MAAM;QAC1G,IAAI;YACA,MAAM,cAAc,GAAG,MAAM,OAAA,UAAU,CAAC,IAAI,IAAI,MAAM,CAAC,CAAC;YAExD,IAAI,IAAI,IAAI,MAAM,IAAI,CAAC,cAAc,EAAE;gBACnC,OAAO,OAAO,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,MAAM,CAAC,CAAC;aACnE;YAED,IAAI,MAAM,GAAG,MAAM,CAAC,aAAa,CAAC;YAClC,MAAM,eAAe,GAAG,MAAM,IAAI,IAAI,CAAC;YACvC,MAAM,KAAK,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC;YAElC,MAAM,MAAM,GAAG,KAAK,EAAE,CAAC;YAEvB,IAAI,eAAe,EAAE;gBACjB,IAAI,IAAI,IAAI,MAAM,EAAE;oBAChB,MAAM,CAAC,MAAM,EAAE,CAAC;iBACnB;qBAAM,IAAI,IAAI,IAAI,MAAM,EAAE;oBACvB,MAAM,CAAC,QAAQ,CAAC,UAAU,EAAE,GAAG,EAAE,CAAC,MAAO,CAAC,MAAM,EAAE,CAAC,CAAC;iBACvD;aACJ;YAED,OAAO,MAAM,YAAY,OAAO,CAAC,CAAC,CAAC,MAAM,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC;SAC5D;QAAC,OAAO,KAAU,EAAE;YACjB,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,kBAAkB;YAC7D,OAAO,OAAO,CAAC,MAAM,CAAI,KAAK,CAAC,CAAC;SACnC;IACL,CAAC;IA3BqB,cAAO,UA2B5B,CAAA;AACL,CAAC,EA9BS,MAAM,KAAN,MAAM,QA8Bf;AC9BD,IAAU,MAAM,CAuYf;AAvYD,WAAU,MAAM;IACZ,MAAa,MAAM;QACf,gBAAgB;QAChB,MAAM,GAAwB;YAC1B,KAAK,EAAE,CAAC;YACR,MAAM,EAAE,EAAE;YACV,OAAO,EAAE,IAAI,GAAG,EAAE;YAClB,KAAK,EAAE,GAAG,EAAE;gBACR,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,IAAI,CAAC,EAAE;oBACxB,MAAM,OAAO,GAAG,KAAK,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;oBAEvD,IAAI,IAAI,CAAC,QAAQ,EAAE;wBACf,MAAM,CAAC,OAAO,CAAC,CAAC;qBACnB;yBAAM;wBACH,MAAM,IAAI,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC;wBAC7B,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;4BAChC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;4BAC9B,MAAM,CAAC,OAAO,CAAC,CAAC;yBACnB;qBACJ;oBAED,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;iBACjC;YACL,CAAC;SACJ,CAAC;QAEF,gBAAgB;QAChB,SAAS,GAAW,MAAM,CAAC,UAAU,CAAC,EAAE,CAAC;QAEzC,gBAAgB;QAChB,QAAQ,GAAY,KAAK,CAAC;QAE1B,gBAAgB;QAChB,QAAQ,CAAsB;QAE9B,gBAAgB;QAChB,QAAQ,GAAoB,EAAE,CAAC;QAE/B,gBAAgB;QAChB,OAAO,CAAiB;QAExB,gBAAgB;QAChB,WAAW,CAAqB;QAEhC,gBAAgB;QAChB,QAAQ,CAAkB;QAE1B,gBAAgB;QAChB,QAAQ,CAAmB;QAE3B,gBAAgB;QAChB,eAAe,CAA0C;QAEzD,gBAAgB;QAChB,YAAY,CAAoC;QAEhD,gBAAgB;QAChB,aAAa,CAAsC;QAEnD,gBAAgB;QAChB,gBAAgB,CAA4C;QAE5D,YAAY,OAA4B;YACpC,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QAC5B,CAAC;QAED,MAAM;QACN,MAAM,CAAC,MAAqB;YACxB,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,EAAE,CAAC;YAC3B,OAAO,IAAI,CAAC;QAChB,CAAC;QAED,+CAA+C;QAC/C,OAAO,CAAC,KAAc;YAClB,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;YACtB,OAAO,IAAI,CAAC;QAChB,CAAC;QAED,iFAAiF;QACjF,MAAM;YACF,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC;YAC7B,OAAO,IAAI,CAAC;QAChB,CAAC;QAED,kFAAkF;QAClF,UAAU,CAAC,GAAG,UAA6B;YACvC,IAAI,CAAC,WAAW,GAAG,UAAU,CAAC;YAC9B,OAAO,IAAI,CAAC;QAChB,CAAC;QAED,+EAA+E;QAC/E,OAAO,CAAC,GAAG,OAAuB;YAC9B,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;YACxB,OAAO,IAAI,CAAC;QAChB,CAAC;QAED,uDAAuD;QACvD,OAAO,CAAC,GAAG,OAAwB;YAC/B,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;YACxB,OAAO,IAAI,CAAC;QAChB,CAAC;QAED,+DAA+D;QAC/D,gBAAgB,CAAC,MAA8C;YAC3D,IAAI,CAAC,eAAe,GAAG,MAAM,CAAC;YAC9B,OAAO,IAAI,CAAC;QAChB,CAAC;QAED,4DAA4D;QAC5D,aAAa,CAAC,MAAwC;YAClD,IAAI,CAAC,YAAY,GAAG,MAAM,CAAC;YAC3B,OAAO,IAAI,CAAC;QAChB,CAAC;QAED,kCAAkC;QAClC,aAAa,CAAC,MAA0C;YACpD,IAAI,CAAC,aAAa,GAAG,MAAM,CAAC;YAC5B,OAAO,IAAI,CAAC;QAChB,CAAC;QAED,kCAAkC;QAClC,gBAAgB,CAAC,MAAgD;YAC7D,IAAI,CAAC,gBAAgB,GAAG,MAAM,CAAC;YAC/B,OAAO,IAAI,CAAC;QAChB,CAAC;QAED,iEAAiE;QACjE,GAAG;YACC,MAAM,YAAY,GAAG,CAAC,MAAqB,EAAQ,EAAE;gBACjD,IAAI,IAAI,CAAC,gBAAgB,IAAI,SAAS,EAAE;oBACpC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;oBAC3B,OAAO;iBACV;gBAED,KAAK,MAAM,SAAS,IAAI,MAAM,CAAC,UAAU,EAAE;oBACvC,IAAI,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,EAAE;wBAClC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;wBAC3B,MAAM;qBACT;iBACJ;YACL,CAAC,CAAC;YAEF,MAAM,aAAa,GAAG,CAAC,MAA+B,EAAQ,EAAE;gBAC5D,KAAK,MAAM,MAAM,IAAI,MAAM,EAAE;oBACzB,YAAY,CAAC,MAAM,CAAC,CAAC;iBACxB;YACL,CAAC,CAAC;YAEF,MAAM,WAAW,GAAG,CAAC,KAAmB,EAAQ,EAAE;gBAC9C,IAAI,IAAI,CAAC,aAAa,IAAI,SAAS,EAAE;oBACjC,aAAa,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;oBAC7B,OAAO;iBACV;gBAED,KAAK,MAAM,MAAM,IAAI,KAAK,CAAC,OAAO,EAAE;oBAChC,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,EAAE;wBAC5B,YAAY,CAAC,MAAM,CAAC,CAAC;qBACxB;iBACJ;YACL,CAAC,CAAC;YAEF,MAAM,aAAa,GAAG,CAAC,MAA8B,EAAQ,EAAE;gBAC3D,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;oBACxB,WAAW,CAAC,KAAK,CAAC,CAAC;iBACtB;YACL,CAAC,CAAC;YAEF,MAAM,cAAc,GAAG,CAAC,QAAyB,EAAQ,EAAE;gBACvD,IAAI,IAAI,CAAC,YAAY,IAAI,SAAS,EAAE;oBAChC,aAAa,CAAC,QAAQ,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;oBACtC,OAAO;iBACV;gBAED,KAAK,MAAM,KAAK,IAAI,QAAQ,CAAC,KAAK,CAAC,OAAO,EAAE;oBACxC,IAAI,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,EAAE;wBAC1B,WAAW,CAAC,KAAK,CAAC,CAAC;qBACtB;iBACJ;YACL,CAAC,CAAC;YAEF,MAAM,gBAAgB,GAAG,CAAC,UAAqC,EAAQ,EAAE;gBACrE,KAAK,MAAM,QAAQ,IAAI,UAAU,EAAE;oBAC/B,cAAc,CAAC,QAAQ,CAAC,CAAC;iBAC5B;YACL,CAAC,CAAC;YAEF,MAAM,YAAY,GAAG,CAAC,MAAqB,EAAQ,EAAE;gBACjD,IAAI,IAAI,CAAC,eAAe,IAAI,SAAS,EAAE;oBACnC,gBAAgB,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;oBACpC,OAAO;iBACV;gBAED,KAAK,MAAM,QAAQ,IAAI,MAAM,CAAC,UAAU,EAAE;oBACtC,IAAI,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,EAAE;wBAChC,cAAc,CAAC,QAAQ,CAAC,CAAC;qBAC5B;iBACJ;YACL,CAAC,CAAC;YAEF,IAAI,CAAC,QAAQ;gBACT,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC;gBAC9B,CAAC,CAAC,IAAI,CAAC,QAAQ;oBACf,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC;oBAC9B,CAAC,CAAC,IAAI,CAAC,WAAW;wBAClB,CAAC,CAAC,gBAAgB,CAAC,IAAI,CAAC,WAAW,CAAC;wBACpC,CAAC,CAAC,IAAI,CAAC,OAAO;4BACd,CAAC,CAAC,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC;4BAC5B,CAAC,CAAC,SAAS,CAAC;YAEhB,IAAI,CAAC,WAAW,GAAG,SAAS,CAAC;YAC7B,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC;YAC1B,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC;YAC1B,IAAI,CAAC,eAAe,GAAG,SAAS,CAAC;YACjC,IAAI,CAAC,YAAY,GAAG,SAAS,CAAC;YAC9B,IAAI,CAAC,aAAa,GAAG,SAAS,CAAC;YAC/B,IAAI,CAAC,gBAAgB,GAAG,SAAS,CAAC;YAElC,OAAO,IAAI,CAAC;QAChB,CAAC;QAED,sBAAsB;QACtB,MAAM;YACF,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,QAAQ,EAAE;gBAChC,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,EAAE;oBACjC,IAAI;wBACA,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;qBACtD;oBAAC,OAAO,CAAM,EAAE;wBACb,QAAQ,CAAC,CAAC,OAAO,EAAE;4BACf,KAAK,wDAAwD,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,EAAE,KAAK,CAAC;4BACrF,KAAK,gCAAgC;gCACjC,MAAM;4BACV;gCACI,MAAM,CAAC,CAAC;yBACf;qBACJ;iBACJ;aACJ;QACL,CAAC;KACJ;IA7OY,aAAM,SA6OlB,CAAA;IAyBD,MAAM;IACN,SAAgB,KAAK,CAAC,aAAsB,KAAK;QAC7C,MAAM,OAAO,GAAG,GAAwB,EAAE,CAAC,CAAC,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,EAAE;YACnE,MAAM,oBAAoB,GAAG,MAAM,CAAC,sBAAsB,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;YAEzF,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC,cAAc,EAAE;gBACtC,OAAO;oBACH,IAAI,IAAI,CAAC,QAAQ,IAAI,QAAQ,EAAE;wBAC3B,kBAAkB;wBAClB,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,YAAY,oBAAoB,WAAW,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC,aAAa,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,YAAY,MAAM,CAAC,IAAI,gBAAgB,CAAC,CAAC;qBACtK;gBACL,CAAC;gBACD,OAAO;oBACH,IAAI,IAAI,CAAC,QAAQ,IAAI,QAAQ,EAAE;wBAC3B,kBAAkB;wBAClB,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,YAAY,oBAAoB,WAAW,IAAI,CAAC,MAAM,CAAC,EAAE,KAAK,CAAC,KAAK,CAAC,aAAa,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,YAAY,MAAM,CAAC,IAAI,gBAAgB,CAAC,CAAC;wBACnK,KAAK,CAAC,KAAK,EAAE,CAAC;qBACjB;gBACL,CAAC;aACJ,CAAC,CAAC;QACP,CAAC,CAAC;QAEF,MAAM,qBAAqB,GAAG,GAAwB,EAAE,CAAC,CAAC,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,EAAE;YACjF,MAAM,oBAAoB,GAAG,MAAM,CAAC,sBAAsB,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;YAEzF,MAAM,UAAU,GAAG,CAAC,CAAC,MAAM,CAAC,QAAQ,GAAG,CAAC,MAAM,CAAC,yBAAyB,CAAC;YAEzE,MAAM,QAAQ,GAAG,UAAqD,GAAG,IAAW;gBAChF,IAAK,IAA0B,CAAC,QAAQ,IAAI,QAAQ,EAAE;oBAClD,MAAM,aAAa,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC,SAAS,CAAC,MAAM,EAAE,CAAC,CAAC,EAAE,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;oBACxG,MAAM,UAAU,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC;oBAEjG,kBAAkB;oBAClB,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,YAAY,oBAAoB,WAAW,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC,aAAa,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,YAAY,MAAM,CAAC,IAAI,kBAAkB,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,WAAW,CAAC,CAAC,IAAI,qBAAqB,OAAA,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,GAAG,UAAU,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;iBAC/S;gBAED,MAAM,WAAW,GAAG,MAAM,CAAC,cAAc,CAAC,GAAG,IAAI,CAAC,CAAC;gBAEnD,IAAK,IAA0B,CAAC,QAAQ,IAAI,QAAQ,EAAE;oBAClD,kBAAkB;oBAClB,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,YAAY,oBAAoB,WAAW,IAAI,CAAC,MAAM,CAAC,EAAE,KAAK,CAAC,KAAK,CAAC,aAAa,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,YAAY,MAAM,CAAC,IAAI,iBAAiB,WAAW,IAAI,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,cAAc,OAAA,cAAc,CAAC,WAAW,EAAE,MAAM,CAAC,UAAU,CAAC,EAAE,SAAS,CAAC,CAAC;oBAC3Q,KAAK,CAAC,KAAK,EAAE,CAAC;iBACjB;gBAED,OAAO,WAAW,CAAC;YACvB,CAAC,CAAC;YAEF,MAAM,CAAC,MAAM,EAAE,CAAC;YAChB,MAAM,cAAc,GAAG,IAAI,cAAc,CAAC,QAAQ,EAAE,MAAM,CAAC,UAAU,CAAC,UAAU,EAAE,MAAM,CAAC,cAAc,CAAC,CAAC;YACzG,WAAW,CAAC,OAAO,CAAC,MAAM,CAAC,cAAc,EAAE,cAAc,CAAC,CAAC;QAC/D,CAAC,CAAC;QAEF,OAAO,IAAI,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,qBAAqB,EAAE,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC;IAC/E,CAAC;IApDe,YAAK,QAoDpB,CAAA;IAED,MAAM;IACN,SAAgB,SAAS,CAAC,IAAiB;QACvC,MAAM,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,UAAU;aACnC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;aAC7F,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC,cAAc,CAAC,OAAO,CAAC,EAAE,CAAC,cAAc,CAAC,CAAC,CAAC;QAElE,MAAM,YAAY,GAAG,CAAC,MAAqB,EAAiB,EAAE;YAC1D,IAAI,IAAI,GAAG,CAAC,CAAC;YACb,IAAI,KAAK,GAAG,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC;YAE/B,OAAO,IAAI,IAAI,KAAK,EAAE;gBAClB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;gBAC7C,MAAM,UAAU,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC,cAAc,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;gBAEjE,IAAI,UAAU,IAAI,CAAC,EAAE;oBACjB,OAAO,OAAO,CAAC,KAAK,CAAC,CAAC;iBACzB;qBAAM,IAAI,UAAU,GAAG,CAAC,EAAE;oBACvB,KAAK,GAAG,KAAK,GAAG,CAAC,CAAC;iBACrB;qBAAM;oBACH,IAAI,GAAG,KAAK,GAAG,CAAC,CAAC;iBACpB;aACJ;YACD,OAAO,OAAO,CAAC,KAAK,CAAC,CAAC;QAC1B,CAAC,CAAC;QAEF,MAAM,OAAO,GAAG,GAAwB,EAAE,CAAC,CAAC,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,EAAE;YACnE,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC,cAAc,EAAE;gBACtC,IAAI,IAAI,CAAC,QAAQ,IAAI,QAAQ,EAAE;oBAC3B,MAAM,OAAO,GAAG,UAAU,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;oBAChE,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC;oBAEvC,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;wBAC1B,IAAI,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,EAAE;4BAC1G,MAAM,MAAM,GAAG,YAAY,CAAC,MAAM,CAAC,CAAC;4BAEpC,IAAI,MAAM,EAAE;gCACR,MAAM,MAAM,GAAG,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC;gCAEjD,IAAI,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE;oCAC3B,kBAAkB;oCAClB,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,YAAY,MAAM,CAAC,sBAAsB,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,oBAAoB,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,WAAW,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,YAAY,MAAM,CAAC,IAAI,SAAS,CAAC,CAAC;iCACvN;6BACJ;yBACJ;qBACJ;oBAED,KAAK,CAAC,KAAK,EAAE,CAAC;iBACjB;YACL,CAAC,CAAC,CAAC;QACP,CAAC,CAAC;QAEF,OAAO,IAAI,MAAM,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC,CAAC;IACxC,CAAC;IAnDe,gBAAS,YAmDxB,CAAA;IAED,oDAAoD;IACpD,SAAS,MAAM,CAAC,GAAW;QACvB,IAAI,EAAE,GAAG,UAAU,CAAC;QACpB,IAAI,EAAE,GAAG,UAAU,CAAC;QAEpB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACrC,EAAE,GAAG,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YACvB,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,EAAE,UAAU,CAAC,CAAC;YACpC,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,EAAE,UAAU,CAAC,CAAC;SACvC;QAED,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,UAAU,CAAC,CAAC;QAC7C,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,UAAU,CAAC,CAAC;QAE9C,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,UAAU,CAAC,CAAC;QAC7C,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,UAAU,CAAC,CAAC;QAE9C,OAAO,UAAU,GAAG,CAAC,OAAO,GAAG,EAAE,CAAC,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;IACpD,CAAC;AACL,CAAC,EAvYS,MAAM,KAAN,MAAM,QAuYf;ACvYD,IAAU,MAAM,CAmGf;AAnGD,WAAU,MAAM;IACZ,MAAa,KAAuD,SAAQ,YAAY;QACpF,qFAAqF;QAE9E,AAAP,MAAM,KAAK,UAAU;YACjB,OAAO,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC,YAAY,CAAC;QAC5D,CAAC;QAED,0EAA0E;QAC1E,IAAI,QAAQ;YACR,mEAAmE;YACnE,gEAAgE;YAChE,iEAAiE;YACjE,MAAM,KAAK,GAAG,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,MAAM,CAAe,aAAa,EAAE,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC;YAExF,kBAAkB;YAClB,MAAM,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,OAAO,EAAE,IAAI,GAAG,CAAC;gBACzD,KAAK,CAAC,8DAA8D,CAAC,CAAC;YAE1E,kBAAkB;YAClB,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,EAAE,UAAU,EAAE;gBACvC,OAAO,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;YACzE,CAAC,EAAE,IAAI,CAAC,CAAC;YAET,OAAO,IAAI,CAAC,QAAQ,CAAC;QACzB,CAAC;QAED,oEAAoE;QAEpE,IAAI,WAAW;YACX,OAAO,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,gBAAgB,CAAC;QACnD,CAAC;QAED,oEAAoE;QAEpE,IAAI,WAAW;YACX,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,QAAS,CAAC;QAClD,CAAC;QAED,oFAAoF;QAEpF,IAAI,MAAM;YACN,OAAO,MAAM,CAAC,GAAG,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;QAC3C,CAAC;QAED,yDAAyD;QAEzD,IAAI,MAAM;YACN,OAAO,IAAI,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACnC,CAAC;QAED,oEAAoE;QACpE,GAAG,CAAC,KAAa;YACb,IAAI,KAAK,GAAG,CAAC,IAAI,KAAK,IAAI,IAAI,CAAC,MAAM,EAAE;gBACnC,KAAK,CAAC,+BAA+B,KAAK,2BAA2B,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC;aACvF;YAED,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QACpC,CAAC;QAED,oEAAoE;QACpE,GAAG,CAAC,KAAa,EAAE,KAAQ;YACvB,IAAI,KAAK,GAAG,CAAC,IAAI,KAAK,IAAI,IAAI,CAAC,MAAM,EAAE;gBACnC,KAAK,CAAC,+BAA+B,KAAK,2BAA2B,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC;aACvF;YAED,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;QACpC,CAAC;QAED,MAAM;QACN,QAAQ;YACJ,OAAO,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,GAAG,CAAC;QAC9E,CAAC;QAED,gBAAgB;QAChB,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC;YACd,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAClC,MAAM,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;aAC9B;QACL,CAAC;KACJ;IAnDG;QADC,IAAI;4CAGJ;IAID;QADC,IAAI;4CAGJ;IAID;QADC,IAAI;uCAGJ;IAID;QADC,IAAI;uCAGJ;IA7CM;QADN,IAAI;iCAGJ;IALQ,YAAK,QA+EjB,CAAA;IAQD,gBAAgB;IAChB,SAAgB,KAAK,CAA8B,KAAmB,EAAE,gBAA8B;QAClG,MAAM,MAAM,GAAG,OAAO,gBAAgB,IAAI,QAAQ,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,gBAAgB,CAAC,MAAM,CAAC;QAChG,MAAM,KAAK,GAAG,IAAI,MAAM,CAAC,KAAK,CAAI,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC,CAAC;QAEtE,IAAI,UAAU,CAAC,KAAK,CAAC,OAAO,CAAC,gBAAgB,CAAC,EAAE;YAC5C,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC;SAC1C;QAED,OAAO,KAAK,CAAC;IACjB,CAAC;IATe,YAAK,QASpB,CAAA;AACL,CAAC,EAnGS,MAAM,KAAN,MAAM,QAmGf;ACnGD,IAAU,MAAM,CAwDf;AAxDD,WAAU,MAAM;IAEZ,IAAa,QAAQ,GAArB,MAAa,QAAS,SAAQ,YAAY;QACtC,uCAAuC;QACvC,IAAI,KAAK;YACL,IAAI,GAAG,GAAG;gBACN,OAAO,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC;YAC/D,CAAC,CAAC;YAEF,IAAI;gBACA,MAAM,CAAC,GAAG,CAAC,gBAAgB,CAAC;aAC/B;YAAC,OAAO,CAAC,EAAE;gBACR,GAAG,GAAG;oBACF,uEAAuE;oBACvE,mEAAmE;oBACnE,sEAAsE;oBACtE,mCAAmC;oBACnC,uDAAuD;oBACvD,oEAAoE;oBACpE,0EAA0E;oBAC1E,qEAAqE;oBACrE,sEAAsE;oBACtE,OAAO,IAAI,MAAM,CAAC,KAAK,CACnB,IAAI,CAAC,MAAM;yBACN,MAAM,CAAgB,SAAS,EAAE,CAAC,CAAC;yBACnC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;yBACjC,MAAM,CAAgB,YAAY,CAAC;yBACnC,MAAM,EAAE;yBACR,KAAK,CAAgB,OAAO,CAAC,CAAC,KAAK,CAC3C,CAAC;gBACN,CAAC,CAAC;aACL;YAED,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,SAAS,EAAE,OAAO,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;YAEtD,OAAO,IAAI,CAAC,KAAK,CAAC;QACtB,CAAC;QAED,sCAAsC;QAEtC,IAAI,IAAI;YACJ,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;QAC/C,CAAC;QAED,4DAA4D;QAE5D,IAAI,MAAM;YACN,KAAK,MAAM,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAA8B,eAAe,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE;gBACxG,IAAI,CAAC,CAAC,KAAK,CAAgB,gBAAgB,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE;oBAC7D,OAAO,CAAC,CAAC;iBACZ;aACJ;YAED,KAAK,CAAC,wDAAwD,CAAC,CAAC;QACpE,CAAC;KACJ,CAAA;IAfG;QADC,IAAI;wCAGJ;IAID;QADC,IAAI;0CASJ;IApDQ,QAAQ;QADpB,OAAO;OACK,QAAQ,CAqDpB;IArDY,eAAQ,WAqDpB,CAAA;AACL,CAAC,EAxDS,MAAM,KAAN,MAAM,QAwDf;ACxDD,IAAU,MAAM,CA8Uf;AA9UD,WAAU,MAAM;IAEZ,IAAa,KAAK,GAAlB,MAAa,KAAM,SAAQ,YAAY;QACnC,iEAAiE;QACjE,IAAI,kBAAkB;YAClB,MAAM,YAAY,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;YAE1D,kBAAkB;YAClB,MAAM,MAAM,GAAG,YAAY,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,OAAO,EAAE,IAAI,YAAY,CAAC,YAAY,GAAG,CAAC,CAAC;mBACvF,KAAK,CAAC,0EAA0E,CAAC,CAAC;YAEzF,kBAAkB;YAClB,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,EAAE,oBAAoB,EAAE;gBACjD,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,OAAO,EAAE,CAAC;YAC7C,CAAC,EAAE,IAAI,CAAC,CAAC;YAET,OAAO,IAAI,CAAC,kBAAkB,CAAC;QACnC,CAAC;QAED,8DAA8D;QAE9D,IAAI,UAAU;YACV,OAAO,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,kBAAkB,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC;QACpE,CAAC;QAED,0EAA0E;QAE1E,IAAI,gBAAgB;YAChB,OAAO,MAAM,CAAC,GAAG,CAAC,wBAAwB,CAAC,IAAI,CAAC,CAAC;QACrD,CAAC;QAED,2EAA2E;QAE3E,IAAI,YAAY;YACZ,OAAO,MAAM,CAAC,GAAG,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC,cAAc,EAAG,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;QACvF,CAAC;QAED,6DAA6D;QAE7D,IAAI,cAAc;YACd,OAAO,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,qBAAqB,CAAC,IAAI,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC;QACjF,CAAC;QAED,gFAAgF;QAEhF,IAAI,QAAQ;YACR,OAAO,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC;QAC3E,CAAC;QAED,gHAAgH;QAEhH,IAAI,YAAY;YACZ,OAAO,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC;QAChF,CAAC;QAED,4CAA4C;QAE5C,IAAI,MAAM;YACN,OAAO,kBAAkB,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,cAAc,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QACrG,CAAC;QAED,2CAA2C;QAE3C,IAAI,KAAK;YACL,OAAO,MAAM,CAAC,GAAG,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAC1C,CAAC;QAED,kEAAkE;QAElE,IAAI,QAAQ;YACR,OAAO,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;QACzE,CAAC;QAED,0DAA0D;QAE1D,IAAI,QAAQ;YACR,IAAI,CAAC,IAAI,CAAC,SAAS,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;gBACrC,OAAO,EAAE,CAAC;aACb;YAED,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAA8B,qBAAqB,CAAC,CAAC,MAAM,EAAE,CAAC;YACnG,OAAO,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAClG,CAAC;QAED,wFAAwF;QAExF,IAAI,aAAa;YACb,OAAO,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;QACjD,CAAC;QAED,4EAA4E;QAE5E,IAAI,oBAAoB;YACpB,MAAM,iBAAiB,GAAG,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;YACnD,OAAO,iBAAiB,IAAI,IAAI,IAAI,CAAC,iBAAiB,CAAC,cAAc,CAAC,MAAM,EAAE,CAAC;QACnF,CAAC;QAED,4DAA4D;QAE5D,IAAI,KAAK;YACL,OAAO,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC;QAC5D,CAAC;QAED,0DAA0D;QAE1D,IAAI,YAAY;YACZ,OAAO,MAAM,CAAC,GAAG,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC;QACjD,CAAC;QAED,wDAAwD;QAExD,IAAI,UAAU;YACV,OAAO,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;QAC9C,CAAC;QAED,yDAAyD;QAEzD,IAAI,WAAW;YACX,OAAO,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;QAC/C,CAAC;QAED,8DAA8D;QAE9D,IAAI,MAAM;YACN,OAAO,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QAC1C,CAAC;QAED,6DAA6D;QAE7D,IAAI,SAAS;YACT,OAAO,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;QAC7C,CAAC;QAED,wDAAwD;QAExD,IAAI,UAAU;YACV,OAAO,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;QAC9C,CAAC;QAED,4DAA4D;QAE5D,IAAI,WAAW;YACX,OAAO,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;QAC/C,CAAC;QAED,wDAAwD;QACxD,IAAI,QAAQ;YACR,OAAO,IAAI,CAAC,WAAW,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;QAC5C,CAAC;QAED,4DAA4D;QAE5D,IAAI,WAAW;YACX,OAAO,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;QAC/C,CAAC;QAED,yEAAyE;QAEzE,IAAI,UAAU;YACV,OAAO,kBAAkB,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,kBAAkB,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QACzG,CAAC;QAED,yDAAyD;QAEzD,IAAI,OAAO;YACP,OAAO,kBAAkB,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,eAAe,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;QACvG,CAAC;QAED,0CAA0C;QAE1C,IAAI,IAAI;YACJ,OAAO,MAAM,CAAC,GAAG,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,cAAc,EAAG,CAAC;QAC3D,CAAC;QAED,+CAA+C;QAE/C,IAAI,SAAS;YACT,OAAO,MAAM,CAAC,GAAG,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC,cAAc,EAAG,CAAC;QAChE,CAAC;QAED,wDAAwD;QAExD,IAAI,aAAa;YACb,OAAO,kBAAkB,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,qBAAqB,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QAC5G,CAAC;QAED,qEAAqE;QAErE,IAAI,MAAM;YACN,OAAO,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC;QAC1E,CAAC;QAED,uEAAuE;QAEvE,IAAI,IAAI;YACJ,IAAI,IAAI,GAAG,CAAC,CAAC;YACb,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;YAEvB,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;gBAC3C,MAAM,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBAElB,IAAI,CAAC,IAAI,GAAG;oBAAE,IAAI,EAAE,CAAC;qBAChB,IAAI,CAAC,IAAI,GAAG,IAAI,IAAI,IAAI,CAAC;oBAAE,MAAM;qBACjC,IAAI,CAAC,IAAI,GAAG;oBAAE,IAAI,EAAE,CAAC;;oBACrB,MAAM;aACd;YAED,OAAO,IAAI,CAAC;QAChB,CAAC;QAED,gEAAgE;QAEhE,IAAI,gBAAgB;YAChB,OAAO,MAAM,CAAC,GAAG,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC;QACpD,CAAC;QAED,8EAA8E;QAE9E,IAAI,aAAa;YACb,OAAO,MAAM,CAAC,GAAG,CAAC,qBAAqB,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QACxD,CAAC;QAED,0CAA0C;QAE1C,IAAI,IAAI;YACJ,OAAO,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC;QAC1D,CAAC;QAED,mDAAmD;QACnD,KAAK;YACD,OAAO,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;QACzD,CAAC;QAED,mDAAmD;QACnD,KAAK,CAA8B,IAAY;YAC3C,OAAO,IAAI,CAAC,QAAQ,CAAI,IAAI,CAAC,IAAI,KAAK,CAAC,uBAAuB,IAAI,aAAa,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;QACrG,CAAC;QAED,8DAA8D;QAC9D,OAAO,CAAC,GAAG,OAAuB;YAC9B,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;gBACjB,KAAK,CAAC,wBAAwB,IAAI,CAAC,IAAI,CAAC,IAAI,kCAAkC,CAAC,CAAC;aACnF;YAED,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,IAAI,OAAO,CAAC,MAAM,EAAE;gBACxC,KAAK,CAAC,wBAAwB,IAAI,CAAC,IAAI,CAAC,IAAI,gBAAgB,IAAI,CAAC,QAAQ,CAAC,MAAM,8BAA8B,OAAO,CAAC,MAAM,EAAE,CAAC,CAAC;aACnI;YAED,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAC9C,MAAM,SAAS,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,aAAa,CAAC,EAAE,KAAK,CAAC,CAAC;YAE1E,MAAM,YAAY,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAgB,iBAAiB,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;YACpG,OAAO,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,eAAe,CAAC,YAAY,CAAC,CAAC,CAAC;QACtE,CAAC;QAED,yDAAyD;QACzD,UAAU;YACN,MAAM,CAAC,GAAG,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;YACjC,OAAO,IAAI,CAAC;QAChB,CAAC;QAED,yGAAyG;QACzG,gBAAgB,CAAC,KAAmB;YAChC,OAAO,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,qBAAqB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAC3D,CAAC;QAED,uEAAuE;QACvE,YAAY,CAAC,KAAmB,EAAE,eAAwB;YACtD,OAAO,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,iBAAiB,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,eAAe,CAAC,CAAC;QACzE,CAAC;QAED,wEAAwE;QACxE,MAAM,CAAqC,IAAY,EAAE,iBAAyB,CAAC,CAAC;YAChF,OAAO,IAAI,CAAC,SAAS,CAAI,IAAI,EAAE,cAAc,CAAC,IAAI,KAAK,CAAC,wBAAwB,IAAI,aAAa,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;QACvH,CAAC;QAED,iDAAiD;QACjD,MAAM,CAAC,IAAY;YACf,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,8BAA8B,IAAI,aAAa,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;QAC1G,CAAC;QAED,qFAAqF;QACrF,GAAG;YACC,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC;YAE5B,MAAM,cAAc,GAAG,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;YAEzD,MAAM,CAAC,GAAG,CAAC,gBAAgB,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;YAEpD,MAAM,SAAS,GAAG,cAAc,CAAC,WAAW,EAAE,CAAC;YAE/C,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,EAAE;gBACrB,KAAK,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC;aAClD;YAED,OAAO,MAAM,CAAC;QAClB,CAAC;QAED,0CAA0C;QAC1C,QAAQ,CAA8B,IAAY;YAC9C,OAAO,IAAI,MAAM,CAAC,KAAK,CAAI,MAAM,CAAC,GAAG,CAAC,qBAAqB,CAAC,IAAI,EAAE,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC;QAClH,CAAC;QAED,+DAA+D;QAC/D,SAAS,CAAqC,IAAY,EAAE,iBAAyB,CAAC,CAAC;YACnF,OAAO,IAAI,MAAM,CAAC,MAAM,CAAI,MAAM,CAAC,GAAG,CAAC,sBAAsB,CAAC,IAAI,EAAE,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,EAAE,cAAc,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC;QACpI,CAAC;QAED,iDAAiD;QACjD,SAAS,CAAC,IAAY;YAClB,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC;QACxD,CAAC;QAED,MAAM;QACN,QAAQ;YACJ,MAAM,SAAS,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YAExD,OAAO;KACd,IAAI,CAAC,YAAY;EACpB,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,OAAO;EAC1F,IAAI,CAAC,IAAI,CAAC,IAAI;EACd,SAAS,CAAC,CAAC,CAAC,MAAM,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE;;MAEhE,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;MAC1B,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC;EAC/B,CAAC;QACK,CAAC;QAED,mDAAmD;QACnD,MAAM,CAAC,SAAS,CAAC,KAAoC;YACjD,MAAM,QAAQ,GAAG,IAAI,cAAc,CAAC,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,MAAM,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;YACrG,OAAO,MAAM,CAAC,GAAG,CAAC,YAAY,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;QACnD,CAAC;KACJ,CAAA;IAxTG;QADC,IAAI;2CAGJ;IAID;QADC,IAAI;iDAGJ;IAID;QADC,IAAI;6CAGJ;IAID;QADC,IAAI;+CAGJ;IAID;QADC,IAAI;yCAGJ;IAID;QADC,IAAI;6CAGJ;IAID;QADC,IAAI;uCAGJ;IAID;QADC,IAAI;sCAGJ;IAID;QADC,IAAI;yCAGJ;IAID;QADC,IAAI;yCAQJ;IAID;QADC,IAAI;8CAGJ;IAID;QADC,IAAI;qDAIJ;IAID;QADC,IAAI;sCAGJ;IAID;QADC,IAAI;6CAGJ;IAID;QADC,IAAI;2CAGJ;IAID;QADC,IAAI;4CAGJ;IAID;QADC,IAAI;uCAGJ;IAID;QADC,IAAI;0CAGJ;IAID;QADC,IAAI;2CAGJ;IAID;QADC,IAAI;4CAGJ;IASD;QADC,IAAI;4CAGJ;IAID;QADC,IAAI;2CAGJ;IAID;QADC,IAAI;wCAGJ;IAID;QADC,IAAI;qCAGJ;IAID;QADC,IAAI;0CAGJ;IAID;QADC,IAAI;8CAGJ;IAID;QADC,IAAI;uCAGJ;IAID;QADC,IAAI;qCAeJ;IAID;QADC,IAAI;iDAGJ;IAID;QADC,IAAI;8CAGJ;IAID;QADC,IAAI;qCAGJ;IAhOQ,KAAK;QADjB,OAAO;OACK,KAAK,CA2UjB;IA3UY,YAAK,QA2UjB,CAAA;AACL,CAAC,EA9US,MAAM,KAAN,MAAM,QA8Uf;AC9UD,IAAU,MAAM,CAkCf;AAlCD,WAAU,MAAM;IACZ,6DAA6D;IAC7D,SAAgB,QAAQ,CACpB,KAAmB,EACnB,KAAwB;QAExB,MAAM,cAAc,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC;QAC9D,MAAM,uBAAuB,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,0BAA0B,CAAC,CAAC;QAEhF,IAAI,CAAC,cAAc,CAAC,gBAAgB,CAAC,KAAK,CAAC,EAAE;YACzC,KAAK,CAAC,gCAAgC,KAAK,CAAC,IAAI,CAAC,IAAI,+BAA+B,CAAC,CAAC;SACzF;QAED,IAAI,KAAK,CAAC,MAAM,CAAC,cAAc,CAAC,IAAI,KAAK,CAAC,MAAM,CAAC,uBAAuB,CAAC,EAAE;YACvE,KAAK,CAAC,wCAAwC,cAAc,CAAC,IAAI,CAAC,IAAI,QAAQ,uBAAuB,CAAC,IAAI,CAAC,IAAI,0BAA0B,CAAC,CAAC;SAC9I;QAED,MAAM,QAAQ,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC;QAC/B,MAAM,GAAG,GAAG,QAAQ,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC;QAEvC,MAAM,MAAM,GAAG,QAAQ,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,KAAK,CAAC,gCAAgC,KAAK,CAAC,IAAI,CAAC,IAAI,6BAA6B,CAAC,CAAC;QACnI,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,QAAQ,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC;QAEzD,MAAM,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,KAAY,CAAC,CAAC;QAE3C,QAAQ,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,KAAK,GAAG,QAAQ,CAAC;QAC9C,QAAQ,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC,KAAK,GAAG,QAAQ,CAAC;QAC/C,OAAA,qBAAqB,CAAC,GAAG,CAAC,GAAG,QAAQ,CAAC;QAEtC,OAAO,QAAQ,CAAC;IACpB,CAAC;IA5Be,eAAQ,WA4BvB,CAAA;IAED,kFAAkF;IACrE,4BAAqB,GAA2D,EAAE,CAAC;AACpG,CAAC,EAlCS,MAAM,KAAN,MAAM,QAkCf;AClCD,IAAU,MAAM,CA4Cf;AA5CD,WAAU,MAAM;IAEZ,IAAa,MAAM,GAAnB,MAAa,MAAO,SAAQ,YAAY;QACpC,sGAAsG;QAEtG,IAAI,UAAU;YACV,IAAI,OAAO,GAAG,cAAc,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,mBAAmB,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC;YAE3E,IAAI,OAAO,CAAC,MAAM,IAAI,CAAC,EAAE;gBACrB,MAAM,eAAe,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAA8B,eAAe,CAAC,CAAC,QAAQ,EAAE,CAAC,MAAM,EAAE,CAAC;gBAC7G,OAAO,GAAG,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAgB,gBAAgB,CAAC,CAAC,KAAK,CAAC,CAAC;aAC7G;YAED,OAAO,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;QACpD,CAAC;QAED,8DAA8D;QAE9D,IAAI,MAAM;YACN,OAAO,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAC,MAAM,CAAgB,mBAAmB,CAAC,CAAC,MAAM,EAAE,CAAC;QACvG,CAAC;QAED,wDAAwD;QACxD,QAAQ,CAAC,IAAY;YACjB,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,0BAA0B,IAAI,EAAE,CAAC,CAAC;QAC7E,CAAC;QAED,uDAAuD;QACvD,MAAM;YACF,OAAO,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC;QAC5D,CAAC;QAED,wDAAwD;QACxD,WAAW,CAAC,IAAY;YACpB,OAAO,IAAI,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,yBAAyB,CAAC,IAAI,EAAE,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC;QACtH,CAAC;KACJ,CAAA;IA/BG;QADC,IAAI;4CAUJ;IAID;QADC,IAAI;wCAGJ;IAlBQ,MAAM;QADlB,OAAO;OACK,MAAM,CAkClB;IAlCY,aAAM,SAkClB,CAAA;IAID,kBAAkB;IAClB,MAAM,CAAC,MAAM,EAAE,QAAQ,EAAE,GAAG,EAAE;QAC1B,OAAO,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,CAAC;IACrD,CAAC,EAAE,IAAI,CAAC,CAAC;AACb,CAAC,EA5CS,MAAM,KAAN,MAAM,QA4Cf;AC5CD,IAAU,MAAM,CAgLf;AAhLD,WAAU,MAAM;IACZ,MAAa,KAAuD,SAAQ,YAAY;QACpF,qDAAqD;QAErD,IAAI,KAAK;YACL,OAAO,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC;QAC5D,CAAC;QAED,2CAA2C;QAE3C,IAAI,KAAK;YACL,OAAO,MAAM,CAAC,GAAG,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAC1C,CAAC;QAED,oEAAoE;QAEpE,IAAI,SAAS;YACT,OAAO,CAAC,IAAI,CAAC,KAAK,2CAAkC,CAAC,IAAI,CAAC,CAAC;QAC/D,CAAC;QAED,+CAA+C;QAE/C,IAAI,QAAQ;YACR,OAAO,CAAC,IAAI,CAAC,KAAK,0CAAiC,CAAC,IAAI,CAAC,CAAC;QAC9D,CAAC;QAED,sDAAsD;QAEtD,IAAI,cAAc;YACd,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAC,KAAK,CAAC,0BAA0B,CAAC,CAAC,MAAM,CAAC;YAEhG,kBAAkB;YAClB,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,SAAS,EAAE,gBAAgB,EAAE;gBAC7C,OAAO,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC;YACjC,CAAC,EAAE,IAAI,CAAC,CAAC;YAET,OAAO,IAAI,CAAC,cAAc,CAAC;QAC/B,CAAC;QAED,8CAA8C;QAE9C,IAAI,QAAQ;YACR,QAAQ,IAAI,CAAC,KAAK,kDAA0C,EAAE;gBAC1D;oBACI,OAAO,SAAS,CAAC;gBACrB;oBACI,OAAO,mBAAmB,CAAC;gBAC/B;oBACI,OAAO,UAAU,CAAC;gBACtB;oBACI,OAAO,WAAW,CAAC;gBACvB;oBACI,OAAO,oBAAoB,CAAC;gBAChC;oBACI,OAAO,QAAQ,CAAC;aACvB;QACL,CAAC;QAED,mCAAmC;QAEnC,IAAI,IAAI;YACJ,OAAO,MAAM,CAAC,GAAG,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,cAAc,EAAG,CAAC;QAC3D,CAAC;QAED,kGAAkG;QAElG,IAAI,MAAM;YACN,OAAO,MAAM,CAAC,GAAG,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;QAC3C,CAAC;QAED,mCAAmC;QAEnC,IAAI,IAAI;YACJ,OAAO,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC;QAC1D,CAAC;QAED,oCAAoC;QACpC,IAAI,KAAK;YACL,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;gBAChB,KAAK,CAAC,gCAAgC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,sCAAsC,CAAC,CAAC;aACnH;YAED,MAAM,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;YACjD,MAAM,CAAC,GAAG,CAAC,mBAAmB,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;YAEpD,OAAO,OAAA,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,CAAM,CAAC;QACxC,CAAC;QAED,2FAA2F;QAC3F,IAAI,KAAK,CAAC,KAAQ;YACd,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;gBAChB,KAAK,CAAC,gCAAgC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,sCAAsC,CAAC,CAAC;aACnH;YAED,IAAI,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,SAAS,EAAE;gBACvC,KAAK,CAAC,mCAAmC,IAAI,CAAC,IAAI,mCAAmC,CAAC,CAAC;aAC1F;YAED,MAAM,MAAM;YACR,wDAAwD;YACxD,0DAA0D;YAC1D,KAAK,YAAY,MAAM,CAAC,MAAM,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW;gBACzD,CAAC,CAAC,KAAK,CAAC,KAAK,EAAE;gBACf,CAAC,CAAC,KAAK,YAAY,YAAY;oBAC/B,CAAC,CAAC,KAAK,CAAC,MAAM;oBACd,CAAC,CAAC,KAAK,YAAY,aAAa;wBAChC,CAAC,CAAC,KAAK;wBACP,CAAC,CAAC,OAAA,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;YAE/E,MAAM,CAAC,GAAG,CAAC,mBAAmB,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;QACxD,CAAC;QAED,MAAM;QACN,QAAQ;YACJ,OAAO;EACjB,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,iBAAiB,CAAC,CAAC,CAAC,EAAE;EAC5C,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE;EAC9B,IAAI,CAAC,IAAI,CAAC,IAAI;EACd,IAAI,CAAC,IAAI;EACT,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,OAAA,IAAI,CAAE,IAAI,CAAC,KAA0B,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,QAAS,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,EAAE;EAC5I,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,SAAS,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;QAC7E,CAAC;QAED,gBAAgB;QAChB,UAAU,CAAC,QAA0C;YACjD,IAAI,IAAI,CAAC,QAAQ,EAAE;gBACf,KAAK,CAAC,8BAA8B,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,sCAAsC,CAAC,CAAC;aACjH;YAED,MAAM,WAAW,GAAG,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,QAAQ,YAAY,MAAM,CAAC,SAAS,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAE7H,OAAO,IAAI,KAAK,CAAC,IAAI,EAAE;gBACnB,GAAG,CAAC,MAAuB,EAAE,QAA4B;oBACrD,IAAI,QAAQ,IAAI,OAAO,EAAE;wBACrB,OAAO,OAAA,IAAI,CAAC,WAAW,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC;qBACzC;oBACD,OAAO,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;gBACzC,CAAC;gBAED,GAAG,CAAC,MAAuB,EAAE,QAA4B,EAAE,KAAU;oBACjE,IAAI,QAAQ,IAAI,OAAO,EAAE;wBACrB,OAAA,KAAK,CAAC,WAAW,EAAE,KAAK,EAAE,MAAM,CAAC,IAAI,CAAC,CAAC;wBACvC,OAAO,IAAI,CAAC;qBACf;oBAED,OAAO,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,QAAQ,EAAE,KAAK,CAAC,CAAC;gBAChD,CAAC;aACJ,CAAC,CAAC;QACP,CAAC;KACJ;IAjJG;QADC,IAAI;sCAGJ;IAID;QADC,IAAI;sCAGJ;IAID;QADC,IAAI;0CAGJ;IAID;QADC,IAAI;yCAGJ;IAID;QADC,IAAI;+CAUJ;IAID;QADC,IAAI;yCAgBJ;IAID;QADC,IAAI;qCAGJ;IAID;QADC,IAAI;uCAGJ;IAID;QADC,IAAI;qCAGJ;IAzEQ,YAAK,QAoJjB,CAAA;AA2BL,CAAC,EAhLS,MAAM,KAAN,MAAM,QAgLf;AChLD,IAAU,MAAM,CAef;AAfD,WAAU,MAAM;IACZ,MAAa,QAAQ;QAEI;QADrB,gBAAgB;QAChB,YAAqB,MAAc;YAAd,WAAM,GAAN,MAAM,CAAQ;QAAG,CAAC;QAEvC,iDAAiD;QACjD,IAAI,MAAM;YACN,OAAO,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,iBAAiB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC;QACrF,CAAC;QAED,yBAAyB;QACzB,IAAI;YACA,OAAO,MAAM,CAAC,GAAG,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAChD,CAAC;KACJ;IAbY,eAAQ,WAapB,CAAA;AACL,CAAC,EAfS,MAAM,KAAN,MAAM,QAef;ACfD,IAAU,MAAM,CA8Df;AA9DD,WAAU,MAAM;IAEZ,IAAa,KAAK,GAAlB,MAAa,KAAM,SAAQ,YAAY;QACnC,+DAA+D;QAE/D,IAAI,QAAQ;YACR,OAAO,IAAI,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC;QAClE,CAAC;QAED,wDAAwD;QAExD,IAAI,UAAU;YACV,IAAI,MAAM,CAAC,yBAAyB,EAAE;gBAClC,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;aAC9B;iBAAM;gBACH,OAAO,MAAM,CAAC,GAAG,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;aAC9C;QACL,CAAC;QAED,8CAA8C;QAE9C,IAAI,OAAO;YACP,IAAI,MAAM,CAAC,yBAAyB,EAAE;gBAClC,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAA8B,UAAU,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;gBACjG,qEAAqE;gBACrE,qEAAqE;gBACrE,uCAAuC;gBACvC,MAAM,OAAO,GAAG,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACnG,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC;gBACxC,OAAO,OAAO,CAAC;aAClB;iBAAM;gBACH,OAAO,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;aAClI;QACL,CAAC;QAED,mCAAmC;QAEnC,IAAI,IAAI;YACJ,OAAO,MAAM,CAAC,GAAG,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,cAAc,EAAG,CAAC;QAC3D,CAAC;QAED,oEAAoE;QACpE,KAAK,CAAC,IAAY;YACd,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,uBAAuB,IAAI,gBAAgB,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;QAChG,CAAC;QAED,oEAAoE;QACpE,QAAQ,CAAC,IAAY;YACjB,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;YACvC,MAAM,cAAc,GAAG,MAAM,CAAC,eAAe,CAAC,QAAQ,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC;YAC7F,MAAM,SAAS,GAAG,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC;YAEnE,OAAO,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,aAAa,CAAC,IAAI,EAAE,cAAc,EAAE,SAAS,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC;QACpG,CAAC;KACJ,CAAA;IAjDG;QADC,IAAI;yCAGJ;IAID;QADC,IAAI;2CAOJ;IAID;QADC,IAAI;wCAaJ;IAID;QADC,IAAI;qCAGJ;IArCQ,KAAK;QADjB,OAAO;OACK,KAAK,CAoDjB;IApDY,YAAK,QAoDjB,CAAA;IAID,kBAAkB;IAClB,MAAM,CAAC,MAAM,EAAE,QAAQ,EAAE,GAAG,EAAE;QAC1B,OAAO,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,EAAE,CAAC,CAAC;IACpD,CAAC,EAAE,IAAI,CAAC,CAAC;AACb,CAAC,EA9DS,MAAM,KAAN,MAAM,QA8Df;AC9DD,IAAU,MAAM,CAsCf;AAtCD,WAAU,MAAM;IACZ,MAAa,cAAe,SAAQ,YAAY;QAC5C,kCAAkC;QAClC,MAAM,CAAC,OAAO;YACV,OAAO,IAAI,MAAM,CAAC,cAAc,EAAE,CAAC;QACvC,CAAC;QAED,uDAAuD;QACvD,YAAY,SAAwB,MAAM,CAAC,GAAG,CAAC,qBAAqB,EAAE;YAClE,KAAK,CAAC,MAAM,CAAC,CAAC;QAClB,CAAC;QAED,kCAAkC;QAElC,IAAI,OAAO;YACP,OAAO,kBAAkB,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,wBAAwB,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QAC/G,CAAC;QAED,wDAAwD;QAExD,IAAI,OAAO;YACP,kBAAkB;YAClB,OAAO,cAAc,CAAC,CAAC,CAAC,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,wBAAwB,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;QACrI,CAAC;QAED,kCAAkC;QAClC,IAAI;YACA,MAAM,CAAC,GAAG,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;QACxC,CAAC;KACJ;IAfG;QADC,IAAI;iDAGJ;IAID;QADC,IAAI;iDAIJ;IAtBQ,qBAAc,iBA4B1B,CAAA;IAED,MAAM;IACN,SAAgB,cAAc,CAAI,KAAiE;QAC/F,MAAM,cAAc,GAAG,MAAM,CAAC,cAAc,CAAC,OAAO,EAAE,CAAC;QACvD,MAAM,MAAM,GAAG,KAAK,CAAC,cAAc,CAAC,CAAC;QACrC,cAAc,CAAC,IAAI,EAAE,CAAC;QACtB,OAAO,MAAM,CAAC;IAClB,CAAC;IALe,qBAAc,iBAK7B,CAAA;AACL,CAAC,EAtCS,MAAM,KAAN,MAAM,QAsCf;ACtCD,IAAU,MAAM,CAyaf;AAzaD,WAAU,MAAM;IACZ,MAAa,MAAsE,SAAQ,YAAY;QACnG,sDAAsD;QAEtD,IAAI,KAAK;YACL,OAAO,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC;QAC7D,CAAC;QAED,4CAA4C;QAE5C,IAAI,KAAK;YACL,OAAO,MAAM,CAAC,GAAG,CAAC,cAAc,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QACjD,CAAC;QAED,2DAA2D;QAE3D,IAAI,mBAAmB;YACnB,MAAM,0BAA0B,GAAG,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;YACrE,MAAM,CAAC,GAAG,CAAC,cAAc,CAAC,IAAI,EAAE,0BAA0B,CAAC,CAAC;YAE5D,OAAO,0BAA0B,CAAC,OAAO,EAAE,CAAC;QAChD,CAAC;QAED,MAAM;QAEN,IAAI,cAAc;YACd,MAAM,KAAK,GAAiC,EAAE,CAAC;YAE/C,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,UAAU,EAAE;gBACrC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;aACzC;YAED,IAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,MAAM,CAAC,yBAAyB,EAAE;gBACpD,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;aAC5B;YAED,IAAI,IAAI,CAAC,UAAU,EAAE;gBACjB,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;aACzB;YAED,OAAO,KAAK,CAAC;QACjB,CAAC;QAED,0DAA0D;QAE1D,IAAI,QAAQ;YACR,IAAI,CAAC,IAAI,CAAC,SAAS,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;gBACrC,OAAO,EAAE,CAAC;aACb;YAED,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAA8B,qBAAqB,CAAC,CAAC,MAAM,EAAE,CAAC;YAC9F,OAAO,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAClG,CAAC;QAED,kDAAkD;QAElD,IAAI,UAAU;YACV,OAAO,CAAC,IAAI,CAAC,mBAAmB,gEAAqD,CAAC,IAAI,CAAC,CAAC;QAChG,CAAC;QAED,iDAAiD;QAEjD,IAAI,SAAS;YACT,OAAO,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;QAC9C,CAAC;QAED,2FAA2F;QAE3F,IAAI,UAAU;YACV,OAAO,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;QAC/C,CAAC;QAED,gDAAgD;QAEhD,IAAI,QAAQ;YACR,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;QAC9C,CAAC;QAED,sDAAsD;QAEtD,IAAI,cAAc;YACd,OAAO,CAAC,IAAI,CAAC,mBAAmB,8DAAqD,CAAC,IAAI,CAAC,CAAC;QAChG,CAAC;QAED,+CAA+C;QAE/C,IAAI,QAAQ;YACR,QAAQ,IAAI,CAAC,KAAK,oDAA4C,EAAE;gBAC5D;oBACI,OAAO,SAAS,CAAC;gBACrB;oBACI,OAAO,mBAAmB,CAAC;gBAC/B;oBACI,OAAO,UAAU,CAAC;gBACtB;oBACI,OAAO,WAAW,CAAC;gBACvB;oBACI,OAAO,oBAAoB,CAAC;gBAChC;oBACI,OAAO,QAAQ,CAAC;aACvB;QACL,CAAC;QAED,oCAAoC;QAEpC,IAAI,IAAI;YACJ,OAAO,MAAM,CAAC,GAAG,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,cAAc,EAAG,CAAC;QAC5D,CAAC;QAED,gBAAgB;QAEhB,IAAI,cAAc;YACd,OAAO,IAAI,cAAc,CAAC,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,UAAU,CAAC,UAAU,EAAE,IAAI,CAAC,cAA8C,CAAC,CAAC;QACpI,CAAC;QAED,0DAA0D;QAE1D,IAAI,MAAM;YACN,OAAO,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,eAAe,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;QACrE,CAAC;QAED,oDAAoD;QAEpD,IAAI,cAAc;YACd,OAAO,MAAM,CAAC,GAAG,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC;QACpD,CAAC;QAED,0CAA0C;QAE1C,IAAI,UAAU;YACV,OAAO,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;gBACzE,MAAM,aAAa,GAAG,MAAM,CAAC,GAAG,CAAC,sBAAsB,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,cAAc,EAAG,CAAC;gBACnF,MAAM,aAAa,GAAG,MAAM,CAAC,GAAG,CAAC,sBAAsB,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;gBACjE,OAAO,IAAI,MAAM,CAAC,SAAS,CAAC,aAAa,EAAE,CAAC,EAAE,IAAI,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;YAClF,CAAC,CAAC,CAAC;QACP,CAAC;QAED,8DAA8D;QAE9D,IAAI,sBAAsB;YACtB,OAAO,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACvD,CAAC;QAED,2CAA2C;QAE3C,IAAI,UAAU;YACV,OAAO,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC,CAAC;QACjE,CAAC;QAED,oDAAoD;QACpD,IAAI,cAAc;YACd,MAAM,cAAc,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,0BAA0B,CAAC,CAAC,UAAU,EAAE,CAAC,KAAK,CAAgB,gBAAgB,CAAC,CAAC,KAAK,CAAC;YACjI,MAAM,2BAA2B,GAAG,cAAc,CAAC,KAAK,CAAgB,YAAY,CAAC,CAAC,KAAK,CAAC;YAC5F,MAAM,oBAAoB,GAAG,cAAc,CAAC,KAAK,CAAgB,QAAQ,CAAC,CAAC,KAAK,CAAC;YAEjF,kBAAkB;YAClB,MAAM,MAAM,GAAG,oBAAoB,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC,MAAM,CAAC,2BAA2B,CAAC,CAAC;mBAC/F,KAAK,CAAC,sEAAsE,CAAC,CAAC;YAErF,kBAAkB;YAClB,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,EAAE,gBAAgB,EAAE;gBAC9C,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,WAAW,EAAE,CAAC;YACjD,CAAC,EAAE,IAAI,CAAC,CAAC;YAET,2EAA2E;YAC3E,+EAA+E;YAC/E,mFAAmF;YACnF,eAAe;YACf,wEAAwE;YACxE,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,0BAA0B,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,MAAM,EAAE,CAAC;YAE1E,OAAO,IAAI,CAAC,cAAc,CAAC;QAC/B,CAAC;QAED,wCAAwC;QACxC,IAAI,cAAc,CAAC,KAA2G;YAC1H,IAAI;gBACA,WAAW,CAAC,OAAO,CAAC,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;aAC9D;YAAC,OAAO,CAAM,EAAE;gBACb,QAAQ,CAAC,CAAC,OAAO,EAAE;oBACf,KAAK,gCAAgC;wBACjC,KAAK,CAAC,0CAA0C,IAAI,CAAC,IAAI,mCAAmC,CAAC,CAAC;oBAClG,KAAK,wDAAwD,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,EAAE,KAAK;wBAChF,IAAI,CAAC,0CAA0C,IAAI,CAAC,IAAI,uBAAuB,CAAC,CAAC;wBACjF,MAAM;oBACV,KAAK,gCAAgC;wBACjC,IAAI,CAAC,0CAA0C,IAAI,CAAC,IAAI,6CAA6C,CAAC,CAAC;wBACvG,MAAM;oBACV;wBACI,MAAM,CAAC,CAAC;iBACf;aACJ;QACL,CAAC;QAED,gEAAgE;QAChE,OAAO,CAAyC,GAAG,OAAuB;YACtE,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;gBACjB,KAAK,CAAC,yBAAyB,IAAI,CAAC,IAAI,kCAAkC,CAAC,CAAC;aAC/E;YAED,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,IAAI,OAAO,CAAC,MAAM,EAAE;gBACxC,KAAK,CAAC,yBAAyB,IAAI,CAAC,IAAI,gBAAgB,IAAI,CAAC,QAAQ,CAAC,MAAM,8BAA8B,OAAO,CAAC,MAAM,EAAE,CAAC,CAAC;aAC/H;YAED,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAC9C,MAAM,SAAS,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,aAAa,CAAC,EAAE,KAAK,CAAC,CAAC;YAE1E,MAAM,oBAAoB,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAgB,mBAAmB,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;YACzG,OAAO,IAAI,MAAM,CAAC,MAAM,CAAC,oBAAoB,CAAC,KAAK,CAAgB,SAAS,CAAC,CAAC,KAAK,CAAC,CAAC;QACzF,CAAC;QAED,2BAA2B;QAC3B,MAAM,CAAC,GAAG,UAAmC;YACzC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;gBAChB,KAAK,CAAC,mCAAmC,IAAI,CAAC,IAAI,qEAAqE,CAAC,CAAC;aAC5H;YACD,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,GAAG,UAAU,CAAC,CAAC;QAC/C,CAAC;QAED,gBAAgB;QAChB,SAAS,CAAC,QAA4B,EAAE,GAAG,UAAmC;YAC1E,MAAM,mBAAmB,GAAG,UAAU,CAAC,GAAG,CAAC,OAAA,YAAY,CAAC,CAAC;YAEzD,IAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,MAAM,CAAC,yBAAyB,EAAE;gBACpD,mBAAmB,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;aACzC;YAED,IAAI,IAAI,CAAC,UAAU,EAAE;gBACjB,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;aACzC;YAED,IAAI;gBACA,MAAM,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,mBAAmB,CAAC,CAAC;gBAChE,OAAO,OAAA,cAAc,CAAC,WAAW,EAAE,IAAI,CAAC,UAAU,CAAM,CAAC;aAC5D;YAAC,OAAO,CAAM,EAAE;gBACb,IAAI,CAAC,IAAI,IAAI,EAAE;oBACX,KAAK,CAAC,6FAA6F,CAAC,CAAC;iBACxG;gBAED,QAAQ,CAAC,CAAC,OAAO,EAAE;oBACf,KAAK,oBAAoB;wBACrB,KAAK,CAAC,0BAA0B,IAAI,CAAC,IAAI,gBAAgB,IAAI,CAAC,cAAc,sBAAsB,UAAU,CAAC,MAAM,EAAE,CAAC,CAAC;oBAC3H,KAAK,oBAAoB,CAAC;oBAC1B,KAAK,iBAAiB,CAAC;oBACvB,KAAK,4BAA4B;wBAC7B,KAAK,CAAC,0BAA0B,IAAI,CAAC,IAAI,kCAAkC,CAAC,CAAC;iBACpF;gBAED,MAAM,CAAC,CAAC;aACX;QACL,CAAC;QAED,iEAAiE;QACjE,QAAQ,CAAC,GAAG,cAAwB;YAChC,MAAM,MAAM,GAAG,IAAI,CAAC,WAAW,CAAI,GAAG,cAAc,CAAC,CAAC;YAEtD,IAAI,MAAM,IAAI,SAAS;gBAAE,OAAO,MAAM,CAAC;YAEvC,KAAK,CAAC,mCAAmC,IAAI,CAAC,IAAI,IAAI,cAAc,GAAG,CAAC,CAAC;QAC7E,CAAC;QAED,8CAA8C;QAC9C,SAAS,CAAC,IAAY;YAClB,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,2BAA2B,IAAI,cAAc,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;QACtG,CAAC;QAED,kDAAkD;QAClD,MAAM;YACF,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;YACxC,WAAW,CAAC,KAAK,EAAE,CAAC;QACxB,CAAC;QAED,iEAAiE;QACjE,WAAW,CAAyC,GAAG,cAAwB;YAC3E,OAAO,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;gBACpC,OAAO,CACH,MAAM,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI;oBACxB,MAAM,CAAC,cAAc,IAAI,cAAc,CAAC,MAAM;oBAC9C,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,IAAI,cAAc,CAAC,CAAC,CAAC,CAAC,CACtE,CAAC;YACN,CAAC,CAAiC,CAAC;QACvC,CAAC;QAED,8CAA8C;QAC9C,YAAY,CAAC,IAAY;YACrB,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC;QACrD,CAAC;QAED,MAAM;QACN,QAAQ;YACJ,OAAO;EACjB,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE;EAC9B,IAAI,CAAC,UAAU,CAAC,IAAI;EACpB,IAAI,CAAC,IAAI;GACR,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC;EAC3B,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,SAAS,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,EAAE,EAAE,CAAC;QACrG,CAAC;QAED,gBAAgB;QAChB,UAAU,CAAC,QAA0C;YACjD,IAAI,IAAI,CAAC,QAAQ,EAAE;gBACf,KAAK,CAAC,+BAA+B,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,sCAAsC,CAAC,CAAC;aAClH;YAED,OAAO,IAAI,KAAK,CAAC,IAAI,EAAE;gBACnB,GAAG,CAAC,MAAwB,EAAE,QAAgC;oBAC1D,QAAQ,QAAQ,EAAE;wBACd,KAAK,QAAQ;4BACT,8CAA8C;4BAC9C,kDAAkD;4BAClD,kDAAkD;4BAClD,kDAAkD;4BAClD,YAAY;4BACZ,kDAAkD;4BAClD,mDAAmD;4BACnD,gDAAgD;4BAChD,iDAAiD;4BACjD,EAAE;4BACF,8CAA8C;4BAC9C,MAAM,MAAM,GACR,QAAQ,YAAY,MAAM,CAAC,SAAS;gCAChC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW;oCACtB,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,qBAAqB,EAAE,GAAG,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC;oCACzE,CAAC,CAAC,KAAK,CAAC,wBAAwB,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,MAAM,CAAC,IAAI,8CAA8C,CAAC;gCACzH,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW;oCAC1B,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,qBAAqB,EAAE,CAAC;oCAC9C,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC;4BAE1B,OAAO,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;wBACjD,KAAK,SAAS,CAAC;wBACf,KAAK,UAAU,CAAC;wBAChB,KAAK,aAAa;4BACd,OAAO,UAAU,GAAG,IAAW;gCAC3B,OAAO,MAAM,CAAC,QAAQ,CAAC,CAAC,GAAG,IAAI,CAAC,EAAE,UAAU,CAAC,QAAQ,CAAC,CAAC;4BAC3D,CAAC,CAAC;qBACT;oBAED,OAAO,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;gBACzC,CAAC;aACJ,CAAC,CAAC;QACP,CAAC;QAED,gBAAgB;QAChB,IAAI,CAAC,KAA2G;YAC5G,MAAM,UAAU,GAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,GAAG,CAAC,MAAM,CAAC,yBAAyB,CAAC;YACvE,OAAO,IAAI,cAAc,CACrB,CAAC,GAAG,IAAmC,EAA6B,EAAE;gBAClE,MAAM,UAAU,GAAG,IAAI,CAAC,QAAQ;oBAC5B,CAAC,CAAC,IAAI,CAAC,KAAK;oBACZ,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW;wBACxB,CAAC,CAAC,IAAI,MAAM,CAAC,SAAS,CAAE,IAAI,CAAC,CAAC,CAAmB,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,UAAU,GAAG,qBAAqB,EAAE,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;wBAC3H,CAAC,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAkB,CAAC,CAAC;gBAElD,MAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,OAAA,cAAc,CAAC,IAAI,CAAC,CAAC,GAAG,UAAU,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;gBAC/F,MAAM,MAAM,GAAG,KAAK,CAAC,IAAI,CAAC,UAAU,EAAE,GAAG,UAAU,CAAC,CAAC;gBACrD,OAAO,OAAA,YAAY,CAAC,MAAM,CAAC,CAAC;YAChC,CAAC,EACD,IAAI,CAAC,UAAU,CAAC,UAAU,EAC1B,IAAI,CAAC,cAAc,CACtB,CAAC;QACN,CAAC;KACJ;IArWG;QADC,IAAI;uCAGJ;IAID;QADC,IAAI;uCAGJ;IAID;QADC,IAAI;qDAMJ;IAID;QADC,IAAI;gDAiBJ;IAID;QADC,IAAI;0CAQJ;IAID;QADC,IAAI;4CAGJ;IAID;QADC,IAAI;2CAGJ;IAID;QADC,IAAI;4CAGJ;IAID;QADC,IAAI;0CAGJ;IAID;QADC,IAAI;gDAGJ;IAID;QADC,IAAI;0CAgBJ;IAID;QADC,IAAI;sCAGJ;IAID;QADC,IAAI;gDAGJ;IAID;QADC,IAAI;wCAGJ;IAID;QADC,IAAI;gDAGJ;IAID;QADC,IAAI;4CAOJ;IAID;QADC,IAAI;wDAGJ;IAID;QADC,IAAI;4CAGJ;IAlJQ,aAAM,SAwWlB,CAAA;IAED,IAAI,qBAAqB,GAAG,GAAW,EAAE;QACrC,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,0BAA0B,CAAC,CAAC,UAAU,EAAE,CAAC,KAAK,EAAE,CAAC;QACpF,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,SAAS,CAAC,MAAM,EAAE,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC;QAE1D,4CAA4C;QAC5C,kEAAkE;QAClE,wEAAwE;QACxE,qEAAqE;QACrE,MAAM,MAAM,GAAG,MAAM,CAAC,KAAK,CAAgB,OAAO,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC;QACjH,OAAO,CAAC,qBAAqB,GAAG,GAAG,EAAE,CAAC,MAAM,CAAC,EAAE,CAAC;IACpD,CAAC,CAAC;AAoDN,CAAC,EAzaS,MAAM,KAAN,MAAM,QAyaf;ACzaD,IAAU,MAAM,CAkHf;AAlHD,WAAU,MAAM;IACZ,MAAa,MAAO,SAAQ,YAAY;QACpC,sFAAsF;QAE/E,AAAP,MAAM,KAAK,UAAU;YACjB,OAAO,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC,YAAY,CAAC;QAC7D,CAAC;QAED,qCAAqC;QAErC,IAAI,KAAK;YACL,OAAO,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC;QAC7D,CAAC;QAED,yCAAyC;QACzC,IAAI,OAAO;YACP,OAAO,IAAI,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QAC3C,CAAC;QAED,2CAA2C;QAE3C,IAAI,IAAI;YACJ,OAAO,MAAM,CAAC,GAAG,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;QAC1C,CAAC;QAED,0CAA0C;QAC1C,KAAK,CAA8B,IAAY;YAC3C,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK,CAAI,IAAI,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QACtD,CAAC;QAED,2CAA2C;QAC3C,MAAM,CAAqC,IAAY,EAAE,iBAAyB,CAAC,CAAC;YAChF,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAI,IAAI,EAAE,cAAc,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QACvE,CAAC;QAED,0CAA0C;QAC1C,GAAG,CAAC,GAAY;YACZ,OAAO,IAAI,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;QACnE,CAAC;QAED,qEAAqE;QACrE,aAAa,CAAqC,MAAqB;YACnE,OAAO,IAAI,MAAM,CAAC,MAAM,CAAI,MAAM,CAAC,GAAG,CAAC,sBAAsB,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QAClG,CAAC;QAED,0CAA0C;QAC1C,QAAQ,CAA8B,IAAY;YAC9C,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAI,IAAI,CAAC,EAAE,UAAU,CAAC,IAAI,CAAC,CAAC;QAC1D,CAAC;QAED,0CAA0C;QAC1C,SAAS,CAAqC,IAAY,EAAE,iBAAyB,CAAC,CAAC;YACnF,OAAO,IAAI,CAAC,KAAK,CAAC,SAAS,CAAI,IAAI,EAAE,cAAc,CAAC,EAAE,UAAU,CAAC,IAAI,CAAC,CAAC;QAC3E,CAAC;QAED,MAAM;QACN,QAAQ;YACJ,OAAO,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAgB,UAAU,EAAE,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,OAAO,IAAI,MAAM,CAAC;QACzG,CAAC;QAED,2FAA2F;QAC3F,KAAK;YACD,OAAO,IAAI,CAAC,KAAK,CAAC,WAAW;gBACzB,CAAC,CAAC,IAAI,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;gBACrE,CAAC,CAAC,KAAK,CAAC,+BAA+B,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,8BAA8B,CAAC,CAAC;QACnG,CAAC;QAED,+CAA+C;QAC/C,OAAO,CAAC,iBAA0B;YAC9B,OAAO,IAAI,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,kBAAkB,CAAC,IAAI,EAAE,CAAC,iBAAiB,CAAC,CAAC,CAAC;QACxF,CAAC;KACJ;IA7DG;QADC,IAAI;uCAGJ;IASD;QADC,IAAI;sCAGJ;IAnBM;QADN,IAAI;kCAGJ;IALQ,aAAM,SAsElB,CAAA;IAED,WAAiB,MAAM;QACnB,MAAa,OAAO;YAEsB;YADtC,gBAAgB;YAChB,YAAY,gBAAgB,CAAU,MAA0B;gBAA1B,WAAM,GAAN,MAAM,CAAoB;YAAG,CAAC;YAEpE,wDAAwD;YACxD,KAAK;gBACD,OAAO,MAAM,CAAC,GAAG,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAChD,CAAC;YAED,uDAAuD;YACvD,IAAI;gBACA,OAAO,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAC/C,CAAC;YAED,uFAAuF;YACvF,KAAK;gBACD,OAAO,MAAM,CAAC,GAAG,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAChD,CAAC;YAED,sEAAsE;YACtE,QAAQ;gBACJ,OAAO,MAAM,CAAC,GAAG,CAAC,eAAe,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACnD,CAAC;YAED,mEAAmE;YACnE,QAAQ,CAAC,OAAe;gBACpB,OAAO,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,eAAe,CAAC,IAAI,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;YAC9D,CAAC;YAED,4GAA4G;YAC5G,OAAO,CAAC,OAAe;gBACnB,OAAO,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,cAAc,CAAC,IAAI,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;YAC7D,CAAC;YAED,iGAAiG;YACjG,IAAI;gBACA,OAAO,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAC/C,CAAC;SACJ;QAtCY,cAAO,UAsCnB,CAAA;IACL,CAAC,EAxCgB,MAAM,GAAN,aAAM,KAAN,aAAM,QAwCtB;AACL,CAAC,EAlHS,MAAM,KAAN,MAAM,QAkHf;AClHD,IAAU,MAAM,CA0Bf;AA1BD,WAAU,MAAM;IACZ,MAAa,SAAS;QAClB,8BAA8B;QACrB,IAAI,CAAS;QAEtB,kCAAkC;QACzB,QAAQ,CAAS;QAE1B,8BAA8B;QACrB,IAAI,CAAc;QAE3B,YAAY,IAAY,EAAE,QAAgB,EAAE,IAAiB;YACzD,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;YACjB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;YACzB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACrB,CAAC;QAED,MAAM;QACN,QAAQ;YACJ,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,EAAE,CAAC;QAC5C,CAAC;KACJ;IApBY,gBAAS,YAoBrB,CAAA;AAKL,CAAC,EA1BS,MAAM,KAAN,MAAM,QA0Bf;AC1BD,IAAU,MAAM,CAuCf;AAvCD,WAAU,MAAM;IACZ,MAAa,OAAyD,SAAQ,YAAY;QAC1C;QAA5C,YAAY,MAAqB,EAAW,IAAiB;YACzD,KAAK,CAAC,MAAM,CAAC,CAAC;YAD0B,SAAI,GAAJ,IAAI,CAAa;QAE7D,CAAC;QAED,2CAA2C;QAC3C,GAAG,CAAC,KAAa;YACb,OAAO,OAAA,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,EAAE,IAAI,CAAC,IAAI,CAAM,CAAC;QAC3F,CAAC;QAED,uEAAuE;QACvE,IAAI,CAAC,MAAc,EAAE,SAAiB,CAAC;YACnC,MAAM,MAAM,GAAG,IAAI,UAAU,CAAC,KAAK,CAAI,MAAM,CAAC,CAAC;YAE/C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;gBAC7B,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC;aACpC;YAED,OAAO,MAAM,CAAC;QAClB,CAAC;QAED,gDAAgD;QAChD,GAAG,CAAC,KAAa,EAAE,KAAQ;YACvB,OAAA,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;QACvF,CAAC;QAED,MAAM;QACN,QAAQ;YACJ,OAAO,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC;QAClC,CAAC;QAED,6DAA6D;QAC7D,KAAK,CAAC,MAAW,EAAE,SAAiB,CAAC;YACjC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACpC,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;aACnC;QACL,CAAC;KACJ;IArCY,cAAO,UAqCnB,CAAA;AACL,CAAC,EAvCS,MAAM,KAAN,MAAM,QAuCf;ACvCD,IAAU,MAAM,CA+Ef;AA/ED,WAAU,MAAM;IACZ,MAAa,SAA2D,SAAQ,YAAY;QAC5C;QAA5C,YAAY,MAAqB,EAAW,IAAiB;YACzD,KAAK,CAAC,MAAM,CAAC,CAAC;YAD0B,SAAI,GAAJ,IAAI,CAAa;QAE7D,CAAC;QAED,4DAA4D;QAC5D,IAAI,KAAK;YACL,OAAO,OAAA,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,CAAM,CAAC;QAC7C,CAAC;QAED,4DAA4D;QAC5D,IAAI,KAAK,CAAC,KAAQ;YACd,OAAA,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;QACzC,CAAC;QAED,MAAM;QACN,QAAQ;YACJ,OAAO,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,KAAK,EAAE,CAAC;QACtD,CAAC;KACJ;IAnBY,gBAAS,YAmBrB,CAAA;IAMD,kDAAkD;IAClD,SAAgB,SAAS,CAA8B,KAAQ,EAAE,IAAkB;QAC/E,MAAM,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;QAEjD,QAAQ,OAAO,KAAK,EAAE;YAClB,KAAK,SAAS;gBACV,OAAO,IAAI,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC,EAAE,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC,IAAI,CAAC,CAAC;YACpG,KAAK,QAAQ;gBACT,QAAQ,IAAI,EAAE,QAAQ,EAAE;oBACpB,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY;wBAC9B,OAAO,IAAI,MAAM,CAAC,SAAS,CAAI,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;oBAChE,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI;wBACtB,OAAO,IAAI,MAAM,CAAC,SAAS,CAAI,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;oBAChE,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;oBAC3B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa;wBAC/B,OAAO,IAAI,MAAM,CAAC,SAAS,CAAI,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;oBACjE,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK;wBACvB,OAAO,IAAI,MAAM,CAAC,SAAS,CAAI,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;oBACjE,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW;wBAC7B,OAAO,IAAI,MAAM,CAAC,SAAS,CAAI,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;oBACjE,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG;wBACrB,OAAO,IAAI,MAAM,CAAC,SAAS,CAAI,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;oBACjE,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY;wBAC9B,OAAO,IAAI,MAAM,CAAC,SAAS,CAAI,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;oBACjE,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI;wBACtB,OAAO,IAAI,MAAM,CAAC,SAAS,CAAI,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;oBACjE,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK;wBACvB,OAAO,IAAI,MAAM,CAAC,SAAS,CAAI,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;oBACnE,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM;wBACxB,OAAO,IAAI,MAAM,CAAC,SAAS,CAAI,MAAM,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;iBACvE;YACL,KAAK,QAAQ;gBACT,IAAI,KAAK,YAAY,MAAM,CAAC,SAAS,IAAI,KAAK,YAAY,MAAM,CAAC,OAAO,EAAE;oBACtE,OAAO,IAAI,MAAM,CAAC,SAAS,CAAI,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC;iBAC1E;qBAAM,IAAI,KAAK,YAAY,MAAM,CAAC,MAAM,EAAE;oBACvC,OAAO,IAAI,MAAM,CAAC,SAAS,CAAI,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;iBAChF;qBAAM,IAAI,KAAK,YAAY,MAAM,CAAC,MAAM,IAAI,KAAK,YAAY,MAAM,CAAC,KAAK,EAAE;oBACxE,OAAO,IAAI,MAAM,CAAC,SAAS,CAAI,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;iBACvF;qBAAM,IAAI,KAAK,YAAY,aAAa,EAAE;oBACvC,QAAQ,IAAI,EAAE,QAAQ,EAAE;wBACpB,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,qBAAqB,CAAC;wBAC5C,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa;4BAC/B,OAAO,IAAI,MAAM,CAAC,SAAS,CAAI,MAAM,CAAC,YAAY,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;qBACxE;iBACJ;qBAAM,IAAI,KAAK,YAAY,KAAK,EAAE;oBAC/B,OAAO,IAAI,MAAM,CAAC,SAAS,CAAI,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC,IAAI,CAAC,CAAC;iBACpG;qBAAM,IAAI,KAAK,YAAY,MAAM,EAAE;oBAChC,OAAO,IAAI,MAAM,CAAC,SAAS,CAAI,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC,IAAI,CAAC,CAAC;iBACrG;YACL;gBACI,KAAK,CAAC,kCAAkC,KAAK,4BAA4B,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;SAC9F;IACL,CAAC;IAnDe,gBAAS,YAmDxB,CAAA;AACL,CAAC,EA/ES,MAAM,KAAN,MAAM,QA+Ef;AC/ED,IAAU,MAAM,CA2Cf;AA3CD,WAAU,MAAM;IACZ,MAAa,MAAO,SAAQ,YAAY;QACpC,uCAAuC;QACvC,IAAI,OAAO;YACP,OAAO,MAAM,CAAC,GAAG,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,eAAe,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACxE,CAAC;QAED,4EAA4E;QAC5E,IAAI,OAAO,CAAC,KAAoB;YAC5B,kBAAkB;YAClB,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;mBACzE,KAAK,CAAC,6DAA6D,CAAC,CAAC;YAE5E,UAAU,CAAC,MAAM,CAAC,cAAc,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,EAAE,SAAS,EAAE;gBACjE,GAAG,CAAsB,KAAoB;oBACzC,MAAM,CAAC,GAAG,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,gBAAgB,CAAC,KAAK,IAAI,EAAE,CAAC,CAAC;oBAC9D,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,QAAQ,CAAC,KAAK,EAAE,MAAM,IAAI,CAAC,CAAC,CAAC;gBACzD,CAAC;aACJ,CAAC,CAAC;YAEH,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;QACzB,CAAC;QAED,sCAAsC;QACtC,IAAI,MAAM;YACN,OAAO,MAAM,CAAC,GAAG,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;QAC5C,CAAC;QAED,0DAA0D;QAC1D,IAAI,MAAM;YACN,OAAO,IAAI,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACnC,CAAC;QAED,MAAM;QACN,QAAQ;YACJ,OAAO,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,OAAO,GAAG,CAAC;QACxD,CAAC;KACJ;IApCY,aAAM,SAoClB,CAAA;IAED,uDAAuD;IACvD,SAAgB,MAAM,CAAC,OAAsB;QACzC,OAAO,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,MAAM,CAAC,eAAe,CAAC,OAAO,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC;IAC1F,CAAC;IAFe,aAAM,SAErB,CAAA;AACL,CAAC,EA3CS,MAAM,KAAN,MAAM,QA2Cf;AC3CD,IAAU,MAAM,CAyJf;AAzJD,WAAU,MAAM;IACZ,MAAa,MAAO,SAAQ,YAAY;QACpC,gDAAgD;QAChD,IAAI,EAAE;YACF,IAAI,GAAG,GAAG;gBACN,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAS,WAAW,CAAC,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC;YACrE,CAAC,CAAC;YAEF,4HAA4H;YAC5H,IAAI,OAAO,CAAC,QAAQ,IAAI,SAAS,EAAE;gBAC/B,MAAM,eAAe,GAAG,OAAO,CAAC,kBAAkB,EAAE,CAAC;gBACrD,MAAM,kBAAkB,GAAG,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,CAAC,aAAc,CAAC,CAAC,CAAC;gBAEjE,kBAAkB;gBAClB,MAAM,MAAM,GAAG,kBAAkB,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,OAAO,EAAE,IAAI,eAAe,EAAE,IAAI,CAAC;oBACjF,KAAK,CAAC,0EAA0E,CAAC,CAAC;gBAEtF,MAAM,IAAI,GAAG,GAAG,CAAC;gBACjB,GAAG,GAAG;oBACF,OAAO,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,OAAO,EAAE,CAAC;gBACvD,CAAC,CAAC;aACL;YAED,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;YAEjD,OAAO,IAAI,CAAC,EAAE,CAAC;QACnB,CAAC;QAED,qGAAqG;QAErG,IAAI,QAAQ;YACR,OAAO,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAgB,iBAAiB,CAAC,EAAE,KAAK,IAAI,IAAI,CAAC,MAAM,CAAC;QACxF,CAAC;QAED,oFAAoF;QAEpF,IAAI,WAAW;YACX,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QACxC,CAAC;QAED,iDAAiD;QAEjD,IAAI,SAAS;YACT,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,CAAS,qBAAqB,CAAC,CAAC,MAAM,EAAE,CAAC;QACtE,CAAC;QAED,0DAA0D;QAE1D,IAAI,MAAM;YACN,OAAO,IAAI,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACnC,CAAC;QAED,gBAAgB;QAEhB,IAAY,UAAU;YAClB,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAgB,aAAa,CAAC,CAAC,KAAK,CAAC;QACnE,CAAC;QAED,gBAAgB;QAEhB,IAAY,sBAAsB;YAC9B,MAAM,oBAAoB,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,CAAgB,4BAA4B,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,sBAAsB,CAAC,CAAC;YAC9I,MAAM,gBAAgB,GAAG,oBAAoB,CAAC,MAAM,EAAE,CAAC;YAEvD,IAAI,sBAAsB,GACtB,gBAAgB,CAAC,QAAQ,CAAgB,cAAc,CAAC,EAAE,KAAK;gBAC/D,gBAAgB,CAAC,SAAS,CAAgB,4BAA4B,CAAC,EAAE,MAAM,EAAE;gBACjF,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,yCAAyC,CAAC,CAAC,CAAC;YAEvF,IAAI,sBAAsB,IAAI,IAAI,IAAI,sBAAsB,CAAC,MAAM,EAAE,EAAE;gBACnE,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE;oBAC9C,KAAK,CAAC,sGAAsG,CAAC,CAAC;iBACjH;qBAAM;oBACH,KAAK,CAAC,wDAAwD,IAAI,CAAC,SAAS,gDAAgD,CAAC,CAAC;iBACjI;aACJ;YAED,OAAO,sBAAsB,CAAC;QAClC,CAAC;QAED,uDAAuD;QACvD,MAAM;YACF,OAAO,MAAM,CAAC,GAAG,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC;QACzC,CAAC;QAED,kDAAkD;QAClD,QAAQ,CAAI,KAA2B;YACnC,MAAM,IAAI,GAAG,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;YAExD,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE;gBACzB,MAAM,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,qCAAqC,CAAC,EAAE,GAAG,EAAE;oBAC9F,MAAM,MAAM,GAAG,KAAK,EAAE,CAAC;oBACvB,YAAY,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;gBACxC,CAAC,CAAC,CAAC;gBAEH,2FAA2F;gBAC3F,yFAAyF;gBACzF,uFAAuF;gBACvF,iFAAiF;gBACjF,8BAA8B;gBAC9B,0BAA0B;gBAC1B,wBAAwB;gBACxB,wBAAwB;gBACxB,EAAE;gBACF,yFAAyF;gBACzF,4FAA4F;gBAC5F,qFAAqF;gBACrF,6FAA6F;gBAC7F,4DAA4D;gBAC5D,MAAM,CAAC,QAAQ,CAAC,UAAU,EAAE,GAAG,EAAE;oBAC7B,QAAQ,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC;gBACpG,CAAC,CAAC,CAAC;gBAEH,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;YAChC,CAAC,CAAC,CAAC;QACP,CAAC;QAED,gBAAgB;QAChB,aAAa,CAAC,KAAmB;YAC7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE;gBACzB,MAAM,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO,CAAC,WAAW,CAAC,CAAC,WAAW,EAAE,CAAC;gBACxE,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,EAAE;oBAChB,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC,UAAU,EAAE,CAAC;oBAClE,IAAI,MAAM,EAAE,KAAK,EAAE,YAAY,CAAC,KAAK,EAAE,KAAK,CAAC,EAAE;wBAC3C,OAAO,MAAM,CAAC;qBACjB;iBACJ;aACJ;QACL,CAAC;KACJ;IAnGG;QADC,IAAI;0CAGJ;IAID;QADC,IAAI;6CAGJ;IAID;QADC,IAAI;2CAGJ;IAID;QADC,IAAI;wCAGJ;IAID;QADC,IAAI;4CAGJ;IAID;QADC,IAAI;wDAmBJ;IA7EQ,aAAM,SAgIlB,CAAA;IAID,MAAM,CAAC,MAAM,EAAE,iBAAiB,EAAE,GAAG,EAAE;QACnC,OAAO,cAAc,CAAC,MAAM,CAAC,GAAG,CAAC,wBAAwB,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IAC9F,CAAC,CAAC,CAAC;IAIH,MAAM,CAAC,MAAM,EAAE,eAAe,EAAE,GAAG,EAAE;QACjC,OAAO,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,gBAAgB,EAAE,CAAC,CAAC,UAAU,EAAE,CAAC;IACzE,CAAC,CAAC,CAAC;IAIH,MAAM,CAAC,MAAM,EAAE,YAAY,EAAE,GAAG,EAAE;QAC9B,+DAA+D;QAC/D,+DAA+D;QAC/D,iEAAiE;QACjE,oEAAoE;QACpE,mBAAmB;QACnB,OAAO,OAAA,eAAe,CAAC,CAAC,CAAC,CAAC;IAC9B,CAAC,CAAC,CAAC;AACP,CAAC,EAzJS,MAAM,KAAN,MAAM,QAyJf;ACzJD,IAAU,MAAM,CA6Jf;AA7JD,WAAU,MAAM;IAEZ,IAAa,IAAI,GAAjB,MAAa,IAAK,SAAQ,YAAY;QAClC,MAAM;QAEC,AAAP,MAAM,KAAK,IAAI;YACX,MAAM,CAAC,GAAG,CAAC,CAAS,EAAE,QAAQ,CAAC,CAAe,EAAyB,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC;YAE5H,OAAO;gBACH,IAAI,EAAE,CAAC,CAAC,aAAa,CAAC;gBACtB,OAAO,EAAE,CAAC,CAAC,gBAAgB,CAAC;gBAC5B,IAAI,EAAE,CAAC,CAAC,aAAa,CAAC;gBACtB,IAAI,EAAE,CAAC,CAAC,cAAc,CAAC;gBACvB,YAAY,EAAE,CAAC,CAAC,aAAa,CAAC;gBAC9B,KAAK,EAAE,CAAC,CAAC,cAAc,CAAC;gBACxB,aAAa,EAAE,CAAC,CAAC,eAAe,CAAC;gBACjC,GAAG,EAAE,CAAC,CAAC,cAAc,CAAC;gBACtB,WAAW,EAAE,CAAC,CAAC,eAAe,CAAC;gBAC/B,IAAI,EAAE,CAAC,CAAC,cAAc,CAAC;gBACvB,YAAY,EAAE,CAAC,CAAC,eAAe,CAAC;gBAChC,aAAa,EAAE,CAAC,CAAC,eAAe,CAAC;gBACjC,qBAAqB,EAAE,CAAC,CAAC,gBAAgB,CAAC;gBAC1C,KAAK,EAAE,CAAC,CAAC,eAAe,CAAC;gBACzB,MAAM,EAAE,CAAC,CAAC,eAAe,CAAC;gBAC1B,OAAO,EAAE,CAAC,CAAC,eAAe,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;gBACpD,SAAS,EAAE,CAAC,CAAC,gBAAgB,CAAC;gBAC9B,MAAM,EAAE,CAAC,CAAC,eAAe,CAAC;gBAC1B,MAAM,EAAE,CAAC,CAAC,eAAe,CAAC;gBAC1B,KAAK,EAAE,CAAC,CAAC,cAAc,CAAC;gBACxB,KAAK,EAAE,CAAC,CAAC,aAAa,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC;gBAC1C,qBAAqB,EAAE,CAAC,CAAC,aAAa,EAAE,CAAC,CAAC,EAAE,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,kBAAkB,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;gBACnG,eAAe,EAAE,CAAC,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAE,CAAC;aAC1F,CAAC;QACN,CAAC;QAED,mCAAmC;QAEnC,IAAI,KAAK;YACL,OAAO,IAAI,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC;QAC3D,CAAC;QAED,MAAM;QAEN,IAAI,UAAU;YACV,SAAS,kBAAkB,CAAC,IAAiB;gBACzC,MAAM,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;gBAClE,OAAO,cAAc,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YAC9F,CAAC;YAED,IAAI,IAAI,CAAC,aAAa,EAAE;gBACpB,OAAO,SAAS,CAAC;aACpB;YAED,QAAQ,IAAI,CAAC,QAAQ,EAAE;gBACnB,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI;oBACtB,OAAO,MAAM,CAAC;gBAClB,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO;oBACzB,OAAO,MAAM,CAAC;gBAClB,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI;oBACtB,OAAO,OAAO,CAAC;gBACnB,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI;oBACtB,OAAO,MAAM,CAAC;gBAClB,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY;oBAC9B,OAAO,OAAO,CAAC;gBACnB,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK;oBACvB,OAAO,OAAO,CAAC;gBACnB,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa;oBAC/B,OAAO,QAAQ,CAAC;gBACpB,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG;oBACrB,OAAO,OAAO,CAAC;gBACnB,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW;oBAC7B,OAAO,QAAQ,CAAC;gBACpB,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI;oBACtB,OAAO,OAAO,CAAC;gBACnB,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY;oBAC9B,OAAO,QAAQ,CAAC;gBACpB,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK;oBACvB,OAAO,OAAO,CAAC;gBACnB,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM;oBACxB,OAAO,QAAQ,CAAC;gBACpB,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC;gBACpC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,qBAAqB,CAAC;gBAC5C,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC;gBAC9B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;gBAC7B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;gBAC5B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,qBAAqB;oBACvC,OAAO,SAAS,CAAC;gBACrB,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS;oBAC3B,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,QAAS,CAAC,UAAU,CAAC,CAAC,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;gBAC1F,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;gBAC5B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;gBAC7B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe;oBACjC,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,QAAS,CAAC,UAAU,CAAC,CAAC,CAAC,SAAS,CAAC;gBAC5H;oBACI,OAAO,SAAS,CAAC;aACxB;QACL,CAAC;QAED,2DAA2D;QAE3D,IAAI,aAAa;YACb,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;QACnC,CAAC;QAED,iDAAiD;QAEjD,IAAI,WAAW;YACX,QAAQ,IAAI,CAAC,QAAQ,EAAE;gBACnB,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC;gBAC9B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;gBAC3B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;gBAC3B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC;gBACnC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;gBAC5B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC;gBACpC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC;gBAC1B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC;gBAClC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;gBAC3B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC;gBACnC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;gBAC5B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;gBAC7B,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC;gBACpC,KAAK,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,qBAAqB;oBACvC,OAAO,IAAI,CAAC;gBAChB;oBACI,OAAO,KAAK,CAAC;aACpB;QACL,CAAC;QAED,kCAAkC;QAElC,IAAI,IAAI;YACJ,MAAM,MAAM,GAAG,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;YAE5C,IAAI;gBACA,OAAO,MAAM,CAAC,cAAc,EAAG,CAAC;aACnC;oBAAS;gBACN,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;aACvB;QACL,CAAC;QAED,wDAAwD;QAExD,IAAI,MAAM;YACN,OAAO,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC,CAAC;QAC7D,CAAC;QAED,8CAA8C;QAE9C,IAAI,QAAQ;YACR,OAAO,MAAM,CAAC,GAAG,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;QAC5C,CAAC;QAED,MAAM;QACN,QAAQ;YACJ,OAAO,IAAI,CAAC,IAAI,CAAC;QACrB,CAAC;KACJ,CAAA;IAvHG;QADC,IAAI;qCAGJ;IAID;QADC,IAAI;0CAsDJ;IAID;QADC,IAAI;6CAGJ;IAID;QADC,IAAI;2CAqBJ;IAID;QADC,IAAI;oCASJ;IAID;QADC,IAAI;sCAGJ;IAID;QADC,IAAI;wCAGJ;IAjJM;QADN,IAAI;0BA6BJ;IA/BQ,IAAI;QADhB,OAAO;OACK,IAAI,CA0JhB;IA1JY,WAAI,OA0JhB,CAAA;AACL,CAAC,EA7JS,MAAM,KAAN,MAAM,QA6Jf;AC7JD,IAAU,MAAM,CA2Cf;AA3CD,WAAU,MAAM;IACZ,MAAa,SAAU,SAAQ,YAAY;QACK;QAA5C,YAAY,MAAqB,EAAW,IAAiB;YACzD,KAAK,CAAC,MAAM,CAAC,CAAC;YAD0B,SAAI,GAAJ,IAAI,CAAa;QAE7D,CAAC;QAED,gDAAgD;QAChD,GAAG;YACC,OAAO,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC;QAC7E,CAAC;QAED,0CAA0C;QAC1C,KAAK,CAA8B,IAAY;YAC3C,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAI,IAAI,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QAC3D,CAAC;QAED,2CAA2C;QAC3C,MAAM,CAAqC,IAAY,EAAE,iBAAyB,CAAC,CAAC;YAChF,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAI,IAAI,EAAE,cAAc,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QAC5E,CAAC;QAED,0CAA0C;QAC1C,QAAQ,CAA8B,IAAY;YAC9C,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAI,IAAI,CAAC,EAAE,UAAU,CAAC,IAAI,CAAC,CAAC;QAC/D,CAAC;QAED,0CAA0C;QAC1C,SAAS,CAAqC,IAAY,EAAE,iBAAyB,CAAC,CAAC;YACnF,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,SAAS,CAAI,IAAI,EAAE,cAAc,CAAC,EAAE,UAAU,CAAC,IAAI,CAAC,CAAC;QAChF,CAAC;QAED,MAAM;QACN,QAAQ;YACJ,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAgB,UAAU,EAAE,CAAC,CAAC,CAAC;YAC3D,OAAO,IAAI,CAAC,MAAM,EAAE;gBAChB,CAAC,CAAC,MAAM;gBACR,CAAC,CAAC,2DAA2D;oBAC7D,0BAA0B;oBAC1B,QAAQ,CAAC,KAAK,CAAC,WAAW;wBAC1B,CAAC,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,OAAO,IAAI,MAAM;wBACrC,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,QAAQ,EAAE,IAAI,MAAM,CAAC;QAC1C,CAAC;KACJ;IAzCY,gBAAS,YAyCrB,CAAA;AACL,CAAC,EA3CS,MAAM,KAAN,MAAM,QA2Cf;AC3CD,2CAA2C;AAC3C,2CAA2C;AAC3C,4CAA4C;AAC5C,0CAA0C;AAC1C,wCAAwC;AACxC,iDAAiD;AACjD,+CAA+C;AAC/C,6CAA6C;AAC7C,wDAAwD;AACxD,oDAAoD;AACpD,2CAA2C;AAC3C,iDAAiD;AAEjD,wCAAwC;AACxC,gDAAgD;AAChD,yCAAyC;AACzC,uDAAuD;AACvD,4CAA4C;AAC5C,uCAAuC;AACvC,2CAA2C;AAC3C,2CAA2C;AAC3C,4CAA4C;AAC5C,2CAA2C;AAE3C,kDAAkD;AAClD,qDAAqD;AACrD,kDAAkD;AAClD,qDAAqD;AACrD,mDAAmD;AACnD,kDAAkD;AAClD,sDAAsD;AACtD,kDAAkD;AAClD,4DAA4D;AAC5D,mDAAmD;AACnD,mDAAmD;AACnD,sDAAsD;AACtD,oDAAoD;AACpD,sDAAsD;AACtD,mDAAmD;AACnD,mDAAmD;AACnD,iDAAiD;AACjD,uDAAuD;AAEvD,UAAU,CAAC,MAAM,GAAG,MAAM,CAAC"}
âœ„
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/** @internal */
var Android;
(function (Android) {
    // prettier-ignore
    getter(Android, "apiLevel", () => {
        const value = getProperty("ro.build.version.sdk");
        return value ? parseInt(value) : null;
    }, lazy);
    function getProperty(name) {
        const handle = Module.findExportByName("libc.so", "__system_property_get");
        if (handle) {
            const __system_property_get = new NativeFunction(handle, "void", ["pointer", "pointer"]);
            const value = Memory.alloc(92).writePointer(NULL);
            __system_property_get(Memory.allocUtf8String(name), value);
            return value.readCString() ?? undefined;
        }
    }
})(Android || (Android = {}));
/** @internal */
function raise(message) {
    const error = new Error(`\x1b[0m${message}`);
    error.name = `\x1b[0m\x1b[38;5;9mil2cpp\x1b[0m`;
    error.stack = error.stack
        ?.replace(/^Error/, error.name)
        ?.replace(/\n    at (.+) \((.+):(.+)\)/, "\x1b[3m\x1b[2m")
        ?.concat("\x1B[0m");
    throw error;
}
/** @internal */
function warn(message) {
    globalThis.console.log(`\x1b[38;5;11mil2cpp\x1b[0m: ${message}`);
}
/** @internal */
function ok(message) {
    globalThis.console.log(`\x1b[38;5;10mil2cpp\x1b[0m: ${message}`);
}
/** @internal */
function inform(message) {
    globalThis.console.log(`\x1b[38;5;12mil2cpp\x1b[0m: ${message}`);
}
/** @internal */
function decorate(target, decorator, descriptors = Object.getOwnPropertyDescriptors(target)) {
    for (const key in descriptors) {
        descriptors[key] = decorator(target, key, descriptors[key]);
    }
    Object.defineProperties(target, descriptors);
    return target;
}
/** @internal */
function getter(target, key, get, decorator) {
    globalThis.Object.defineProperty(target, key, decorator?.(target, key, { get, configurable: true }) ?? { get, configurable: true });
}
/** @internal */
function lazy(_, propertyKey, descriptor) {
    const getter = descriptor.get;
    if (!getter) {
        throw new Error("@lazy can only be applied to getter accessors");
    }
    descriptor.get = function () {
        const value = getter.call(this);
        Object.defineProperty(this, propertyKey, {
            value,
            configurable: descriptor.configurable,
            enumerable: descriptor.enumerable,
            writable: false
        });
        return value;
    };
    return descriptor;
}
/** Scaffold class. */
class NativeStruct {
    handle;
    constructor(handleOrWrapper) {
        if (handleOrWrapper instanceof NativePointer) {
            this.handle = handleOrWrapper;
        }
        else {
            this.handle = handleOrWrapper.handle;
        }
    }
    equals(other) {
        return this.handle.equals(other.handle);
    }
    isNull() {
        return this.handle.isNull();
    }
    asNullable() {
        return this.isNull() ? null : this;
    }
}
/** @internal */
function forModule(...moduleNames) {
    function find(moduleName, name, readString = _ => _.readUtf8String()) {
        const handle = Module.findExportByName(moduleName, name) ?? NULL;
        if (!handle.isNull()) {
            return { handle, readString };
        }
    }
    return new Promise(resolve => {
        for (const moduleName of moduleNames) {
            const module = Process.findModuleByName(moduleName);
            if (module != null) {
                resolve(module);
                return;
            }
        }
        let targets = [];
        switch (Process.platform) {
            case "linux":
                if (Android.apiLevel == null) {
                    targets = [find(null, "dlopen")];
                    break;
                }
                // A5: device reboot, can't hook symbols
                // A6, A7: __dl_open
                // A8, A8.1: __dl__Z8__dlopenPKciPKv
                // A9, A10, A12, A13: __dl___loader_dlopen
                targets = (Process.findModuleByName("linker64") ?? Process.getModuleByName("linker"))
                    .enumerateSymbols()
                    .filter(_ => ["__dl___loader_dlopen", "__dl__Z8__dlopenPKciPKv", "__dl_open"].includes(_.name))
                    .map(_ => ({ handle: _.address, readString: _ => _.readCString() }));
                break;
            case "darwin":
                targets = [find("libdyld.dylib", "dlopen")];
                break;
            case "windows":
                targets = [
                    find("kernel32.dll", "LoadLibraryW", _ => _.readUtf16String()),
                    find("kernel32.dll", "LoadLibraryExW", _ => _.readUtf16String()),
                    find("kernel32.dll", "LoadLibraryA", _ => _.readAnsiString()),
                    find("kernel32.dll", "LoadLibraryExA", _ => _.readAnsiString())
                ];
                break;
        }
        targets = targets.filter(_ => _);
        if (targets.length == 0) {
            raise(`there are no targets to hook the loading of \x1b[3m${moduleNames}\x1b[0m, please file a bug`);
        }
        const timeout = setTimeout(() => {
            for (const moduleName of moduleNames) {
                const module = Process.findModuleByName(moduleName);
                if (module != null) {
                    warn(`\x1b[3m${module.name}\x1b[0m has been loaded, but such event hasn't been detected - please file a bug`);
                    clearTimeout(timeout);
                    interceptors.forEach(_ => _.detach());
                    resolve(module);
                    return;
                }
            }
            warn(`10 seconds have passed and \x1b[3m${moduleNames}\x1b[0m has not been loaded yet, is the app running?`);
        }, 10000);
        const interceptors = targets.map(_ => Interceptor.attach(_.handle, {
            onEnter(args) {
                this.modulePath = _.readString(args[0]) ?? "";
            },
            onLeave(_) {
                for (const moduleName of moduleNames) {
                    if (this.modulePath.endsWith(moduleName)) {
                        const module = Process.findModuleByName(this.modulePath);
                        if (module != null) {
                            setImmediate(() => {
                                clearTimeout(timeout);
                                interceptors.forEach(_ => _.detach());
                            });
                            resolve(module);
                            break;
                        }
                    }
                }
            }
        }));
    });
}
NativePointer.prototype.offsetOf = function (condition, depth) {
    depth ??= 512;
    for (let i = 0; depth > 0 ? i < depth : i < -depth; i++) {
        if (condition(depth > 0 ? this.add(i) : this.sub(i))) {
            return i;
        }
    }
    return null;
};
/** @internal */
function readNativeIterator(block) {
    const array = [];
    const iterator = Memory.alloc(Process.pointerSize);
    let handle = block(iterator);
    while (!handle.isNull()) {
        array.push(handle);
        handle = block(iterator);
    }
    return array;
}
/** @internal */
function readNativeList(block) {
    const lengthPointer = Memory.alloc(Process.pointerSize);
    const startPointer = block(lengthPointer);
    if (startPointer.isNull()) {
        return [];
    }
    const array = new Array(lengthPointer.readInt());
    for (let i = 0; i < array.length; i++) {
        array[i] = startPointer.add(i * Process.pointerSize).readPointer();
    }
    return array;
}
/** @internal */
function recycle(Class) {
    return new Proxy(Class, {
        cache: new Map(),
        construct(Target, argArray) {
            const handle = argArray[0].toUInt32();
            if (!this.cache.has(handle)) {
                this.cache.set(handle, new Target(argArray[0]));
            }
            return this.cache.get(handle);
        }
    });
}
/** @internal */
var UnityVersion;
(function (UnityVersion) {
    const pattern = /(20\d{2}|\d)\.(\d)\.(\d{1,2})(?:[abcfp]|rc){0,2}\d?/;
    function find(string) {
        return string?.match(pattern)?.[0];
    }
    UnityVersion.find = find;
    function gte(a, b) {
        return compare(a, b) >= 0;
    }
    UnityVersion.gte = gte;
    function lt(a, b) {
        return compare(a, b) < 0;
    }
    UnityVersion.lt = lt;
    function compare(a, b) {
        const aMatches = a.match(pattern);
        const bMatches = b.match(pattern);
        for (let i = 1; i <= 3; i++) {
            const a = Number(aMatches?.[i] ?? -1);
            const b = Number(bMatches?.[i] ?? -1);
            if (a > b)
                return 1;
            else if (a < b)
                return -1;
        }
        return 0;
    }
})(UnityVersion || (UnityVersion = {}));
var Il2Cpp;
(function (Il2Cpp) {
    Il2Cpp.api = {
        get alloc() {
            return r("il2cpp_alloc", "pointer", ["size_t"]);
        },
        get arrayGetLength() {
            return r("il2cpp_array_length", "uint32", ["pointer"]);
        },
        get arrayNew() {
            return r("il2cpp_array_new", "pointer", ["pointer", "uint32"]);
        },
        get assemblyGetImage() {
            return r("il2cpp_assembly_get_image", "pointer", ["pointer"]);
        },
        get classForEach() {
            return r("il2cpp_class_for_each", "void", ["pointer", "pointer"]);
        },
        get classFromName() {
            return r("il2cpp_class_from_name", "pointer", ["pointer", "pointer", "pointer"]);
        },
        get classFromObject() {
            return r("il2cpp_class_from_system_type", "pointer", ["pointer"]);
        },
        get classGetArrayClass() {
            return r("il2cpp_array_class_get", "pointer", ["pointer", "uint32"]);
        },
        get classGetArrayElementSize() {
            return r("il2cpp_class_array_element_size", "int", ["pointer"]);
        },
        get classGetAssemblyName() {
            return r("il2cpp_class_get_assemblyname", "pointer", ["pointer"]);
        },
        get classGetBaseType() {
            return r("il2cpp_class_enum_basetype", "pointer", ["pointer"]);
        },
        get classGetDeclaringType() {
            return r("il2cpp_class_get_declaring_type", "pointer", ["pointer"]);
        },
        get classGetElementClass() {
            return r("il2cpp_class_get_element_class", "pointer", ["pointer"]);
        },
        get classGetFieldFromName() {
            return r("il2cpp_class_get_field_from_name", "pointer", ["pointer", "pointer"]);
        },
        get classGetFields() {
            return r("il2cpp_class_get_fields", "pointer", ["pointer", "pointer"]);
        },
        get classGetFlags() {
            return r("il2cpp_class_get_flags", "int", ["pointer"]);
        },
        get classGetImage() {
            return r("il2cpp_class_get_image", "pointer", ["pointer"]);
        },
        get classGetInstanceSize() {
            return r("il2cpp_class_instance_size", "int32", ["pointer"]);
        },
        get classGetInterfaces() {
            return r("il2cpp_class_get_interfaces", "pointer", ["pointer", "pointer"]);
        },
        get classGetMethodFromName() {
            return r("il2cpp_class_get_method_from_name", "pointer", ["pointer", "pointer", "int"]);
        },
        get classGetMethods() {
            return r("il2cpp_class_get_methods", "pointer", ["pointer", "pointer"]);
        },
        get classGetName() {
            return r("il2cpp_class_get_name", "pointer", ["pointer"]);
        },
        get classGetNamespace() {
            return r("il2cpp_class_get_namespace", "pointer", ["pointer"]);
        },
        get classGetNestedClasses() {
            return r("il2cpp_class_get_nested_types", "pointer", ["pointer", "pointer"]);
        },
        get classGetParent() {
            return r("il2cpp_class_get_parent", "pointer", ["pointer"]);
        },
        get classGetStaticFieldData() {
            return r("il2cpp_class_get_static_field_data", "pointer", ["pointer"]);
        },
        get classGetValueTypeSize() {
            return r("il2cpp_class_value_size", "int32", ["pointer", "pointer"]);
        },
        get classGetType() {
            return r("il2cpp_class_get_type", "pointer", ["pointer"]);
        },
        get classHasReferences() {
            return r("il2cpp_class_has_references", "bool", ["pointer"]);
        },
        get classInitialize() {
            return r("il2cpp_runtime_class_init", "void", ["pointer"]);
        },
        get classIsAbstract() {
            return r("il2cpp_class_is_abstract", "bool", ["pointer"]);
        },
        get classIsAssignableFrom() {
            return r("il2cpp_class_is_assignable_from", "bool", ["pointer", "pointer"]);
        },
        get classIsBlittable() {
            return r("il2cpp_class_is_blittable", "bool", ["pointer"]);
        },
        get classIsEnum() {
            return r("il2cpp_class_is_enum", "bool", ["pointer"]);
        },
        get classIsGeneric() {
            return r("il2cpp_class_is_generic", "bool", ["pointer"]);
        },
        get classIsInflated() {
            return r("il2cpp_class_is_inflated", "bool", ["pointer"]);
        },
        get classIsInterface() {
            return r("il2cpp_class_is_interface", "bool", ["pointer"]);
        },
        get classIsSubclassOf() {
            return r("il2cpp_class_is_subclass_of", "bool", ["pointer", "pointer", "bool"]);
        },
        get classIsValueType() {
            return r("il2cpp_class_is_valuetype", "bool", ["pointer"]);
        },
        get domainGetAssemblyFromName() {
            return r("il2cpp_domain_assembly_open", "pointer", ["pointer", "pointer"]);
        },
        get domainGet() {
            return r("il2cpp_domain_get", "pointer", []);
        },
        get domainGetAssemblies() {
            return r("il2cpp_domain_get_assemblies", "pointer", ["pointer", "pointer"]);
        },
        get fieldGetClass() {
            return r("il2cpp_field_get_parent", "pointer", ["pointer"]);
        },
        get fieldGetFlags() {
            return r("il2cpp_field_get_flags", "int", ["pointer"]);
        },
        get fieldGetName() {
            return r("il2cpp_field_get_name", "pointer", ["pointer"]);
        },
        get fieldGetOffset() {
            return r("il2cpp_field_get_offset", "int32", ["pointer"]);
        },
        get fieldGetStaticValue() {
            return r("il2cpp_field_static_get_value", "void", ["pointer", "pointer"]);
        },
        get fieldGetType() {
            return r("il2cpp_field_get_type", "pointer", ["pointer"]);
        },
        get fieldSetStaticValue() {
            return r("il2cpp_field_static_set_value", "void", ["pointer", "pointer"]);
        },
        get free() {
            return r("il2cpp_free", "void", ["pointer"]);
        },
        get gcCollect() {
            return r("il2cpp_gc_collect", "void", ["int"]);
        },
        get gcCollectALittle() {
            return r("il2cpp_gc_collect_a_little", "void", []);
        },
        get gcDisable() {
            return r("il2cpp_gc_disable", "void", []);
        },
        get gcEnable() {
            return r("il2cpp_gc_enable", "void", []);
        },
        get gcGetHeapSize() {
            return r("il2cpp_gc_get_heap_size", "int64", []);
        },
        get gcGetMaxTimeSlice() {
            return r("il2cpp_gc_get_max_time_slice_ns", "int64", []);
        },
        get gcGetUsedSize() {
            return r("il2cpp_gc_get_used_size", "int64", []);
        },
        get gcHandleGetTarget() {
            return r("il2cpp_gchandle_get_target", "pointer", ["uint32"]);
        },
        get gcHandleFree() {
            return r("il2cpp_gchandle_free", "void", ["uint32"]);
        },
        get gcHandleNew() {
            return r("il2cpp_gchandle_new", "uint32", ["pointer", "bool"]);
        },
        get gcHandleNewWeakRef() {
            return r("il2cpp_gchandle_new_weakref", "uint32", ["pointer", "bool"]);
        },
        get gcIsDisabled() {
            return r("il2cpp_gc_is_disabled", "bool", []);
        },
        get gcIsIncremental() {
            return r("il2cpp_gc_is_incremental", "bool", []);
        },
        get gcSetMaxTimeSlice() {
            return r("il2cpp_gc_set_max_time_slice_ns", "void", ["int64"]);
        },
        get gcStartIncrementalCollection() {
            return r("il2cpp_gc_start_incremental_collection", "void", []);
        },
        get gcStartWorld() {
            return r("il2cpp_start_gc_world", "void", []);
        },
        get gcStopWorld() {
            return r("il2cpp_stop_gc_world", "void", []);
        },
        get getCorlib() {
            return r("il2cpp_get_corlib", "pointer", []);
        },
        get imageGetAssembly() {
            return r("il2cpp_image_get_assembly", "pointer", ["pointer"]);
        },
        get imageGetClass() {
            return r("il2cpp_image_get_class", "pointer", ["pointer", "uint"]);
        },
        get imageGetClassCount() {
            return r("il2cpp_image_get_class_count", "uint32", ["pointer"]);
        },
        get imageGetName() {
            return r("il2cpp_image_get_name", "pointer", ["pointer"]);
        },
        get initialize() {
            return r("il2cpp_init", "void", ["pointer"]);
        },
        get livenessAllocateStruct() {
            return r("il2cpp_unity_liveness_allocate_struct", "pointer", ["pointer", "int", "pointer", "pointer", "pointer"]);
        },
        get livenessCalculationBegin() {
            return r("il2cpp_unity_liveness_calculation_begin", "pointer", ["pointer", "int", "pointer", "pointer", "pointer", "pointer"]);
        },
        get livenessCalculationEnd() {
            return r("il2cpp_unity_liveness_calculation_end", "void", ["pointer"]);
        },
        get livenessCalculationFromStatics() {
            return r("il2cpp_unity_liveness_calculation_from_statics", "void", ["pointer"]);
        },
        get livenessFinalize() {
            return r("il2cpp_unity_liveness_finalize", "void", ["pointer"]);
        },
        get livenessFreeStruct() {
            return r("il2cpp_unity_liveness_free_struct", "void", ["pointer"]);
        },
        get memorySnapshotCapture() {
            return r("il2cpp_capture_memory_snapshot", "pointer", []);
        },
        get memorySnapshotFree() {
            return r("il2cpp_free_captured_memory_snapshot", "void", ["pointer"]);
        },
        get memorySnapshotGetClasses() {
            return r("il2cpp_memory_snapshot_get_classes", "pointer", ["pointer", "pointer"]);
        },
        get memorySnapshotGetObjects() {
            return r("il2cpp_memory_snapshot_get_objects", "pointer", ["pointer", "pointer"]);
        },
        get methodGetClass() {
            return r("il2cpp_method_get_class", "pointer", ["pointer"]);
        },
        get methodGetFlags() {
            return r("il2cpp_method_get_flags", "uint32", ["pointer", "pointer"]);
        },
        get methodGetName() {
            return r("il2cpp_method_get_name", "pointer", ["pointer"]);
        },
        get methodGetObject() {
            return r("il2cpp_method_get_object", "pointer", ["pointer", "pointer"]);
        },
        get methodGetParameterCount() {
            return r("il2cpp_method_get_param_count", "uint8", ["pointer"]);
        },
        get methodGetParameterName() {
            return r("il2cpp_method_get_param_name", "pointer", ["pointer", "uint32"]);
        },
        get methodGetParameters() {
            return r("il2cpp_method_get_parameters", "pointer", ["pointer", "pointer"]);
        },
        get methodGetParameterType() {
            return r("il2cpp_method_get_param", "pointer", ["pointer", "uint32"]);
        },
        get methodGetReturnType() {
            return r("il2cpp_method_get_return_type", "pointer", ["pointer"]);
        },
        get methodIsGeneric() {
            return r("il2cpp_method_is_generic", "bool", ["pointer"]);
        },
        get methodIsInflated() {
            return r("il2cpp_method_is_inflated", "bool", ["pointer"]);
        },
        get methodIsInstance() {
            return r("il2cpp_method_is_instance", "bool", ["pointer"]);
        },
        get monitorEnter() {
            return r("il2cpp_monitor_enter", "void", ["pointer"]);
        },
        get monitorExit() {
            return r("il2cpp_monitor_exit", "void", ["pointer"]);
        },
        get monitorPulse() {
            return r("il2cpp_monitor_pulse", "void", ["pointer"]);
        },
        get monitorPulseAll() {
            return r("il2cpp_monitor_pulse_all", "void", ["pointer"]);
        },
        get monitorTryEnter() {
            return r("il2cpp_monitor_try_enter", "bool", ["pointer", "uint32"]);
        },
        get monitorTryWait() {
            return r("il2cpp_monitor_try_wait", "bool", ["pointer", "uint32"]);
        },
        get monitorWait() {
            return r("il2cpp_monitor_wait", "void", ["pointer"]);
        },
        get objectGetClass() {
            return r("il2cpp_object_get_class", "pointer", ["pointer"]);
        },
        get objectGetVirtualMethod() {
            return r("il2cpp_object_get_virtual_method", "pointer", ["pointer", "pointer"]);
        },
        get objectInitialize() {
            return r("il2cpp_runtime_object_init_exception", "void", ["pointer", "pointer"]);
        },
        get objectNew() {
            return r("il2cpp_object_new", "pointer", ["pointer"]);
        },
        get objectGetSize() {
            return r("il2cpp_object_get_size", "uint32", ["pointer"]);
        },
        get objectUnbox() {
            return r("il2cpp_object_unbox", "pointer", ["pointer"]);
        },
        get resolveInternalCall() {
            return r("il2cpp_resolve_icall", "pointer", ["pointer"]);
        },
        get stringGetChars() {
            return r("il2cpp_string_chars", "pointer", ["pointer"]);
        },
        get stringGetLength() {
            return r("il2cpp_string_length", "int32", ["pointer"]);
        },
        get stringNew() {
            return r("il2cpp_string_new", "pointer", ["pointer"]);
        },
        get valueTypeBox() {
            return r("il2cpp_value_box", "pointer", ["pointer", "pointer"]);
        },
        get threadAttach() {
            return r("il2cpp_thread_attach", "pointer", ["pointer"]);
        },
        get threadDetach() {
            return r("il2cpp_thread_detach", "void", ["pointer"]);
        },
        get threadGetAttachedThreads() {
            return r("il2cpp_thread_get_all_attached_threads", "pointer", ["pointer"]);
        },
        get threadGetCurrent() {
            return r("il2cpp_thread_current", "pointer", []);
        },
        get threadIsVm() {
            return r("il2cpp_is_vm_thread", "bool", ["pointer"]);
        },
        get typeGetClass() {
            return r("il2cpp_class_from_type", "pointer", ["pointer"]);
        },
        get typeGetName() {
            return r("il2cpp_type_get_name", "pointer", ["pointer"]);
        },
        get typeGetObject() {
            return r("il2cpp_type_get_object", "pointer", ["pointer"]);
        },
        get typeGetTypeEnum() {
            return r("il2cpp_type_get_type", "int", ["pointer"]);
        }
    };
    decorate(Il2Cpp.api, lazy);
    getter(Il2Cpp, "memorySnapshotApi", () => new CModule("#include <stdint.h>\n#include <string.h>\n\ntypedef struct Il2CppManagedMemorySnapshot Il2CppManagedMemorySnapshot;\ntypedef struct Il2CppMetadataType Il2CppMetadataType;\n\nstruct Il2CppManagedMemorySnapshot\n{\n  struct Il2CppManagedHeap\n  {\n    uint32_t section_count;\n    void * sections;\n  } heap;\n  struct Il2CppStacks\n  {\n    uint32_t stack_count;\n    void * stacks;\n  } stacks;\n  struct Il2CppMetadataSnapshot\n  {\n    uint32_t type_count;\n    Il2CppMetadataType * types;\n  } metadata_snapshot;\n  struct Il2CppGCHandles\n  {\n    uint32_t tracked_object_count;\n    void ** pointers_to_objects;\n  } gc_handles;\n  struct Il2CppRuntimeInformation\n  {\n    uint32_t pointer_size;\n    uint32_t object_header_size;\n    uint32_t array_header_size;\n    uint32_t array_bounds_offset_in_header;\n    uint32_t array_size_offset_in_header;\n    uint32_t allocation_granularity;\n  } runtime_information;\n  void * additional_user_information;\n};\n\nstruct Il2CppMetadataType\n{\n  uint32_t flags;\n  void * fields;\n  uint32_t field_count;\n  uint32_t statics_size;\n  uint8_t * statics;\n  uint32_t base_or_element_type_index;\n  char * name;\n  const char * assembly_name;\n  uint64_t type_info_address;\n  uint32_t size;\n};\n\nuintptr_t\nil2cpp_memory_snapshot_get_classes (\n    const Il2CppManagedMemorySnapshot * snapshot, Il2CppMetadataType ** iter)\n{\n  const int zero = 0;\n  const void * null = 0;\n\n  if (iter != NULL && snapshot->metadata_snapshot.type_count > zero)\n  {\n    if (*iter == null)\n    {\n      *iter = snapshot->metadata_snapshot.types;\n      return (uintptr_t) (*iter)->type_info_address;\n    }\n    else\n    {\n      Il2CppMetadataType * metadata_type = *iter + 1;\n\n      if (metadata_type < snapshot->metadata_snapshot.types +\n                              snapshot->metadata_snapshot.type_count)\n      {\n        *iter = metadata_type;\n        return (uintptr_t) (*iter)->type_info_address;\n      }\n    }\n  }\n  return 0;\n}\n\nvoid **\nil2cpp_memory_snapshot_get_objects (\n    const Il2CppManagedMemorySnapshot * snapshot, uint32_t * size)\n{\n  *size = snapshot->gc_handles.tracked_object_count;\n  return snapshot->gc_handles.pointers_to_objects;\n}\n"), lazy);
    function r(exportName, retType, argTypes) {
        const handle = globalThis.IL2CPP_EXPORTS?.[exportName]?.() ?? Il2Cpp.module.findExportByName(exportName) ?? Il2Cpp.memorySnapshotApi[exportName];
        return new NativeFunction(handle ?? raise(`couldn't resolve export ${exportName}`), retType, argTypes);
    }
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    Il2Cpp.application = {
        /** */
        get dataPath() {
            return unityEngineCall("get_persistentDataPath");
        },
        /** */
        get identifier() {
            return unityEngineCall("get_identifier") ?? unityEngineCall("get_bundleIdentifier");
        },
        /** Gets the version of the application */
        get version() {
            return unityEngineCall("get_version");
        }
    };
    // prettier-ignore
    getter(Il2Cpp, "unityVersion", () => {
        try {
            const unityVersion = globalThis.IL2CPP_UNITY_VERSION ?? unityEngineCall("get_unityVersion");
            if (unityVersion != null) {
                return unityVersion;
            }
        }
        catch (_) {
        }
        const searchPattern = "69 6c 32 63 70 70";
        for (const range of Il2Cpp.module.enumerateRanges("r--").concat(Process.getRangeByAddress(Il2Cpp.module.base))) {
            for (let { address } of Memory.scanSync(range.base, range.size, searchPattern)) {
                while (address.readU8() != 0) {
                    address = address.sub(1);
                }
                const match = UnityVersion.find(address.add(1).readCString());
                if (match != undefined) {
                    return match;
                }
            }
        }
        raise("couldn't determine the Unity version, please specify it manually");
    }, lazy);
    // prettier-ignore
    getter(Il2Cpp, "unityVersionIsBelow201830", () => {
        return UnityVersion.lt(Il2Cpp.unityVersion, "2018.3.0");
    }, lazy);
    // prettier-ignore
    getter(Il2Cpp, "unityVersionIsBelow202120", () => {
        return UnityVersion.lt(Il2Cpp.unityVersion, "2021.2.0");
    }, lazy);
    function unityEngineCall(method) {
        const handle = Il2Cpp.api.resolveInternalCall(Memory.allocUtf8String("UnityEngine.Application::" + method));
        const nativeFunction = new NativeFunction(handle, "pointer", []);
        return nativeFunction.isNull() ? null : new Il2Cpp.String(nativeFunction()).asNullable()?.content ?? null;
    }
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    /** Dumps the application. */
    function dump(fileName, path) {
        fileName = fileName ?? `${Il2Cpp.application.identifier ?? "unknown"}_${Il2Cpp.application.version ?? "unknown"}.cs`;
        const destination = `${path ?? Il2Cpp.application.dataPath}/${fileName}`;
        const file = new File(destination, "w");
        for (const assembly of Il2Cpp.domain.assemblies) {
            inform(`dumping ${assembly.name}...`);
            for (const klass of assembly.image.classes) {
                file.write(`${klass}\n\n`);
            }
        }
        file.flush();
        file.close();
        ok(`dump saved to ${destination}`);
    }
    Il2Cpp.dump = dump;
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    /** */
    function installExceptionListener(targetThread = "current") {
        const currentThread = Il2Cpp.api.threadGetCurrent();
        return Interceptor.attach(Il2Cpp.module.getExportByName("__cxa_throw"), function (args) {
            if (targetThread == "current" && !Il2Cpp.api.threadGetCurrent().equals(currentThread)) {
                return;
            }
            inform(new Il2Cpp.Object(args[0].readPointer()));
        });
    }
    Il2Cpp.installExceptionListener = installExceptionListener;
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    /** Creates a filter which includes `element`s whose type can be assigned to `klass` variables. */
    function is(klass) {
        return (element) => {
            if (element instanceof Il2Cpp.Class) {
                return klass.isAssignableFrom(element);
            }
            else {
                return klass.isAssignableFrom(element.class);
            }
        };
    }
    Il2Cpp.is = is;
    /** Creates a filter which includes `element`s whose type corresponds to `klass` type. */
    function isExactly(klass) {
        return (element) => {
            if (element instanceof Il2Cpp.Class) {
                return element.equals(klass);
            }
            else {
                return element.class.equals(klass);
            }
        };
    }
    Il2Cpp.isExactly = isExactly;
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    Il2Cpp.gc = {
        /** Gets the heap size in bytes. */
        get heapSize() {
            return Il2Cpp.api.gcGetHeapSize();
        },
        /** Determines whether the garbage collector is disabled. */
        get isEnabled() {
            return !Il2Cpp.api.gcIsDisabled();
        },
        /** Determines whether the garbage collector is incremental. */
        get isIncremental() {
            return !!Il2Cpp.api.gcIsIncremental();
        },
        /** Gets the number of nanoseconds the garbage collector can spend in a collection step. */
        get maxTimeSlice() {
            return Il2Cpp.api.gcGetMaxTimeSlice();
        },
        /** Gets the used heap size in bytes. */
        get usedHeapSize() {
            return Il2Cpp.api.gcGetUsedSize();
        },
        /** Enables or disables the garbage collector. */
        set isEnabled(value) {
            value ? Il2Cpp.api.gcEnable() : Il2Cpp.api.gcDisable();
        },
        /** Sets the number of nanoseconds the garbage collector can spend in a collection step. */
        set maxTimeSlice(nanoseconds) {
            Il2Cpp.api.gcSetMaxTimeSlice(nanoseconds);
        },
        /** Returns the heap allocated objects of the specified class. This variant reads GC descriptors. */
        choose(klass) {
            const matches = [];
            const callback = (objects, size) => {
                for (let i = 0; i < size; i++) {
                    matches.push(new Il2Cpp.Object(objects.add(i * Process.pointerSize).readPointer()));
                }
            };
            const chooseCallback = new NativeCallback(callback, "void", ["pointer", "int", "pointer"]);
            if (Il2Cpp.unityVersionIsBelow202120) {
                const onWorld = new NativeCallback(() => { }, "void", []);
                const state = Il2Cpp.api.livenessCalculationBegin(klass, 0, chooseCallback, NULL, onWorld, onWorld);
                Il2Cpp.api.livenessCalculationFromStatics(state);
                Il2Cpp.api.livenessCalculationEnd(state);
            }
            else {
                const realloc = (handle, size) => {
                    if (!handle.isNull() && size.compare(0) == 0) {
                        Il2Cpp.free(handle);
                        return NULL;
                    }
                    else {
                        return Il2Cpp.alloc(size);
                    }
                };
                const reallocCallback = new NativeCallback(realloc, "pointer", ["pointer", "size_t", "pointer"]);
                this.stopWorld();
                const state = Il2Cpp.api.livenessAllocateStruct(klass, 0, chooseCallback, NULL, reallocCallback);
                Il2Cpp.api.livenessCalculationFromStatics(state);
                Il2Cpp.api.livenessFinalize(state);
                this.startWorld();
                Il2Cpp.api.livenessFreeStruct(state);
            }
            return matches;
        },
        /** Forces a garbage collection of the specified generation. */
        collect(generation) {
            Il2Cpp.api.gcCollect(generation < 0 ? 0 : generation > 2 ? 2 : generation);
        },
        /** Forces a garbage collection. */
        collectALittle() {
            Il2Cpp.api.gcCollectALittle();
        },
        /** Resumes all the previously stopped threads. */
        startWorld() {
            return Il2Cpp.api.gcStartWorld();
        },
        /** Performs an incremental garbage collection. */
        startIncrementalCollection() {
            return Il2Cpp.api.gcStartIncrementalCollection();
        },
        /** Stops all threads which may access the garbage collected heap, other than the caller. */
        stopWorld() {
            return Il2Cpp.api.gcStopWorld();
        }
    };
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    /** Allocates the given amount of bytes. */
    function alloc(size = Process.pointerSize) {
        return Il2Cpp.api.alloc(size);
    }
    Il2Cpp.alloc = alloc;
    /** Frees memory. */
    function free(pointer) {
        return Il2Cpp.api.free(pointer);
    }
    Il2Cpp.free = free;
    /** @internal */
    function read(pointer, type) {
        switch (type.typeEnum) {
            case Il2Cpp.Type.enum.boolean:
                return !!pointer.readS8();
            case Il2Cpp.Type.enum.byte:
                return pointer.readS8();
            case Il2Cpp.Type.enum.unsignedByte:
                return pointer.readU8();
            case Il2Cpp.Type.enum.short:
                return pointer.readS16();
            case Il2Cpp.Type.enum.unsignedShort:
                return pointer.readU16();
            case Il2Cpp.Type.enum.int:
                return pointer.readS32();
            case Il2Cpp.Type.enum.unsignedInt:
                return pointer.readU32();
            case Il2Cpp.Type.enum.char:
                return pointer.readU16();
            case Il2Cpp.Type.enum.long:
                return pointer.readS64();
            case Il2Cpp.Type.enum.unsignedLong:
                return pointer.readU64();
            case Il2Cpp.Type.enum.float:
                return pointer.readFloat();
            case Il2Cpp.Type.enum.double:
                return pointer.readDouble();
            case Il2Cpp.Type.enum.nativePointer:
            case Il2Cpp.Type.enum.unsignedNativePointer:
                return pointer.readPointer();
            case Il2Cpp.Type.enum.pointer:
                return new Il2Cpp.Pointer(pointer.readPointer(), type.class.baseType);
            case Il2Cpp.Type.enum.valueType:
                return new Il2Cpp.ValueType(pointer, type);
            case Il2Cpp.Type.enum.object:
            case Il2Cpp.Type.enum.class:
                return new Il2Cpp.Object(pointer.readPointer());
            case Il2Cpp.Type.enum.genericInstance:
                return type.class.isValueType ? new Il2Cpp.ValueType(pointer, type) : new Il2Cpp.Object(pointer.readPointer());
            case Il2Cpp.Type.enum.string:
                return new Il2Cpp.String(pointer.readPointer());
            case Il2Cpp.Type.enum.array:
            case Il2Cpp.Type.enum.multidimensionalArray:
                return new Il2Cpp.Array(pointer.readPointer());
        }
        raise(`couldn't read the value from ${pointer} using an unhandled or unknown type ${type.name} (${type.typeEnum}), please file an issue`);
    }
    Il2Cpp.read = read;
    /** @internal */
    function write(pointer, value, type) {
        switch (type.typeEnum) {
            case Il2Cpp.Type.enum.boolean:
                return pointer.writeS8(+value);
            case Il2Cpp.Type.enum.byte:
                return pointer.writeS8(value);
            case Il2Cpp.Type.enum.unsignedByte:
                return pointer.writeU8(value);
            case Il2Cpp.Type.enum.short:
                return pointer.writeS16(value);
            case Il2Cpp.Type.enum.unsignedShort:
                return pointer.writeU16(value);
            case Il2Cpp.Type.enum.int:
                return pointer.writeS32(value);
            case Il2Cpp.Type.enum.unsignedInt:
                return pointer.writeU32(value);
            case Il2Cpp.Type.enum.char:
                return pointer.writeU16(value);
            case Il2Cpp.Type.enum.long:
                return pointer.writeS64(value);
            case Il2Cpp.Type.enum.unsignedLong:
                return pointer.writeU64(value);
            case Il2Cpp.Type.enum.float:
                return pointer.writeFloat(value);
            case Il2Cpp.Type.enum.double:
                return pointer.writeDouble(value);
            case Il2Cpp.Type.enum.nativePointer:
            case Il2Cpp.Type.enum.unsignedNativePointer:
            case Il2Cpp.Type.enum.pointer:
            case Il2Cpp.Type.enum.string:
            case Il2Cpp.Type.enum.array:
            case Il2Cpp.Type.enum.multidimensionalArray:
                return pointer.writePointer(value);
            case Il2Cpp.Type.enum.valueType:
                return Memory.copy(pointer, value, type.class.valueTypeSize), pointer;
            case Il2Cpp.Type.enum.object:
            case Il2Cpp.Type.enum.class:
            case Il2Cpp.Type.enum.genericInstance:
                return value instanceof Il2Cpp.ValueType ? (Memory.copy(pointer, value, type.class.valueTypeSize), pointer) : pointer.writePointer(value);
        }
        raise(`couldn't write value ${value} to ${pointer} using an unhandled or unknown type ${type.name} (${type.typeEnum}), please file an issue`);
    }
    Il2Cpp.write = write;
    /** @internal */
    function fromFridaValue(value, type) {
        if (globalThis.Array.isArray(value)) {
            const handle = Memory.alloc(type.class.valueTypeSize);
            const fields = type.class.fields.filter(_ => !_.isStatic);
            for (let i = 0; i < fields.length; i++) {
                const convertedValue = fromFridaValue(value[i], fields[i].type);
                write(handle.add(fields[i].offset).sub(Il2Cpp.Object.headerSize), convertedValue, fields[i].type);
            }
            return new Il2Cpp.ValueType(handle, type);
        }
        else if (value instanceof NativePointer) {
            if (type.isByReference) {
                return new Il2Cpp.Reference(value, type);
            }
            switch (type.typeEnum) {
                case Il2Cpp.Type.enum.pointer:
                    return new Il2Cpp.Pointer(value, type.class.baseType);
                case Il2Cpp.Type.enum.string:
                    return new Il2Cpp.String(value);
                case Il2Cpp.Type.enum.class:
                case Il2Cpp.Type.enum.genericInstance:
                case Il2Cpp.Type.enum.object:
                    return new Il2Cpp.Object(value);
                case Il2Cpp.Type.enum.array:
                case Il2Cpp.Type.enum.multidimensionalArray:
                    return new Il2Cpp.Array(value);
                default:
                    return value;
            }
        }
        else if (type.typeEnum == Il2Cpp.Type.enum.boolean) {
            return !!value;
        }
        else if (type.typeEnum == Il2Cpp.Type.enum.valueType && type.class.isEnum) {
            return fromFridaValue([value], type);
        }
        else {
            return value;
        }
    }
    Il2Cpp.fromFridaValue = fromFridaValue;
    /** @internal */
    function toFridaValue(value) {
        if (typeof value == "boolean") {
            return +value;
        }
        else if (value instanceof Il2Cpp.ValueType) {
            if (value.type.class.isEnum) {
                return value.field("value__").value;
            }
            else {
                const _ = value.type.class.fields.filter(_ => !_.isStatic).map(_ => toFridaValue(_.withHolder(value).value));
                return _.length == 0 ? [0] : _;
            }
        }
        else {
            return value;
        }
    }
    Il2Cpp.toFridaValue = toFridaValue;
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    getter(Il2Cpp, "module", () => {
        const [moduleName, fallback] = getExpectedModuleNames();
        return Process.findModuleByName(moduleName) ?? Process.getModuleByName(fallback);
    });
    /** @internal Waits for Unity and Il2Cpp native libraries to be loaded and initialized. */
    async function initialize(blocking = false) {
        Reflect.defineProperty(Il2Cpp, "module", {
            // prettier-ignore
            value: Process.platform == "darwin"
                ? Process.findModuleByAddress(DebugSymbol.fromName("il2cpp_init").address)
                    ?? await forModule(...getExpectedModuleNames())
                : await forModule(...getExpectedModuleNames())
        });
        if (Il2Cpp.api.getCorlib().isNull()) {
            return await new Promise(resolve => {
                const interceptor = Interceptor.attach(Il2Cpp.api.initialize, {
                    onLeave() {
                        interceptor.detach();
                        blocking ? resolve(true) : setImmediate(() => resolve(false));
                    }
                });
            });
        }
        return false;
    }
    Il2Cpp.initialize = initialize;
    function getExpectedModuleNames() {
        if (globalThis.IL2CPP_MODULE_NAME) {
            return [globalThis.IL2CPP_MODULE_NAME];
        }
        switch (Process.platform) {
            case "linux":
                return [Android.apiLevel ? "libil2cpp.so" : "GameAssembly.so"];
            case "windows":
                return ["GameAssembly.dll"];
            case "darwin":
                return ["UnityFramework", "GameAssembly.dylib"];
        }
        raise(`${Process.platform} is not supported yet`);
    }
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    /** Attaches the caller thread to Il2Cpp domain and executes the given block.  */
    async function perform(block, flag = "bind") {
        try {
            const isInMainThread = await Il2Cpp.initialize(flag == "main");
            if (flag == "main" && !isInMainThread) {
                return perform(() => Il2Cpp.mainThread.schedule(block), "free");
            }
            let thread = Il2Cpp.currentThread;
            const isForeignThread = thread == null;
            thread ??= Il2Cpp.domain.attach();
            const result = block();
            if (isForeignThread) {
                if (flag == "free") {
                    thread.detach();
                }
                else if (flag == "bind") {
                    Script.bindWeak(globalThis, () => thread.detach());
                }
            }
            return result instanceof Promise ? await result : result;
        }
        catch (error) {
            Script.nextTick(_ => { throw _; }, error); // prettier-ignore
            return Promise.reject(error);
        }
    }
    Il2Cpp.perform = perform;
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    class Tracer {
        /** @internal */
        #state = {
            depth: 0,
            buffer: [],
            history: new Set(),
            flush: () => {
                if (this.#state.depth == 0) {
                    const message = `\n${this.#state.buffer.join("\n")}\n`;
                    if (this.#verbose) {
                        inform(message);
                    }
                    else {
                        const hash = cyrb53(message);
                        if (!this.#state.history.has(hash)) {
                            this.#state.history.add(hash);
                            inform(message);
                        }
                    }
                    this.#state.buffer.length = 0;
                }
            }
        };
        /** @internal */
        #threadId = Il2Cpp.mainThread.id;
        /** @internal */
        #verbose = false;
        /** @internal */
        #applier;
        /** @internal */
        #targets = [];
        /** @internal */
        #domain;
        /** @internal */
        #assemblies;
        /** @internal */
        #classes;
        /** @internal */
        #methods;
        /** @internal */
        #assemblyFilter;
        /** @internal */
        #classFilter;
        /** @internal */
        #methodFilter;
        /** @internal */
        #parameterFilter;
        constructor(applier) {
            this.#applier = applier;
        }
        /** */
        thread(thread) {
            this.#threadId = thread.id;
            return this;
        }
        /** Determines whether print duplicate logs. */
        verbose(value) {
            this.#verbose = value;
            return this;
        }
        /** Sets the application domain as the place where to find the target methods. */
        domain() {
            this.#domain = Il2Cpp.domain;
            return this;
        }
        /** Sets the passed `assemblies` as the place where to find the target methods. */
        assemblies(...assemblies) {
            this.#assemblies = assemblies;
            return this;
        }
        /** Sets the passed `classes` as the place where to find the target methods. */
        classes(...classes) {
            this.#classes = classes;
            return this;
        }
        /** Sets the passed `methods` as the target methods. */
        methods(...methods) {
            this.#methods = methods;
            return this;
        }
        /** Filters the assemblies where to find the target methods. */
        filterAssemblies(filter) {
            this.#assemblyFilter = filter;
            return this;
        }
        /** Filters the classes where to find the target methods. */
        filterClasses(filter) {
            this.#classFilter = filter;
            return this;
        }
        /** Filters the target methods. */
        filterMethods(filter) {
            this.#methodFilter = filter;
            return this;
        }
        /** Filters the target methods. */
        filterParameters(filter) {
            this.#parameterFilter = filter;
            return this;
        }
        /** Commits the current changes by finding the target methods. */
        and() {
            const filterMethod = (method) => {
                if (this.#parameterFilter == undefined) {
                    this.#targets.push(method);
                    return;
                }
                for (const parameter of method.parameters) {
                    if (this.#parameterFilter(parameter)) {
                        this.#targets.push(method);
                        break;
                    }
                }
            };
            const filterMethods = (values) => {
                for (const method of values) {
                    filterMethod(method);
                }
            };
            const filterClass = (klass) => {
                if (this.#methodFilter == undefined) {
                    filterMethods(klass.methods);
                    return;
                }
                for (const method of klass.methods) {
                    if (this.#methodFilter(method)) {
                        filterMethod(method);
                    }
                }
            };
            const filterClasses = (values) => {
                for (const klass of values) {
                    filterClass(klass);
                }
            };
            const filterAssembly = (assembly) => {
                if (this.#classFilter == undefined) {
                    filterClasses(assembly.image.classes);
                    return;
                }
                for (const klass of assembly.image.classes) {
                    if (this.#classFilter(klass)) {
                        filterClass(klass);
                    }
                }
            };
            const filterAssemblies = (assemblies) => {
                for (const assembly of assemblies) {
                    filterAssembly(assembly);
                }
            };
            const filterDomain = (domain) => {
                if (this.#assemblyFilter == undefined) {
                    filterAssemblies(domain.assemblies);
                    return;
                }
                for (const assembly of domain.assemblies) {
                    if (this.#assemblyFilter(assembly)) {
                        filterAssembly(assembly);
                    }
                }
            };
            this.#methods
                ? filterMethods(this.#methods)
                : this.#classes
                    ? filterClasses(this.#classes)
                    : this.#assemblies
                        ? filterAssemblies(this.#assemblies)
                        : this.#domain
                            ? filterDomain(this.#domain)
                            : undefined;
            this.#assemblies = undefined;
            this.#classes = undefined;
            this.#methods = undefined;
            this.#assemblyFilter = undefined;
            this.#classFilter = undefined;
            this.#methodFilter = undefined;
            this.#parameterFilter = undefined;
            return this;
        }
        /** Starts tracing. */
        attach() {
            for (const target of this.#targets) {
                if (!target.virtualAddress.isNull()) {
                    try {
                        this.#applier(target, this.#state, this.#threadId);
                    }
                    catch (e) {
                        switch (e.message) {
                            case /unable to intercept function at \w+; please file a bug/.exec(e.message)?.input:
                            case "already replaced this function":
                                break;
                            default:
                                throw e;
                        }
                    }
                }
            }
        }
    }
    Il2Cpp.Tracer = Tracer;
    /** */
    function trace(parameters = false) {
        const applier = () => (method, state, threadId) => {
            const paddedVirtualAddress = method.relativeVirtualAddress.toString(16).padStart(8, "0");
            Interceptor.attach(method.virtualAddress, {
                onEnter() {
                    if (this.threadId == threadId) {
                        // prettier-ignore
                        state.buffer.push(`\x1b[2m0x${paddedVirtualAddress}\x1b[0m ${`â”‚ `.repeat(state.depth++)}â”Œâ”€\x1b[35m${method.class.type.name}::\x1b[1m${method.name}\x1b[0m\x1b[0m`);
                    }
                },
                onLeave() {
                    if (this.threadId == threadId) {
                        // prettier-ignore
                        state.buffer.push(`\x1b[2m0x${paddedVirtualAddress}\x1b[0m ${`â”‚ `.repeat(--state.depth)}â””â”€\x1b[33m${method.class.type.name}::\x1b[1m${method.name}\x1b[0m\x1b[0m`);
                        state.flush();
                    }
                }
            });
        };
        const applierWithParameters = () => (method, state, threadId) => {
            const paddedVirtualAddress = method.relativeVirtualAddress.toString(16).padStart(8, "0");
            const startIndex = +!method.isStatic | +Il2Cpp.unityVersionIsBelow201830;
            const callback = function (...args) {
                if (this.threadId == threadId) {
                    const thisParameter = method.isStatic ? undefined : new Il2Cpp.Parameter("this", -1, method.class.type);
                    const parameters = thisParameter ? [thisParameter].concat(method.parameters) : method.parameters;
                    // prettier-ignore
                    state.buffer.push(`\x1b[2m0x${paddedVirtualAddress}\x1b[0m ${`â”‚ `.repeat(state.depth++)}â”Œâ”€\x1b[35m${method.class.type.name}::\x1b[1m${method.name}\x1b[0m\x1b[0m(${parameters.map(e => `\x1b[32m${e.name}\x1b[0m = \x1b[31m${Il2Cpp.fromFridaValue(args[e.position + startIndex], e.type)}\x1b[0m`).join(", ")})`);
                }
                const returnValue = method.nativeFunction(...args);
                if (this.threadId == threadId) {
                    // prettier-ignore
                    state.buffer.push(`\x1b[2m0x${paddedVirtualAddress}\x1b[0m ${`â”‚ `.repeat(--state.depth)}â””â”€\x1b[33m${method.class.type.name}::\x1b[1m${method.name}\x1b[0m\x1b[0m${returnValue == undefined ? "" : ` = \x1b[36m${Il2Cpp.fromFridaValue(returnValue, method.returnType)}`}\x1b[0m`);
                    state.flush();
                }
                return returnValue;
            };
            method.revert();
            const nativeCallback = new NativeCallback(callback, method.returnType.fridaAlias, method.fridaSignature);
            Interceptor.replace(method.virtualAddress, nativeCallback);
        };
        return new Il2Cpp.Tracer(parameters ? applierWithParameters() : applier());
    }
    Il2Cpp.trace = trace;
    /** */
    function backtrace(mode) {
        const methods = Il2Cpp.domain.assemblies
            .flatMap(_ => _.image.classes.flatMap(_ => _.methods.filter(_ => !_.virtualAddress.isNull())))
            .sort((_, __) => _.virtualAddress.compare(__.virtualAddress));
        const searchInsert = (target) => {
            let left = 0;
            let right = methods.length - 1;
            while (left <= right) {
                const pivot = Math.floor((left + right) / 2);
                const comparison = methods[pivot].virtualAddress.compare(target);
                if (comparison == 0) {
                    return methods[pivot];
                }
                else if (comparison > 0) {
                    right = pivot - 1;
                }
                else {
                    left = pivot + 1;
                }
            }
            return methods[right];
        };
        const applier = () => (method, state, threadId) => {
            Interceptor.attach(method.virtualAddress, function () {
                if (this.threadId == threadId) {
                    const handles = globalThis.Thread.backtrace(this.context, mode);
                    handles.unshift(method.virtualAddress);
                    for (const handle of handles) {
                        if (handle.compare(Il2Cpp.module.base) > 0 && handle.compare(Il2Cpp.module.base.add(Il2Cpp.module.size)) < 0) {
                            const method = searchInsert(handle);
                            if (method) {
                                const offset = handle.sub(method.virtualAddress);
                                if (offset.compare(0xfff) < 0) {
                                    // prettier-ignore
                                    state.buffer.push(`\x1b[2m0x${method.relativeVirtualAddress.toString(16).padStart(8, "0")}\x1b[0m\x1b[2m+0x${offset.toString(16).padStart(3, `0`)}\x1b[0m ${method.class.type.name}::\x1b[1m${method.name}\x1b[0m`);
                                }
                            }
                        }
                    }
                    state.flush();
                }
            });
        };
        return new Il2Cpp.Tracer(applier());
    }
    Il2Cpp.backtrace = backtrace;
    /** https://stackoverflow.com/a/52171480/16885569 */
    function cyrb53(str) {
        let h1 = 0xdeadbeef;
        let h2 = 0x41c6ce57;
        for (let i = 0, ch; i < str.length; i++) {
            ch = str.charCodeAt(i);
            h1 = Math.imul(h1 ^ ch, 2654435761);
            h2 = Math.imul(h2 ^ ch, 1597334677);
        }
        h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507);
        h1 ^= Math.imul(h2 ^ (h2 >>> 13), 3266489909);
        h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507);
        h2 ^= Math.imul(h1 ^ (h1 >>> 13), 3266489909);
        return 4294967296 * (2097151 & h2) + (h1 >>> 0);
    }
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    class Array extends NativeStruct {
        /** Gets the Il2CppArray struct size, possibly equal to `Process.pointerSize * 4`. */
        static get headerSize() {
            return Il2Cpp.corlib.class("System.Array").instanceSize;
        }
        /** @internal Gets a pointer to the first element of the current array. */
        get elements() {
            // We previosly obtained an array whose content is known by calling
            // 'System.String::Split(NULL)' on a known string. However, that
            // method invocation somehow blows things up in Unity 2018.3.0f1.
            const array = Il2Cpp.string("v").object.method("ToCharArray", 0).invoke();
            // prettier-ignore
            const offset = array.handle.offsetOf(_ => _.readS16() == 118) ??
                raise("couldn't find the elements offset in the native array struct");
            // prettier-ignore
            getter(Il2Cpp.Array.prototype, "elements", function () {
                return new Il2Cpp.Pointer(this.handle.add(offset), this.elementType);
            }, lazy);
            return this.elements;
        }
        /** Gets the size of the object encompassed by the current array. */
        get elementSize() {
            return this.elementType.class.arrayElementSize;
        }
        /** Gets the type of the object encompassed by the current array. */
        get elementType() {
            return this.object.class.type.class.baseType;
        }
        /** Gets the total number of elements in all the dimensions of the current array. */
        get length() {
            return Il2Cpp.api.arrayGetLength(this);
        }
        /** Gets the encompassing object of the current array. */
        get object() {
            return new Il2Cpp.Object(this);
        }
        /** Gets the element at the specified index of the current array. */
        get(index) {
            if (index < 0 || index >= this.length) {
                raise(`cannot get element at index ${index} as the array length is ${this.length}`);
            }
            return this.elements.get(index);
        }
        /** Sets the element at the specified index of the current array. */
        set(index, value) {
            if (index < 0 || index >= this.length) {
                raise(`cannot set element at index ${index} as the array length is ${this.length}`);
            }
            this.elements.set(index, value);
        }
        /** */
        toString() {
            return this.isNull() ? "null" : `[${this.elements.read(this.length, 0)}]`;
        }
        /** Iterable. */
        *[Symbol.iterator]() {
            for (let i = 0; i < this.length; i++) {
                yield this.elements.get(i);
            }
        }
    }
    __decorate([
        lazy
    ], Array.prototype, "elementSize", null);
    __decorate([
        lazy
    ], Array.prototype, "elementType", null);
    __decorate([
        lazy
    ], Array.prototype, "length", null);
    __decorate([
        lazy
    ], Array.prototype, "object", null);
    __decorate([
        lazy
    ], Array, "headerSize", null);
    Il2Cpp.Array = Array;
    /** @internal */
    function array(klass, lengthOrElements) {
        const length = typeof lengthOrElements == "number" ? lengthOrElements : lengthOrElements.length;
        const array = new Il2Cpp.Array(Il2Cpp.api.arrayNew(klass, length));
        if (globalThis.Array.isArray(lengthOrElements)) {
            array.elements.write(lengthOrElements);
        }
        return array;
    }
    Il2Cpp.array = array;
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    let Assembly = class Assembly extends NativeStruct {
        /** Gets the image of this assembly. */
        get image() {
            let get = function () {
                return new Il2Cpp.Image(Il2Cpp.api.assemblyGetImage(this));
            };
            try {
                Il2Cpp.api.assemblyGetImage;
            }
            catch (_) {
                get = function () {
                    // We need to get the System.Reflection.Module of the current assembly;
                    // System.Reflection.Assembly::GetModulesInternal, for some reason,
                    // throws a NullReferenceExceptionin Unity 5.3.8f1, so we must rely on
                    // System.Type::get_Module instead.
                    // Now we need to get any System.Type of this assembly.
                    // We cannot use System.Reflection.Assembly::GetTypes because it may
                    // return an empty array; hence we use System.Reflection.Assembly::GetType
                    // to retrieve <Module>, a class/type that seems to be always present
                    // (despite being excluded from System.Reflection.Assembly::GetTypes).
                    return new Il2Cpp.Image(this.object
                        .method("GetType", 1)
                        .invoke(Il2Cpp.string("<Module>"))
                        .method("get_Module")
                        .invoke()
                        .field("_impl").value);
                };
            }
            getter(Il2Cpp.Assembly.prototype, "image", get, lazy);
            return this.image;
        }
        /** Gets the name of this assembly. */
        get name() {
            return this.image.name.replace(".dll", "");
        }
        /** Gets the encompassing object of the current assembly. */
        get object() {
            for (const _ of Il2Cpp.domain.object.method("GetAssemblies", 1).invoke(false)) {
                if (_.field("_mono_assembly").value.equals(this)) {
                    return _;
                }
            }
            raise("couldn't find the object of the native assembly struct");
        }
    };
    __decorate([
        lazy
    ], Assembly.prototype, "name", null);
    __decorate([
        lazy
    ], Assembly.prototype, "object", null);
    Assembly = __decorate([
        recycle
    ], Assembly);
    Il2Cpp.Assembly = Assembly;
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    let Class = class Class extends NativeStruct {
        /** Gets the actual size of the instance of the current class. */
        get actualInstanceSize() {
            const SystemString = Il2Cpp.corlib.class("System.String");
            // prettier-ignore
            const offset = SystemString.handle.offsetOf(_ => _.readInt() == SystemString.instanceSize - 2)
                ?? raise("couldn't find the actual instance size offset in the native class struct");
            // prettier-ignore
            getter(Il2Cpp.Class.prototype, "actualInstanceSize", function () {
                return this.handle.add(offset).readS32();
            }, lazy);
            return this.actualInstanceSize;
        }
        /** Gets the array class which encompass the current class. */
        get arrayClass() {
            return new Il2Cpp.Class(Il2Cpp.api.classGetArrayClass(this, 1));
        }
        /** Gets the size of the object encompassed by the current array class. */
        get arrayElementSize() {
            return Il2Cpp.api.classGetArrayElementSize(this);
        }
        /** Gets the name of the assembly in which the current class is defined. */
        get assemblyName() {
            return Il2Cpp.api.classGetAssemblyName(this).readUtf8String().replace(".dll", "");
        }
        /** Gets the class that declares the current nested class. */
        get declaringClass() {
            return new Il2Cpp.Class(Il2Cpp.api.classGetDeclaringType(this)).asNullable();
        }
        /** Gets the encompassed type of this array, reference, pointer or enum type. */
        get baseType() {
            return new Il2Cpp.Type(Il2Cpp.api.classGetBaseType(this)).asNullable();
        }
        /** Gets the class of the object encompassed or referred to by the current array, pointer or reference class. */
        get elementClass() {
            return new Il2Cpp.Class(Il2Cpp.api.classGetElementClass(this)).asNullable();
        }
        /** Gets the fields of the current class. */
        get fields() {
            return readNativeIterator(_ => Il2Cpp.api.classGetFields(this, _)).map(_ => new Il2Cpp.Field(_));
        }
        /** Gets the flags of the current class. */
        get flags() {
            return Il2Cpp.api.classGetFlags(this);
        }
        /** Gets the full name (namespace + name) of the current class. */
        get fullName() {
            return this.namespace ? `${this.namespace}.${this.name}` : this.name;
        }
        /** Gets the generics parameters of this generic class. */
        get generics() {
            if (!this.isGeneric && !this.isInflated) {
                return [];
            }
            const types = this.type.object.method("GetGenericArguments").invoke();
            return globalThis.Array.from(types).map(_ => new Il2Cpp.Class(Il2Cpp.api.classFromObject(_)));
        }
        /** Determines whether the GC has tracking references to the current class instances. */
        get hasReferences() {
            return !!Il2Cpp.api.classHasReferences(this);
        }
        /** Determines whether ther current class has a valid static constructor. */
        get hasStaticConstructor() {
            const staticConstructor = this.tryMethod(".cctor");
            return staticConstructor != null && !staticConstructor.virtualAddress.isNull();
        }
        /** Gets the image in which the current class is defined. */
        get image() {
            return new Il2Cpp.Image(Il2Cpp.api.classGetImage(this));
        }
        /** Gets the size of the instance of the current class. */
        get instanceSize() {
            return Il2Cpp.api.classGetInstanceSize(this);
        }
        /** Determines whether the current class is abstract. */
        get isAbstract() {
            return !!Il2Cpp.api.classIsAbstract(this);
        }
        /** Determines whether the current class is blittable. */
        get isBlittable() {
            return !!Il2Cpp.api.classIsBlittable(this);
        }
        /** Determines whether the current class is an enumeration. */
        get isEnum() {
            return !!Il2Cpp.api.classIsEnum(this);
        }
        /** Determines whether the current class is a generic one. */
        get isGeneric() {
            return !!Il2Cpp.api.classIsGeneric(this);
        }
        /** Determines whether the current class is inflated. */
        get isInflated() {
            return !!Il2Cpp.api.classIsInflated(this);
        }
        /** Determines whether the current class is an interface. */
        get isInterface() {
            return !!Il2Cpp.api.classIsInterface(this);
        }
        /** Determines whether the current class is a struct. */
        get isStruct() {
            return this.isValueType && !this.isEnum;
        }
        /** Determines whether the current class is a value type. */
        get isValueType() {
            return !!Il2Cpp.api.classIsValueType(this);
        }
        /** Gets the interfaces implemented or inherited by the current class. */
        get interfaces() {
            return readNativeIterator(_ => Il2Cpp.api.classGetInterfaces(this, _)).map(_ => new Il2Cpp.Class(_));
        }
        /** Gets the methods implemented by the current class. */
        get methods() {
            return readNativeIterator(_ => Il2Cpp.api.classGetMethods(this, _)).map(_ => new Il2Cpp.Method(_));
        }
        /** Gets the name of the current class. */
        get name() {
            return Il2Cpp.api.classGetName(this).readUtf8String();
        }
        /** Gets the namespace of the current class. */
        get namespace() {
            return Il2Cpp.api.classGetNamespace(this).readUtf8String();
        }
        /** Gets the classes nested inside the current class. */
        get nestedClasses() {
            return readNativeIterator(_ => Il2Cpp.api.classGetNestedClasses(this, _)).map(_ => new Il2Cpp.Class(_));
        }
        /** Gets the class from which the current class directly inherits. */
        get parent() {
            return new Il2Cpp.Class(Il2Cpp.api.classGetParent(this)).asNullable();
        }
        /** Gets the rank (number of dimensions) of the current array class. */
        get rank() {
            let rank = 0;
            const name = this.name;
            for (let i = this.name.length - 1; i > 0; i--) {
                const c = name[i];
                if (c == "]")
                    rank++;
                else if (c == "[" || rank == 0)
                    break;
                else if (c == ",")
                    rank++;
                else
                    break;
            }
            return rank;
        }
        /** Gets a pointer to the static fields of the current class. */
        get staticFieldsData() {
            return Il2Cpp.api.classGetStaticFieldData(this);
        }
        /** Gets the size of the instance - as a value type - of the current class. */
        get valueTypeSize() {
            return Il2Cpp.api.classGetValueTypeSize(this, NULL);
        }
        /** Gets the type of the current class. */
        get type() {
            return new Il2Cpp.Type(Il2Cpp.api.classGetType(this));
        }
        /** Allocates a new object of the current class. */
        alloc() {
            return new Il2Cpp.Object(Il2Cpp.api.objectNew(this));
        }
        /** Gets the field identified by the given name. */
        field(name) {
            return this.tryField(name) ?? raise(`couldn't find field ${name} in class ${this.type.name}`);
        }
        /** Builds a generic instance of the current generic class. */
        inflate(...classes) {
            if (!this.isGeneric) {
                raise(`cannot inflate class ${this.type.name} as it has no generic parameters`);
            }
            if (this.generics.length != classes.length) {
                raise(`cannot inflate class ${this.type.name} as it needs ${this.generics.length} generic parameter(s), not ${classes.length}`);
            }
            const types = classes.map(_ => _.type.object);
            const typeArray = Il2Cpp.array(Il2Cpp.corlib.class("System.Type"), types);
            const inflatedType = this.type.object.method("MakeGenericType", 1).invoke(typeArray);
            return new Il2Cpp.Class(Il2Cpp.api.classFromObject(inflatedType));
        }
        /** Calls the static constructor of the current class. */
        initialize() {
            Il2Cpp.api.classInitialize(this);
            return this;
        }
        /** Determines whether an instance of `other` class can be assigned to a variable of the current type. */
        isAssignableFrom(other) {
            return !!Il2Cpp.api.classIsAssignableFrom(this, other);
        }
        /** Determines whether the current class derives from `other` class. */
        isSubclassOf(other, checkInterfaces) {
            return !!Il2Cpp.api.classIsSubclassOf(this, other, +checkInterfaces);
        }
        /** Gets the method identified by the given name and parameter count. */
        method(name, parameterCount = -1) {
            return this.tryMethod(name, parameterCount) ?? raise(`couldn't find method ${name} in class ${this.type.name}`);
        }
        /** Gets the nested class with the given name. */
        nested(name) {
            return this.tryNested(name) ?? raise(`couldn't find nested class ${name} in class ${this.type.name}`);
        }
        /** Allocates a new object of the current class and calls its default constructor. */
        new() {
            const object = this.alloc();
            const exceptionArray = Memory.alloc(Process.pointerSize);
            Il2Cpp.api.objectInitialize(object, exceptionArray);
            const exception = exceptionArray.readPointer();
            if (!exception.isNull()) {
                raise(new Il2Cpp.Object(exception).toString());
            }
            return object;
        }
        /** Gets the field with the given name. */
        tryField(name) {
            return new Il2Cpp.Field(Il2Cpp.api.classGetFieldFromName(this, Memory.allocUtf8String(name))).asNullable();
        }
        /** Gets the method with the given name and parameter count. */
        tryMethod(name, parameterCount = -1) {
            return new Il2Cpp.Method(Il2Cpp.api.classGetMethodFromName(this, Memory.allocUtf8String(name), parameterCount)).asNullable();
        }
        /** Gets the nested class with the given name. */
        tryNested(name) {
            return this.nestedClasses.find(_ => _.name == name);
        }
        /** */
        toString() {
            const inherited = [this.parent].concat(this.interfaces);
            return `\
// ${this.assemblyName}
${this.isEnum ? `enum` : this.isStruct ? `struct` : this.isInterface ? `interface` : `class`} \
${this.type.name}\
${inherited ? ` : ${inherited.map(_ => _?.type.name).join(`, `)}` : ``}
{
    ${this.fields.join(`\n    `)}
    ${this.methods.join(`\n    `)}
}`;
        }
        /** Executes a callback for every defined class. */
        static enumerate(block) {
            const callback = new NativeCallback(_ => block(new Il2Cpp.Class(_)), "void", ["pointer", "pointer"]);
            return Il2Cpp.api.classForEach(callback, NULL);
        }
    };
    __decorate([
        lazy
    ], Class.prototype, "arrayClass", null);
    __decorate([
        lazy
    ], Class.prototype, "arrayElementSize", null);
    __decorate([
        lazy
    ], Class.prototype, "assemblyName", null);
    __decorate([
        lazy
    ], Class.prototype, "declaringClass", null);
    __decorate([
        lazy
    ], Class.prototype, "baseType", null);
    __decorate([
        lazy
    ], Class.prototype, "elementClass", null);
    __decorate([
        lazy
    ], Class.prototype, "fields", null);
    __decorate([
        lazy
    ], Class.prototype, "flags", null);
    __decorate([
        lazy
    ], Class.prototype, "fullName", null);
    __decorate([
        lazy
    ], Class.prototype, "generics", null);
    __decorate([
        lazy
    ], Class.prototype, "hasReferences", null);
    __decorate([
        lazy
    ], Class.prototype, "hasStaticConstructor", null);
    __decorate([
        lazy
    ], Class.prototype, "image", null);
    __decorate([
        lazy
    ], Class.prototype, "instanceSize", null);
    __decorate([
        lazy
    ], Class.prototype, "isAbstract", null);
    __decorate([
        lazy
    ], Class.prototype, "isBlittable", null);
    __decorate([
        lazy
    ], Class.prototype, "isEnum", null);
    __decorate([
        lazy
    ], Class.prototype, "isGeneric", null);
    __decorate([
        lazy
    ], Class.prototype, "isInflated", null);
    __decorate([
        lazy
    ], Class.prototype, "isInterface", null);
    __decorate([
        lazy
    ], Class.prototype, "isValueType", null);
    __decorate([
        lazy
    ], Class.prototype, "interfaces", null);
    __decorate([
        lazy
    ], Class.prototype, "methods", null);
    __decorate([
        lazy
    ], Class.prototype, "name", null);
    __decorate([
        lazy
    ], Class.prototype, "namespace", null);
    __decorate([
        lazy
    ], Class.prototype, "nestedClasses", null);
    __decorate([
        lazy
    ], Class.prototype, "parent", null);
    __decorate([
        lazy
    ], Class.prototype, "rank", null);
    __decorate([
        lazy
    ], Class.prototype, "staticFieldsData", null);
    __decorate([
        lazy
    ], Class.prototype, "valueTypeSize", null);
    __decorate([
        lazy
    ], Class.prototype, "type", null);
    Class = __decorate([
        recycle
    ], Class);
    Il2Cpp.Class = Class;
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    /** Creates a delegate object of the given delegate class. */
    function delegate(klass, block) {
        const SystemDelegate = Il2Cpp.corlib.class("System.Delegate");
        const SystemMulticastDelegate = Il2Cpp.corlib.class("System.MulticastDelegate");
        if (!SystemDelegate.isAssignableFrom(klass)) {
            raise(`cannot create a delegate for ${klass.type.name} as it's a non-delegate class`);
        }
        if (klass.equals(SystemDelegate) || klass.equals(SystemMulticastDelegate)) {
            raise(`cannot create a delegate for neither ${SystemDelegate.type.name} nor ${SystemMulticastDelegate.type.name}, use a subclass instead`);
        }
        const delegate = klass.alloc();
        const key = delegate.handle.toString();
        const Invoke = delegate.tryMethod("Invoke") ?? raise(`cannot create a delegate for ${klass.type.name}, there is no Invoke method`);
        delegate.method(".ctor").invoke(delegate, Invoke.handle);
        const callback = Invoke.wrap(block);
        delegate.field("method_ptr").value = callback;
        delegate.field("invoke_impl").value = callback;
        Il2Cpp._callbacksToKeepAlive[key] = callback;
        return delegate;
    }
    Il2Cpp.delegate = delegate;
    /** @internal Used to prevent eager garbage collection against NativeCallbacks. */
    Il2Cpp._callbacksToKeepAlive = {};
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    let Domain = class Domain extends NativeStruct {
        /** Gets the assemblies that have been loaded into the execution context of the application domain. */
        get assemblies() {
            let handles = readNativeList(_ => Il2Cpp.api.domainGetAssemblies(this, _));
            if (handles.length == 0) {
                const assemblyObjects = this.object.method("GetAssemblies").overload().invoke();
                handles = globalThis.Array.from(assemblyObjects).map(_ => _.field("_mono_assembly").value);
            }
            return handles.map(_ => new Il2Cpp.Assembly(_));
        }
        /** Gets the encompassing object of the application domain. */
        get object() {
            return Il2Cpp.corlib.class("System.AppDomain").method("get_CurrentDomain").invoke();
        }
        /** Opens and loads the assembly with the given name. */
        assembly(name) {
            return this.tryAssembly(name) ?? raise(`couldn't find assembly ${name}`);
        }
        /** Attached a new thread to the application domain. */
        attach() {
            return new Il2Cpp.Thread(Il2Cpp.api.threadAttach(this));
        }
        /** Opens and loads the assembly with the given name. */
        tryAssembly(name) {
            return new Il2Cpp.Assembly(Il2Cpp.api.domainGetAssemblyFromName(this, Memory.allocUtf8String(name))).asNullable();
        }
    };
    __decorate([
        lazy
    ], Domain.prototype, "assemblies", null);
    __decorate([
        lazy
    ], Domain.prototype, "object", null);
    Domain = __decorate([
        recycle
    ], Domain);
    Il2Cpp.Domain = Domain;
    // prettier-ignore
    getter(Il2Cpp, "domain", () => {
        return new Il2Cpp.Domain(Il2Cpp.api.domainGet());
    }, lazy);
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    class Field extends NativeStruct {
        /** Gets the class in which this field is defined. */
        get class() {
            return new Il2Cpp.Class(Il2Cpp.api.fieldGetClass(this));
        }
        /** Gets the flags of the current field. */
        get flags() {
            return Il2Cpp.api.fieldGetFlags(this);
        }
        /** Determines whether this field value is known at compile time. */
        get isLiteral() {
            return (this.flags & 64 /* Il2Cpp.Field.Attributes.Literal */) != 0;
        }
        /** Determines whether this field is static. */
        get isStatic() {
            return (this.flags & 16 /* Il2Cpp.Field.Attributes.Static */) != 0;
        }
        /** Determines whether this field is thread static. */
        get isThreadStatic() {
            const offset = Il2Cpp.corlib.class("System.AppDomain").field("type_resolve_in_progress").offset;
            // prettier-ignore
            getter(Il2Cpp.Field.prototype, "isThreadStatic", function () {
                return this.offset == offset;
            }, lazy);
            return this.isThreadStatic;
        }
        /** Gets the access modifier of this field. */
        get modifier() {
            switch (this.flags & 7 /* Il2Cpp.Field.Attributes.FieldAccessMask */) {
                case 1 /* Il2Cpp.Field.Attributes.Private */:
                    return "private";
                case 2 /* Il2Cpp.Field.Attributes.FamilyAndAssembly */:
                    return "private protected";
                case 3 /* Il2Cpp.Field.Attributes.Assembly */:
                    return "internal";
                case 4 /* Il2Cpp.Field.Attributes.Family */:
                    return "protected";
                case 5 /* Il2Cpp.Field.Attributes.FamilyOrAssembly */:
                    return "protected internal";
                case 6 /* Il2Cpp.Field.Attributes.Public */:
                    return "public";
            }
        }
        /** Gets the name of this field. */
        get name() {
            return Il2Cpp.api.fieldGetName(this).readUtf8String();
        }
        /** Gets the offset of this field, calculated as the difference with its owner virtual address. */
        get offset() {
            return Il2Cpp.api.fieldGetOffset(this);
        }
        /** Gets the type of this field. */
        get type() {
            return new Il2Cpp.Type(Il2Cpp.api.fieldGetType(this));
        }
        /** Gets the value of this field. */
        get value() {
            if (!this.isStatic) {
                raise(`cannot access instance field ${this.class.type.name}::${this.name} from a class, use an object instead`);
            }
            const handle = Memory.alloc(Process.pointerSize);
            Il2Cpp.api.fieldGetStaticValue(this.handle, handle);
            return Il2Cpp.read(handle, this.type);
        }
        /** Sets the value of this field. Thread static or literal values cannot be altered yet. */
        set value(value) {
            if (!this.isStatic) {
                raise(`cannot access instance field ${this.class.type.name}::${this.name} from a class, use an object instead`);
            }
            if (this.isThreadStatic || this.isLiteral) {
                raise(`cannot write the value of field ${this.name} as it's thread static or literal`);
            }
            const handle = 
            // pointer-like values should be passed as-is, but boxed
            // value types (primitives included) must be unboxed first
            value instanceof Il2Cpp.Object && this.type.class.isValueType
                ? value.unbox()
                : value instanceof NativeStruct
                    ? value.handle
                    : value instanceof NativePointer
                        ? value
                        : Il2Cpp.write(Memory.alloc(this.type.class.valueTypeSize), value, this.type);
            Il2Cpp.api.fieldSetStaticValue(this.handle, handle);
        }
        /** */
        toString() {
            return `\
${this.isThreadStatic ? `[ThreadStatic] ` : ``}\
${this.isStatic ? `static ` : ``}\
${this.type.name} \
${this.name}\
${this.isLiteral ? ` = ${this.type.class.isEnum ? Il2Cpp.read(this.value.handle, this.type.class.baseType) : this.value}` : ``};\
${this.isThreadStatic || this.isLiteral ? `` : ` // 0x${this.offset.toString(16)}`}`;
        }
        /** @internal */
        withHolder(instance) {
            if (this.isStatic) {
                raise(`cannot access static field ${this.class.type.name}::${this.name} from an object, use a class instead`);
            }
            const valueHandle = instance.handle.add(this.offset - (instance instanceof Il2Cpp.ValueType ? Il2Cpp.Object.headerSize : 0));
            return new Proxy(this, {
                get(target, property) {
                    if (property == "value") {
                        return Il2Cpp.read(valueHandle, target.type);
                    }
                    return Reflect.get(target, property);
                },
                set(target, property, value) {
                    if (property == "value") {
                        Il2Cpp.write(valueHandle, value, target.type);
                        return true;
                    }
                    return Reflect.set(target, property, value);
                }
            });
        }
    }
    __decorate([
        lazy
    ], Field.prototype, "class", null);
    __decorate([
        lazy
    ], Field.prototype, "flags", null);
    __decorate([
        lazy
    ], Field.prototype, "isLiteral", null);
    __decorate([
        lazy
    ], Field.prototype, "isStatic", null);
    __decorate([
        lazy
    ], Field.prototype, "isThreadStatic", null);
    __decorate([
        lazy
    ], Field.prototype, "modifier", null);
    __decorate([
        lazy
    ], Field.prototype, "name", null);
    __decorate([
        lazy
    ], Field.prototype, "offset", null);
    __decorate([
        lazy
    ], Field.prototype, "type", null);
    Il2Cpp.Field = Field;
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    class GCHandle {
        handle;
        /** @internal */
        constructor(handle) {
            this.handle = handle;
        }
        /** Gets the object associated to this handle. */
        get target() {
            return new Il2Cpp.Object(Il2Cpp.api.gcHandleGetTarget(this.handle)).asNullable();
        }
        /** Frees this handle. */
        free() {
            return Il2Cpp.api.gcHandleFree(this.handle);
        }
    }
    Il2Cpp.GCHandle = GCHandle;
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    let Image = class Image extends NativeStruct {
        /** Gets the assembly in which the current image is defined. */
        get assembly() {
            return new Il2Cpp.Assembly(Il2Cpp.api.imageGetAssembly(this));
        }
        /** Gets the amount of classes defined in this image. */
        get classCount() {
            if (Il2Cpp.unityVersionIsBelow201830) {
                return this.classes.length;
            }
            else {
                return Il2Cpp.api.imageGetClassCount(this);
            }
        }
        /** Gets the classes defined in this image. */
        get classes() {
            if (Il2Cpp.unityVersionIsBelow201830) {
                const types = this.assembly.object.method("GetTypes").invoke(false);
                // In Unity 5.3.8f1, getting System.Reflection.Emit.OpCodes type name
                // without iterating all the classes first somehow blows things up at
                // app startup, hence the `Array.from`.
                const classes = globalThis.Array.from(types, _ => new Il2Cpp.Class(Il2Cpp.api.classFromObject(_)));
                classes.unshift(this.class("<Module>"));
                return classes;
            }
            else {
                return globalThis.Array.from(globalThis.Array(this.classCount), (_, i) => new Il2Cpp.Class(Il2Cpp.api.imageGetClass(this, i)));
            }
        }
        /** Gets the name of this image. */
        get name() {
            return Il2Cpp.api.imageGetName(this).readUtf8String();
        }
        /** Gets the class with the specified name defined in this image. */
        class(name) {
            return this.tryClass(name) ?? raise(`couldn't find class ${name} in assembly ${this.name}`);
        }
        /** Gets the class with the specified name defined in this image. */
        tryClass(name) {
            const dotIndex = name.lastIndexOf(".");
            const classNamespace = Memory.allocUtf8String(dotIndex == -1 ? "" : name.slice(0, dotIndex));
            const className = Memory.allocUtf8String(name.slice(dotIndex + 1));
            return new Il2Cpp.Class(Il2Cpp.api.classFromName(this, classNamespace, className)).asNullable();
        }
    };
    __decorate([
        lazy
    ], Image.prototype, "assembly", null);
    __decorate([
        lazy
    ], Image.prototype, "classCount", null);
    __decorate([
        lazy
    ], Image.prototype, "classes", null);
    __decorate([
        lazy
    ], Image.prototype, "name", null);
    Image = __decorate([
        recycle
    ], Image);
    Il2Cpp.Image = Image;
    // prettier-ignore
    getter(Il2Cpp, "corlib", () => {
        return new Il2Cpp.Image(Il2Cpp.api.getCorlib());
    }, lazy);
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    class MemorySnapshot extends NativeStruct {
        /** Captures a memory snapshot. */
        static capture() {
            return new Il2Cpp.MemorySnapshot();
        }
        /** Creates a memory snapshot with the given handle. */
        constructor(handle = Il2Cpp.api.memorySnapshotCapture()) {
            super(handle);
        }
        /** Gets any initialized class. */
        get classes() {
            return readNativeIterator(_ => Il2Cpp.api.memorySnapshotGetClasses(this, _)).map(_ => new Il2Cpp.Class(_));
        }
        /** Gets the objects tracked by this memory snapshot. */
        get objects() {
            // prettier-ignore
            return readNativeList(_ => Il2Cpp.api.memorySnapshotGetObjects(this, _)).filter(_ => !_.isNull()).map(_ => new Il2Cpp.Object(_));
        }
        /** Frees this memory snapshot. */
        free() {
            Il2Cpp.api.memorySnapshotFree(this);
        }
    }
    __decorate([
        lazy
    ], MemorySnapshot.prototype, "classes", null);
    __decorate([
        lazy
    ], MemorySnapshot.prototype, "objects", null);
    Il2Cpp.MemorySnapshot = MemorySnapshot;
    /** */
    function memorySnapshot(block) {
        const memorySnapshot = Il2Cpp.MemorySnapshot.capture();
        const result = block(memorySnapshot);
        memorySnapshot.free();
        return result;
    }
    Il2Cpp.memorySnapshot = memorySnapshot;
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    class Method extends NativeStruct {
        /** Gets the class in which this method is defined. */
        get class() {
            return new Il2Cpp.Class(Il2Cpp.api.methodGetClass(this));
        }
        /** Gets the flags of the current method. */
        get flags() {
            return Il2Cpp.api.methodGetFlags(this, NULL);
        }
        /** Gets the implementation flags of the current method. */
        get implementationFlags() {
            const implementationFlagsPointer = Memory.alloc(Process.pointerSize);
            Il2Cpp.api.methodGetFlags(this, implementationFlagsPointer);
            return implementationFlagsPointer.readU32();
        }
        /** */
        get fridaSignature() {
            const types = [];
            for (const parameter of this.parameters) {
                types.push(parameter.type.fridaAlias);
            }
            if (!this.isStatic || Il2Cpp.unityVersionIsBelow201830) {
                types.unshift("pointer");
            }
            if (this.isInflated) {
                types.push("pointer");
            }
            return types;
        }
        /** Gets the generic parameters of this generic method. */
        get generics() {
            if (!this.isGeneric && !this.isInflated) {
                return [];
            }
            const types = this.object.method("GetGenericArguments").invoke();
            return globalThis.Array.from(types).map(_ => new Il2Cpp.Class(Il2Cpp.api.classFromObject(_)));
        }
        /** Determines whether this method is external. */
        get isExternal() {
            return (this.implementationFlags & 4096 /* Il2Cpp.Method.ImplementationAttribute.InternalCall */) != 0;
        }
        /** Determines whether this method is generic. */
        get isGeneric() {
            return !!Il2Cpp.api.methodIsGeneric(this);
        }
        /** Determines whether this method is inflated (generic with a concrete type parameter). */
        get isInflated() {
            return !!Il2Cpp.api.methodIsInflated(this);
        }
        /** Determines whether this method is static. */
        get isStatic() {
            return !Il2Cpp.api.methodIsInstance(this);
        }
        /** Determines whether this method is synchronized. */
        get isSynchronized() {
            return (this.implementationFlags & 32 /* Il2Cpp.Method.ImplementationAttribute.Synchronized */) != 0;
        }
        /** Gets the access modifier of this method. */
        get modifier() {
            switch (this.flags & 7 /* Il2Cpp.Method.Attributes.MemberAccessMask */) {
                case 1 /* Il2Cpp.Method.Attributes.Private */:
                    return "private";
                case 2 /* Il2Cpp.Method.Attributes.FamilyAndAssembly */:
                    return "private protected";
                case 3 /* Il2Cpp.Method.Attributes.Assembly */:
                    return "internal";
                case 4 /* Il2Cpp.Method.Attributes.Family */:
                    return "protected";
                case 5 /* Il2Cpp.Method.Attributes.FamilyOrAssembly */:
                    return "protected internal";
                case 6 /* Il2Cpp.Method.Attributes.Public */:
                    return "public";
            }
        }
        /** Gets the name of this method. */
        get name() {
            return Il2Cpp.api.methodGetName(this).readUtf8String();
        }
        /** @internal */
        get nativeFunction() {
            return new NativeFunction(this.virtualAddress, this.returnType.fridaAlias, this.fridaSignature);
        }
        /** Gets the encompassing object of the current method. */
        get object() {
            return new Il2Cpp.Object(Il2Cpp.api.methodGetObject(this, NULL));
        }
        /** Gets the amount of parameters of this method. */
        get parameterCount() {
            return Il2Cpp.api.methodGetParameterCount(this);
        }
        /** Gets the parameters of this method. */
        get parameters() {
            return globalThis.Array.from(globalThis.Array(this.parameterCount), (_, i) => {
                const parameterName = Il2Cpp.api.methodGetParameterName(this, i).readUtf8String();
                const parameterType = Il2Cpp.api.methodGetParameterType(this, i);
                return new Il2Cpp.Parameter(parameterName, i, new Il2Cpp.Type(parameterType));
            });
        }
        /** Gets the relative virtual address (RVA) of this method. */
        get relativeVirtualAddress() {
            return this.virtualAddress.sub(Il2Cpp.module.base);
        }
        /** Gets the return type of this method. */
        get returnType() {
            return new Il2Cpp.Type(Il2Cpp.api.methodGetReturnType(this));
        }
        /** Gets the virtual address (VA) of this method. */
        get virtualAddress() {
            const FilterTypeName = Il2Cpp.corlib.class("System.Reflection.Module").initialize().field("FilterTypeName").value;
            const FilterTypeNameMethodPointer = FilterTypeName.field("method_ptr").value;
            const FilterTypeNameMethod = FilterTypeName.field("method").value;
            // prettier-ignore
            const offset = FilterTypeNameMethod.offsetOf(_ => _.readPointer().equals(FilterTypeNameMethodPointer))
                ?? raise("couldn't find the virtual address offset in the native method struct");
            // prettier-ignore
            getter(Il2Cpp.Method.prototype, "virtualAddress", function () {
                return this.handle.add(offset).readPointer();
            }, lazy);
            // In Unity 2017.4.40f1 (don't know about others), Il2Cpp.Class::initialize
            // somehow triggers a nasty bug during early instrumentation, so that we aren't
            // able to obtain the offset to get the virtual address of a method when the script
            // is reloaded.
            // A workaround consists in manually re-invoking the static constructor.
            Il2Cpp.corlib.class("System.Reflection.Module").method(".cctor").invoke();
            return this.virtualAddress;
        }
        /** Replaces the body of this method. */
        set implementation(block) {
            try {
                Interceptor.replace(this.virtualAddress, this.wrap(block));
            }
            catch (e) {
                switch (e.message) {
                    case "access violation accessing 0x0":
                        raise(`couldn't set implementation for method ${this.name} as it has a NULL virtual address`);
                    case /unable to intercept function at \w+; please file a bug/.exec(e.message)?.input:
                        warn(`couldn't set implementation for method ${this.name} as it may be a thunk`);
                        break;
                    case "already replaced this function":
                        warn(`couldn't set implementation for method ${this.name} as it has already been replaced by a thunk`);
                        break;
                    default:
                        throw e;
                }
            }
        }
        /** Creates a generic instance of the current generic method. */
        inflate(...classes) {
            if (!this.isGeneric) {
                raise(`cannot inflate method ${this.name} as it has no generic parameters`);
            }
            if (this.generics.length != classes.length) {
                raise(`cannot inflate method ${this.name} as it needs ${this.generics.length} generic parameter(s), not ${classes.length}`);
            }
            const types = classes.map(_ => _.type.object);
            const typeArray = Il2Cpp.array(Il2Cpp.corlib.class("System.Type"), types);
            const inflatedMethodObject = this.object.method("MakeGenericMethod", 1).invoke(typeArray);
            return new Il2Cpp.Method(inflatedMethodObject.field("mhandle").value);
        }
        /** Invokes this method. */
        invoke(...parameters) {
            if (!this.isStatic) {
                raise(`cannot invoke non-static method ${this.name} as it must be invoked throught a Il2Cpp.Object, not a Il2Cpp.Class`);
            }
            return this.invokeRaw(NULL, ...parameters);
        }
        /** @internal */
        invokeRaw(instance, ...parameters) {
            const allocatedParameters = parameters.map(Il2Cpp.toFridaValue);
            if (!this.isStatic || Il2Cpp.unityVersionIsBelow201830) {
                allocatedParameters.unshift(instance);
            }
            if (this.isInflated) {
                allocatedParameters.push(this.handle);
            }
            try {
                const returnValue = this.nativeFunction(...allocatedParameters);
                return Il2Cpp.fromFridaValue(returnValue, this.returnType);
            }
            catch (e) {
                if (e == null) {
                    raise("an unexpected native invocation exception occurred, this is due to parameter types mismatch");
                }
                switch (e.message) {
                    case "bad argument count":
                        raise(`couldn't invoke method ${this.name} as it needs ${this.parameterCount} parameter(s), not ${parameters.length}`);
                    case "expected a pointer":
                    case "expected number":
                    case "expected array with fields":
                        raise(`couldn't invoke method ${this.name} using incorrect parameter types`);
                }
                throw e;
            }
        }
        /** Gets the overloaded method with the given parameter types. */
        overload(...parameterTypes) {
            const result = this.tryOverload(...parameterTypes);
            if (result != undefined)
                return result;
            raise(`couldn't find overloaded method ${this.name}(${parameterTypes})`);
        }
        /** Gets the parameter with the given name. */
        parameter(name) {
            return this.tryParameter(name) ?? raise(`couldn't find parameter ${name} in method ${this.name}`);
        }
        /** Restore the original method implementation. */
        revert() {
            Interceptor.revert(this.virtualAddress);
            Interceptor.flush();
        }
        /** Gets the overloaded method with the given parameter types. */
        tryOverload(...parameterTypes) {
            return this.class.methods.find(method => {
                return (method.name == this.name &&
                    method.parameterCount == parameterTypes.length &&
                    method.parameters.every((e, i) => e.type.name == parameterTypes[i]));
            });
        }
        /** Gets the parameter with the given name. */
        tryParameter(name) {
            return this.parameters.find(_ => _.name == name);
        }
        /** */
        toString() {
            return `\
${this.isStatic ? `static ` : ``}\
${this.returnType.name} \
${this.name}\
(${this.parameters.join(`, `)});\
${this.virtualAddress.isNull() ? `` : ` // 0x${this.relativeVirtualAddress.toString(16).padStart(8, `0`)}`}`;
        }
        /** @internal */
        withHolder(instance) {
            if (this.isStatic) {
                raise(`cannot access static method ${this.class.type.name}::${this.name} from an object, use a class instead`);
            }
            return new Proxy(this, {
                get(target, property) {
                    switch (property) {
                        case "invoke":
                            // value types methods may assume their `this`
                            // parameter is a pointer to raw data (that is how
                            // value types are layed out in memory) instead of
                            // a pointer to an object (that is object header +
                            // raw data)
                            // in any case, they also don't use whatever there
                            // is in the object header, so we can safely "skip"
                            // the object header by adding the object header
                            // size to the object (a boxed value type) handle
                            //
                            // observed in Unity 5.3.5f1 and >= 2021.2.0f1
                            const handle = instance instanceof Il2Cpp.ValueType
                                ? target.class.isValueType
                                    ? instance.handle.add(maybeObjectHeaderSize() - Il2Cpp.Object.headerSize)
                                    : raise(`cannot invoke method ${target.class.type.name}::${target.name} against a value type, you must box it first`)
                                : target.class.isValueType
                                    ? instance.handle.add(maybeObjectHeaderSize())
                                    : instance.handle;
                            return target.invokeRaw.bind(target, handle);
                        case "inflate":
                        case "overload":
                        case "tryOverload":
                            return function (...args) {
                                return target[property](...args)?.withHolder(instance);
                            };
                    }
                    return Reflect.get(target, property);
                }
            });
        }
        /** @internal */
        wrap(block) {
            const startIndex = +!this.isStatic | +Il2Cpp.unityVersionIsBelow201830;
            return new NativeCallback((...args) => {
                const thisObject = this.isStatic
                    ? this.class
                    : this.class.isValueType
                        ? new Il2Cpp.ValueType(args[0].add(Il2Cpp.Object.headerSize - maybeObjectHeaderSize()), this.class.type)
                        : new Il2Cpp.Object(args[0]);
                const parameters = this.parameters.map((_, i) => Il2Cpp.fromFridaValue(args[i + startIndex], _.type));
                const result = block.call(thisObject, ...parameters);
                return Il2Cpp.toFridaValue(result);
            }, this.returnType.fridaAlias, this.fridaSignature);
        }
    }
    __decorate([
        lazy
    ], Method.prototype, "class", null);
    __decorate([
        lazy
    ], Method.prototype, "flags", null);
    __decorate([
        lazy
    ], Method.prototype, "implementationFlags", null);
    __decorate([
        lazy
    ], Method.prototype, "fridaSignature", null);
    __decorate([
        lazy
    ], Method.prototype, "generics", null);
    __decorate([
        lazy
    ], Method.prototype, "isExternal", null);
    __decorate([
        lazy
    ], Method.prototype, "isGeneric", null);
    __decorate([
        lazy
    ], Method.prototype, "isInflated", null);
    __decorate([
        lazy
    ], Method.prototype, "isStatic", null);
    __decorate([
        lazy
    ], Method.prototype, "isSynchronized", null);
    __decorate([
        lazy
    ], Method.prototype, "modifier", null);
    __decorate([
        lazy
    ], Method.prototype, "name", null);
    __decorate([
        lazy
    ], Method.prototype, "nativeFunction", null);
    __decorate([
        lazy
    ], Method.prototype, "object", null);
    __decorate([
        lazy
    ], Method.prototype, "parameterCount", null);
    __decorate([
        lazy
    ], Method.prototype, "parameters", null);
    __decorate([
        lazy
    ], Method.prototype, "relativeVirtualAddress", null);
    __decorate([
        lazy
    ], Method.prototype, "returnType", null);
    Il2Cpp.Method = Method;
    let maybeObjectHeaderSize = () => {
        const struct = Il2Cpp.corlib.class("System.RuntimeTypeHandle").initialize().alloc();
        struct.method(".ctor").invokeRaw(struct, ptr(0xdeadbeef));
        // here we check where the sentinel value is
        // if it's not where it is supposed to be, it means struct methods
        // assume they are receiving value types (that is a pointer to raw data)
        // hence, we must "skip" the object header when invoking such methods
        const offset = struct.field("value").value.equals(ptr(0xdeadbeef)) ? 0 : Il2Cpp.Object.headerSize;
        return (maybeObjectHeaderSize = () => offset)();
    };
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    class Object extends NativeStruct {
        /** Gets the Il2CppObject struct size, possibly equal to `Process.pointerSize * 2`. */
        static get headerSize() {
            return Il2Cpp.corlib.class("System.Object").instanceSize;
        }
        /** Gets the class of this object. */
        get class() {
            return new Il2Cpp.Class(Il2Cpp.api.objectGetClass(this));
        }
        /** Returns a monitor for this object. */
        get monitor() {
            return new Il2Cpp.Object.Monitor(this);
        }
        /** Gets the size of the current object. */
        get size() {
            return Il2Cpp.api.objectGetSize(this);
        }
        /** Gets the field with the given name. */
        field(name) {
            return this.class.field(name).withHolder(this);
        }
        /** Gets the method with the given name. */
        method(name, parameterCount = -1) {
            return this.class.method(name, parameterCount).withHolder(this);
        }
        /** Creates a reference to this object. */
        ref(pin) {
            return new Il2Cpp.GCHandle(Il2Cpp.api.gcHandleNew(this, +pin));
        }
        /** Gets the correct virtual method from the given virtual method. */
        virtualMethod(method) {
            return new Il2Cpp.Method(Il2Cpp.api.objectGetVirtualMethod(this, method)).withHolder(this);
        }
        /** Gets the field with the given name. */
        tryField(name) {
            return this.class.tryField(name)?.withHolder(this);
        }
        /** Gets the field with the given name. */
        tryMethod(name, parameterCount = -1) {
            return this.class.tryMethod(name, parameterCount)?.withHolder(this);
        }
        /** */
        toString() {
            return this.isNull() ? "null" : this.method("ToString", 0).invoke().content ?? "null";
        }
        /** Unboxes the value type (either a primitive, a struct or an enum) out of this object. */
        unbox() {
            return this.class.isValueType
                ? new Il2Cpp.ValueType(Il2Cpp.api.objectUnbox(this), this.class.type)
                : raise(`couldn't unbox instances of ${this.class.type.name} as they are not value types`);
        }
        /** Creates a weak reference to this object. */
        weakRef(trackResurrection) {
            return new Il2Cpp.GCHandle(Il2Cpp.api.gcHandleNewWeakRef(this, +trackResurrection));
        }
    }
    __decorate([
        lazy
    ], Object.prototype, "class", null);
    __decorate([
        lazy
    ], Object.prototype, "size", null);
    __decorate([
        lazy
    ], Object, "headerSize", null);
    Il2Cpp.Object = Object;
    (function (Object) {
        class Monitor {
            handle;
            /** @internal */
            constructor(/** @internal */ handle) {
                this.handle = handle;
            }
            /** Acquires an exclusive lock on the current object. */
            enter() {
                return Il2Cpp.api.monitorEnter(this.handle);
            }
            /** Release an exclusive lock on the current object. */
            exit() {
                return Il2Cpp.api.monitorExit(this.handle);
            }
            /** Notifies a thread in the waiting queue of a change in the locked object's state. */
            pulse() {
                return Il2Cpp.api.monitorPulse(this.handle);
            }
            /** Notifies all waiting threads of a change in the object's state. */
            pulseAll() {
                return Il2Cpp.api.monitorPulseAll(this.handle);
            }
            /** Attempts to acquire an exclusive lock on the current object. */
            tryEnter(timeout) {
                return !!Il2Cpp.api.monitorTryEnter(this.handle, timeout);
            }
            /** Releases the lock on an object and attempts to block the current thread until it reacquires the lock. */
            tryWait(timeout) {
                return !!Il2Cpp.api.monitorTryWait(this.handle, timeout);
            }
            /** Releases the lock on an object and blocks the current thread until it reacquires the lock. */
            wait() {
                return Il2Cpp.api.monitorWait(this.handle);
            }
        }
        Object.Monitor = Monitor;
    })(Object = Il2Cpp.Object || (Il2Cpp.Object = {}));
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    class Parameter {
        /** Name of this parameter. */
        name;
        /** Position of this parameter. */
        position;
        /** Type of this parameter. */
        type;
        constructor(name, position, type) {
            this.name = name;
            this.position = position;
            this.type = type;
        }
        /** */
        toString() {
            return `${this.type.name} ${this.name}`;
        }
    }
    Il2Cpp.Parameter = Parameter;
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    class Pointer extends NativeStruct {
        type;
        constructor(handle, type) {
            super(handle);
            this.type = type;
        }
        /** Gets the element at the given index. */
        get(index) {
            return Il2Cpp.read(this.handle.add(index * this.type.class.arrayElementSize), this.type);
        }
        /** Reads the given amount of elements starting at the given offset. */
        read(length, offset = 0) {
            const values = new globalThis.Array(length);
            for (let i = 0; i < length; i++) {
                values[i] = this.get(i + offset);
            }
            return values;
        }
        /** Sets the given element at the given index */
        set(index, value) {
            Il2Cpp.write(this.handle.add(index * this.type.class.arrayElementSize), value, this.type);
        }
        /** */
        toString() {
            return this.handle.toString();
        }
        /** Writes the given elements starting at the given index. */
        write(values, offset = 0) {
            for (let i = 0; i < values.length; i++) {
                this.set(i + offset, values[i]);
            }
        }
    }
    Il2Cpp.Pointer = Pointer;
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    class Reference extends NativeStruct {
        type;
        constructor(handle, type) {
            super(handle);
            this.type = type;
        }
        /** Gets the element referenced by the current reference. */
        get value() {
            return Il2Cpp.read(this.handle, this.type);
        }
        /** Sets the element referenced by the current reference. */
        set value(value) {
            Il2Cpp.write(this.handle, value, this.type);
        }
        /** */
        toString() {
            return this.isNull() ? "null" : `->${this.value}`;
        }
    }
    Il2Cpp.Reference = Reference;
    /** Creates a reference to the specified value. */
    function reference(value, type) {
        const handle = Memory.alloc(Process.pointerSize);
        switch (typeof value) {
            case "boolean":
                return new Il2Cpp.Reference(handle.writeS8(+value), Il2Cpp.corlib.class("System.Boolean").type);
            case "number":
                switch (type?.typeEnum) {
                    case Il2Cpp.Type.enum.unsignedByte:
                        return new Il2Cpp.Reference(handle.writeU8(value), type);
                    case Il2Cpp.Type.enum.byte:
                        return new Il2Cpp.Reference(handle.writeS8(value), type);
                    case Il2Cpp.Type.enum.char:
                    case Il2Cpp.Type.enum.unsignedShort:
                        return new Il2Cpp.Reference(handle.writeU16(value), type);
                    case Il2Cpp.Type.enum.short:
                        return new Il2Cpp.Reference(handle.writeS16(value), type);
                    case Il2Cpp.Type.enum.unsignedInt:
                        return new Il2Cpp.Reference(handle.writeU32(value), type);
                    case Il2Cpp.Type.enum.int:
                        return new Il2Cpp.Reference(handle.writeS32(value), type);
                    case Il2Cpp.Type.enum.unsignedLong:
                        return new Il2Cpp.Reference(handle.writeU64(value), type);
                    case Il2Cpp.Type.enum.long:
                        return new Il2Cpp.Reference(handle.writeS64(value), type);
                    case Il2Cpp.Type.enum.float:
                        return new Il2Cpp.Reference(handle.writeFloat(value), type);
                    case Il2Cpp.Type.enum.double:
                        return new Il2Cpp.Reference(handle.writeDouble(value), type);
                }
            case "object":
                if (value instanceof Il2Cpp.ValueType || value instanceof Il2Cpp.Pointer) {
                    return new Il2Cpp.Reference(handle.writePointer(value), value.type);
                }
                else if (value instanceof Il2Cpp.Object) {
                    return new Il2Cpp.Reference(handle.writePointer(value), value.class.type);
                }
                else if (value instanceof Il2Cpp.String || value instanceof Il2Cpp.Array) {
                    return new Il2Cpp.Reference(handle.writePointer(value), value.object.class.type);
                }
                else if (value instanceof NativePointer) {
                    switch (type?.typeEnum) {
                        case Il2Cpp.Type.enum.unsignedNativePointer:
                        case Il2Cpp.Type.enum.nativePointer:
                            return new Il2Cpp.Reference(handle.writePointer(value), type);
                    }
                }
                else if (value instanceof Int64) {
                    return new Il2Cpp.Reference(handle.writeS64(value), Il2Cpp.corlib.class("System.Int64").type);
                }
                else if (value instanceof UInt64) {
                    return new Il2Cpp.Reference(handle.writeU64(value), Il2Cpp.corlib.class("System.UInt64").type);
                }
            default:
                raise(`couldn't create a reference to ${value} using an unhandled type ${type?.name}`);
        }
    }
    Il2Cpp.reference = reference;
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    class String extends NativeStruct {
        /** Gets the content of this string. */
        get content() {
            return Il2Cpp.api.stringGetChars(this).readUtf16String(this.length);
        }
        /** @unsafe Sets the content of this string - it may write out of bounds! */
        set content(value) {
            // prettier-ignore
            const offset = Il2Cpp.string("vfsfitvnm").handle.offsetOf(_ => _.readInt() == 9)
                ?? raise("couldn't find the length offset in the native string struct");
            globalThis.Object.defineProperty(Il2Cpp.String.prototype, "content", {
                set(value) {
                    Il2Cpp.api.stringGetChars(this).writeUtf16String(value ?? "");
                    this.handle.add(offset).writeS32(value?.length ?? 0);
                }
            });
            this.content = value;
        }
        /** Gets the length of this string. */
        get length() {
            return Il2Cpp.api.stringGetLength(this);
        }
        /** Gets the encompassing object of the current string. */
        get object() {
            return new Il2Cpp.Object(this);
        }
        /** */
        toString() {
            return this.isNull() ? "null" : `"${this.content}"`;
        }
    }
    Il2Cpp.String = String;
    /** Creates a new string with the specified content. */
    function string(content) {
        return new Il2Cpp.String(Il2Cpp.api.stringNew(Memory.allocUtf8String(content ?? "")));
    }
    Il2Cpp.string = string;
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    class Thread extends NativeStruct {
        /** Gets the native id of the current thread. */
        get id() {
            let get = function () {
                return this.internal.field("thread_id").value.toNumber();
            };
            // https://github.com/mono/linux-packaging-mono/blob/d586f84dfea30217f34b076a616a098518aa72cd/mono/utils/mono-threads.h#L642
            if (Process.platform != "windows") {
                const currentThreadId = Process.getCurrentThreadId();
                const currentPosixThread = ptr(get.apply(Il2Cpp.currentThread));
                // prettier-ignore
                const offset = currentPosixThread.offsetOf(_ => _.readS32() == currentThreadId, 1024) ??
                    raise(`couldn't find the offset for determining the kernel id of a posix thread`);
                const _get = get;
                get = function () {
                    return ptr(_get.apply(this)).add(offset).readS32();
                };
            }
            getter(Il2Cpp.Thread.prototype, "id", get, lazy);
            return this.id;
        }
        /** Gets the encompassing internal object (System.Threding.InternalThreead) of the current thread. */
        get internal() {
            return this.object.tryField("internal_thread")?.value ?? this.object;
        }
        /** Determines whether the current thread is the garbage collector finalizer one. */
        get isFinalizer() {
            return !Il2Cpp.api.threadIsVm(this);
        }
        /** Gets the managed id of the current thread. */
        get managedId() {
            return this.object.method("get_ManagedThreadId").invoke();
        }
        /** Gets the encompassing object of the current thread. */
        get object() {
            return new Il2Cpp.Object(this);
        }
        /** @internal */
        get staticData() {
            return this.internal.field("static_data").value;
        }
        /** @internal */
        get synchronizationContext() {
            const get_ExecutionContext = this.object.tryMethod("GetMutableExecutionContext") ?? this.object.method("get_ExecutionContext");
            const executionContext = get_ExecutionContext.invoke();
            let synchronizationContext = executionContext.tryField("_syncContext")?.value ??
                executionContext.tryMethod("get_SynchronizationContext")?.invoke() ??
                this.tryLocalValue(Il2Cpp.corlib.class("System.Threading.SynchronizationContext"));
            if (synchronizationContext == null || synchronizationContext.isNull()) {
                if (this.handle.equals(Il2Cpp.mainThread.handle)) {
                    raise(`couldn't find the synchronization context of the main thread, perhaps this is early instrumentation?`);
                }
                else {
                    raise(`couldn't find the synchronization context of thread #${this.managedId}, only the main thread is expected to have one`);
                }
            }
            return synchronizationContext;
        }
        /** Detaches the thread from the application domain. */
        detach() {
            return Il2Cpp.api.threadDetach(this);
        }
        /** Schedules a callback on the current thread. */
        schedule(block) {
            const Post = this.synchronizationContext.method("Post");
            return new Promise(resolve => {
                const delegate = Il2Cpp.delegate(Il2Cpp.corlib.class("System.Threading.SendOrPostCallback"), () => {
                    const result = block();
                    setImmediate(() => resolve(result));
                });
                // This is to replace pending scheduled callbacks when the script is about to get unlaoded.
                // If we skip this cleanup, Frida's native callbacks will point to invalid memory, making
                // the application crash as soon as the IL2CPP runtime tries to execute such callbacks.
                // For instance, without the following code, this is how you can trigger a crash:
                // 1) unfocus the application;
                // 2) schedule a callback;
                // 3) reload the script;
                // 4) focus application.
                //
                // The "proper" solution consists in removing our delegates from the Unity synchroniztion
                // context, but the interface is not consisent across Unity versions - e.g. 2017.4.40f1 uses
                // a queue instead of a list, whereas newer versions do not allow null work requests.
                // The following solution, which basically redirects the invocation to a native function that
                // survives the script reloading, is much simpler, honestly.
                Script.bindWeak(globalThis, () => {
                    delegate.field("method_ptr").value = delegate.field("invoke_impl").value = Il2Cpp.api.domainGet;
                });
                Post.invoke(delegate, NULL);
            });
        }
        /** @internal */
        tryLocalValue(klass) {
            for (let i = 0; i < 16; i++) {
                const base = this.staticData.add(i * Process.pointerSize).readPointer();
                if (!base.isNull()) {
                    const object = new Il2Cpp.Object(base.readPointer()).asNullable();
                    if (object?.class?.isSubclassOf(klass, false)) {
                        return object;
                    }
                }
            }
        }
    }
    __decorate([
        lazy
    ], Thread.prototype, "internal", null);
    __decorate([
        lazy
    ], Thread.prototype, "isFinalizer", null);
    __decorate([
        lazy
    ], Thread.prototype, "managedId", null);
    __decorate([
        lazy
    ], Thread.prototype, "object", null);
    __decorate([
        lazy
    ], Thread.prototype, "staticData", null);
    __decorate([
        lazy
    ], Thread.prototype, "synchronizationContext", null);
    Il2Cpp.Thread = Thread;
    getter(Il2Cpp, "attachedThreads", () => {
        return readNativeList(Il2Cpp.api.threadGetAttachedThreads).map(_ => new Il2Cpp.Thread(_));
    });
    getter(Il2Cpp, "currentThread", () => {
        return new Il2Cpp.Thread(Il2Cpp.api.threadGetCurrent()).asNullable();
    });
    getter(Il2Cpp, "mainThread", () => {
        // I'm not sure if this is always the case. Typically, the main
        // thread managed id is 1, but this isn't always true: spawning
        // an Android application with Unity 5.3.8f1 will cause the Frida
        // thread to have the managed id equal to 1, whereas the main thread
        // managed id is 2.
        return Il2Cpp.attachedThreads[0];
    });
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    let Type = class Type extends NativeStruct {
        /** */
        static get enum() {
            const _ = (_, block = (_) => _) => block(Il2Cpp.corlib.class(_)).type.typeEnum;
            return {
                void: _("System.Void"),
                boolean: _("System.Boolean"),
                char: _("System.Char"),
                byte: _("System.SByte"),
                unsignedByte: _("System.Byte"),
                short: _("System.Int16"),
                unsignedShort: _("System.UInt16"),
                int: _("System.Int32"),
                unsignedInt: _("System.UInt32"),
                long: _("System.Int64"),
                unsignedLong: _("System.UInt64"),
                nativePointer: _("System.IntPtr"),
                unsignedNativePointer: _("System.UIntPtr"),
                float: _("System.Single"),
                double: _("System.Double"),
                pointer: _("System.IntPtr", _ => _.field("m_value")),
                valueType: _("System.Decimal"),
                object: _("System.Object"),
                string: _("System.String"),
                class: _("System.Array"),
                array: _("System.Void", _ => _.arrayClass),
                multidimensionalArray: _("System.Void", _ => new Il2Cpp.Class(Il2Cpp.api.classGetArrayClass(_, 2))),
                genericInstance: _("System.Int32", _ => _.interfaces.find(_ => _.name.endsWith("`1")))
            };
        }
        /** Gets the class of this type. */
        get class() {
            return new Il2Cpp.Class(Il2Cpp.api.typeGetClass(this));
        }
        /** */
        get fridaAlias() {
            function getValueTypeFields(type) {
                const instanceFields = type.class.fields.filter(_ => !_.isStatic);
                return instanceFields.length == 0 ? ["char"] : instanceFields.map(_ => _.type.fridaAlias);
            }
            if (this.isByReference) {
                return "pointer";
            }
            switch (this.typeEnum) {
                case Il2Cpp.Type.enum.void:
                    return "void";
                case Il2Cpp.Type.enum.boolean:
                    return "bool";
                case Il2Cpp.Type.enum.char:
                    return "uchar";
                case Il2Cpp.Type.enum.byte:
                    return "int8";
                case Il2Cpp.Type.enum.unsignedByte:
                    return "uint8";
                case Il2Cpp.Type.enum.short:
                    return "int16";
                case Il2Cpp.Type.enum.unsignedShort:
                    return "uint16";
                case Il2Cpp.Type.enum.int:
                    return "int32";
                case Il2Cpp.Type.enum.unsignedInt:
                    return "uint32";
                case Il2Cpp.Type.enum.long:
                    return "int64";
                case Il2Cpp.Type.enum.unsignedLong:
                    return "uint64";
                case Il2Cpp.Type.enum.float:
                    return "float";
                case Il2Cpp.Type.enum.double:
                    return "double";
                case Il2Cpp.Type.enum.nativePointer:
                case Il2Cpp.Type.enum.unsignedNativePointer:
                case Il2Cpp.Type.enum.pointer:
                case Il2Cpp.Type.enum.string:
                case Il2Cpp.Type.enum.array:
                case Il2Cpp.Type.enum.multidimensionalArray:
                    return "pointer";
                case Il2Cpp.Type.enum.valueType:
                    return this.class.isEnum ? this.class.baseType.fridaAlias : getValueTypeFields(this);
                case Il2Cpp.Type.enum.class:
                case Il2Cpp.Type.enum.object:
                case Il2Cpp.Type.enum.genericInstance:
                    return this.class.isStruct ? getValueTypeFields(this) : this.class.isEnum ? this.class.baseType.fridaAlias : "pointer";
                default:
                    return "pointer";
            }
        }
        /** Determines whether this type is passed by reference. */
        get isByReference() {
            return this.name.endsWith("&");
        }
        /** Determines whether this type is primitive. */
        get isPrimitive() {
            switch (this.typeEnum) {
                case Il2Cpp.Type.enum.boolean:
                case Il2Cpp.Type.enum.char:
                case Il2Cpp.Type.enum.byte:
                case Il2Cpp.Type.enum.unsignedByte:
                case Il2Cpp.Type.enum.short:
                case Il2Cpp.Type.enum.unsignedShort:
                case Il2Cpp.Type.enum.int:
                case Il2Cpp.Type.enum.unsignedInt:
                case Il2Cpp.Type.enum.long:
                case Il2Cpp.Type.enum.unsignedLong:
                case Il2Cpp.Type.enum.float:
                case Il2Cpp.Type.enum.double:
                case Il2Cpp.Type.enum.nativePointer:
                case Il2Cpp.Type.enum.unsignedNativePointer:
                    return true;
                default:
                    return false;
            }
        }
        /** Gets the name of this type. */
        get name() {
            const handle = Il2Cpp.api.typeGetName(this);
            try {
                return handle.readUtf8String();
            }
            finally {
                Il2Cpp.free(handle);
            }
        }
        /** Gets the encompassing object of the current type. */
        get object() {
            return new Il2Cpp.Object(Il2Cpp.api.typeGetObject(this));
        }
        /** Gets the type enum of the current type. */
        get typeEnum() {
            return Il2Cpp.api.typeGetTypeEnum(this);
        }
        /** */
        toString() {
            return this.name;
        }
    };
    __decorate([
        lazy
    ], Type.prototype, "class", null);
    __decorate([
        lazy
    ], Type.prototype, "fridaAlias", null);
    __decorate([
        lazy
    ], Type.prototype, "isByReference", null);
    __decorate([
        lazy
    ], Type.prototype, "isPrimitive", null);
    __decorate([
        lazy
    ], Type.prototype, "name", null);
    __decorate([
        lazy
    ], Type.prototype, "object", null);
    __decorate([
        lazy
    ], Type.prototype, "typeEnum", null);
    __decorate([
        lazy
    ], Type, "enum", null);
    Type = __decorate([
        recycle
    ], Type);
    Il2Cpp.Type = Type;
})(Il2Cpp || (Il2Cpp = {}));
var Il2Cpp;
(function (Il2Cpp) {
    class ValueType extends NativeStruct {
        type;
        constructor(handle, type) {
            super(handle);
            this.type = type;
        }
        /** Boxes the current value type in a object. */
        box() {
            return new Il2Cpp.Object(Il2Cpp.api.valueTypeBox(this.type.class, this));
        }
        /** Gets the field with the given name. */
        field(name) {
            return this.type.class.field(name).withHolder(this);
        }
        /** Gets the method with the given name. */
        method(name, parameterCount = -1) {
            return this.type.class.method(name, parameterCount).withHolder(this);
        }
        /** Gets the field with the given name. */
        tryField(name) {
            return this.type.class.tryField(name)?.withHolder(this);
        }
        /** Gets the field with the given name. */
        tryMethod(name, parameterCount = -1) {
            return this.type.class.tryMethod(name, parameterCount)?.withHolder(this);
        }
        /** */
        toString() {
            const ToString = this.method("ToString", 0);
            return this.isNull()
                ? "null"
                : // if ToString is defined within a value type class, we can
                    // avoid a boxing operaion
                    ToString.class.isValueType
                        ? ToString.invoke().content ?? "null"
                        : this.box().toString() ?? "null";
        }
    }
    Il2Cpp.ValueType = ValueType;
})(Il2Cpp || (Il2Cpp = {}));
/// <reference path="./utils/android.ts">/>
/// <reference path="./utils/console.ts">/>
/// <reference path="./utils/decorate.ts">/>
/// <reference path="./utils/getter.ts">/>
/// <reference path="./utils/lazy.ts">/>
/// <reference path="./utils/native-struct.ts">/>
/// <reference path="./utils/native-wait.ts">/>
/// <reference path="./utils/offset-of.ts">/>
/// <reference path="./utils/read-native-iterator.ts">/>
/// <reference path="./utils/read-native-list.ts">/>
/// <reference path="./utils/recycle.ts">/>
/// <reference path="./utils/unity-version.ts">/>
/// <reference path="./il2cpp/api.ts">/>
/// <reference path="./il2cpp/application.ts">/>
/// <reference path="./il2cpp/dump.ts">/>
/// <reference path="./il2cpp/exception-listener.ts">/>
/// <reference path="./il2cpp/filters.ts">/>
/// <reference path="./il2cpp/gc.ts">/>
/// <reference path="./il2cpp/memory.ts">/>
/// <reference path="./il2cpp/module.ts">/>
/// <reference path="./il2cpp/perform.ts">/>
/// <reference path="./il2cpp/tracer.ts">/>
/// <reference path="./il2cpp/structs/array.ts">/>
/// <reference path="./il2cpp/structs/assembly.ts">/>
/// <reference path="./il2cpp/structs/class.ts">/>
/// <reference path="./il2cpp/structs/delegate.ts">/>
/// <reference path="./il2cpp/structs/domain.ts">/>
/// <reference path="./il2cpp/structs/field.ts">/>
/// <reference path="./il2cpp/structs/gc-handle.ts">/>
/// <reference path="./il2cpp/structs/image.ts">/>
/// <reference path="./il2cpp/structs/memory-snapshot.ts">/>
/// <reference path="./il2cpp/structs/method.ts">/>
/// <reference path="./il2cpp/structs/object.ts">/>
/// <reference path="./il2cpp/structs/parameter.ts">/>
/// <reference path="./il2cpp/structs/pointer.ts">/>
/// <reference path="./il2cpp/structs/reference.ts">/>
/// <reference path="./il2cpp/structs/string.ts">/>
/// <reference path="./il2cpp/structs/thread.ts">/>
/// <reference path="./il2cpp/structs/type.ts">/>
/// <reference path="./il2cpp/structs/value-type.ts">/>
globalThis.Il2Cpp = Il2Cpp;